# 업무일지

## 기본 정보
- 날짜: 2026-02-10 (화요일) 1:30~2:30
- 작성자: hexsera

## 진행 목표
1. Pinball.jsx에 플리퍼 사운드 및 라이프다운 사운드 추가 (TDD)

---

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| RED: playFlipperSound 테스트 작성 | `frontend/src/test/PinballSound.test.jsx` | 신규 생성 |
| GREEN: pinballSound.js 생성 | `frontend/src/pinballSound.js` | playFlipperSound 구현 |
| RED: playLifeDownSound 테스트 추가 | `frontend/src/test/PinballSound.test.jsx` | 기존 파일에 추가 |
| GREEN: playLifeDownSound 구현 | `frontend/src/pinballSound.js` | 함수 추가 |
| GREEN: Pinball.jsx 사운드 연결 | `frontend/src/Pinball.jsx` | import + ref + 호출 |

---

## 주요 변경 사항

### 4. frontend/src/pinballSound.js 생성

**추가:**
```javascript
export function playFlipperSound(audio) {
  if (audio) {
    audio.currentTime = 0;
    audio.play();
  }
}

export function playLifeDownSound(audio) {
  if (audio) {
    audio.currentTime = 0;
    audio.play();
  }
}
```

**특징:**
- Audio 객체를 인자로 받아 사운드 로직만 순수하게 분리
- Pinball.jsx의 Matter.js 의존성 없이 독립적으로 테스트 가능

### 5. frontend/src/test/PinballSound.test.jsx 생성

**추가:**
```javascript
import { describe, it, expect, vi } from 'vitest'
import { playFlipperSound, playLifeDownSound } from '../pinballSound'

describe('playFlipperSound', () => {
  it('플리퍼 버튼을 누르면 flipper 사운드의 play()가 호출된다', () => {
    const mockPlay = vi.fn().mockResolvedValue(undefined)
    const mockAudio = { play: mockPlay, currentTime: 0 }
    playFlipperSound(mockAudio)
    expect(mockPlay).toHaveBeenCalledTimes(1)
  })
})

describe('playLifeDownSound', () => {
  it('life가 줄어들면 lifedown 사운드의 play()가 호출된다', () => {
    const mockPlay = vi.fn().mockResolvedValue(undefined)
    const mockAudio = { play: mockPlay, currentTime: 0 }
    playLifeDownSound(mockAudio)
    expect(mockPlay).toHaveBeenCalledTimes(1)
  })
})
```

**특징:**
- `vi.fn()`으로 Audio mock 생성 → jsdom 환경에서 실제 오디오 재생 없이 테스트
- play()가 1회 호출됐는지만 검증

### 6. frontend/src/Pinball.jsx 수정

**변경 전:**
```javascript
import { STAGE_CONFIGS } from './stageConfigs';

// ref 없음
// Audio 초기화 없음
// 키 이벤트에 사운드 없음
// 터치 이벤트에 사운드 없음
// deathZone에 사운드 없음
```

**변경 후:**
```javascript
import { STAGE_CONFIGS } from './stageConfigs';
import { playFlipperSound, playLifeDownSound } from './pinballSound';

// ref 추가
const fliperSoundRef = useRef(null);
const lifeDownSoundRef = useRef(null);

// Audio 초기화 추가
const fliperSound = new Audio('/audio/fliper.mp3');
fliperSound.volume = 0.5;
fliperSoundRef.current = fliperSound;

const lifeDownSound = new Audio('/audio/lifedown.wav');
lifeDownSound.volume = 0.7;
lifeDownSoundRef.current = lifeDownSound;

// 키 이벤트에 사운드 추가
if (event.key === 'ArrowLeft') {
  isLeftKeyPressed = true;
  playFlipperSound(fliperSoundRef.current);  // 추가
}
if (event.key === 'ArrowRight') {
  isRightKeyPressed = true;
  playFlipperSound(fliperSoundRef.current);  // 추가
}

// 터치 이벤트에 사운드 추가
if (touchX < centerX) {
  isLeftKeyPressed = true;
  playFlipperSound(fliperSoundRef.current);  // 추가
} else {
  isRightKeyPressed = true;
  playFlipperSound(fliperSoundRef.current);  // 추가
}

// deathZone에 사운드 추가
livesRef.current = newLives;
setLives(newLives);
playLifeDownSound(lifeDownSoundRef.current);  // 추가

// cleanup에 추가
if (fliperSoundRef.current) {
  fliperSoundRef.current.pause();
  fliperSoundRef.current.currentTime = 0;
}
if (lifeDownSoundRef.current) {
  lifeDownSoundRef.current.pause();
  lifeDownSoundRef.current.currentTime = 0;
}
```

**사운드 재생 시점:**
```
키보드 ArrowLeft/ArrowRight 눌림 → playFlipperSound() → fliper.mp3
터치 좌/우 시작 → playFlipperSound() → fliper.mp3
deathZone 충돌 (life 감소) → playLifeDownSound() → lifedown.wav
```

---

## 아키텍처

### 사운드 로직 분리 구조

```
변경 전:
┌───────────────────────────────┐
│         Pinball.jsx           │
│  - Matter.js 물리 엔진        │
│  - 사운드 로직 (직접 내장)    │  ← 테스트 불가
│  - 키/터치 이벤트             │
└───────────────────────────────┘

변경 후:
┌───────────────────────────────┐
│         Pinball.jsx           │
│  - Matter.js 물리 엔진        │
│  - 키/터치 이벤트             │
│  - playFlipperSound() 호출    │
│  - playLifeDownSound() 호출   │
└──────────────┬────────────────┘
               │ import
               ▼
┌───────────────────────────────┐
│       pinballSound.js         │
│  - playFlipperSound(audio)    │  ← 테스트 가능
│  - playLifeDownSound(audio)   │
└───────────────────────────────┘
               │ mock으로 대체
               ▼
┌───────────────────────────────┐
│    PinballSound.test.jsx      │
│  - mockAudio = { play: vi.fn }│
│  - expect(play).toHaveBeenCalled │
└───────────────────────────────┘
```

---

## 결과
- 상태: 완료

## 배운내용

## 다음 작업
- 방향키를 계속 누르면 플립퍼 오디오가 연속 재생됨


# 업무일지

## 기본 정보
- 날짜: 2026-02-10 (화) 2:30~3:00
- 작성자: hexsera

## 진행 목표
1. Pinball 게임오버 시 `gameover.mp3` 재생 기능 구현
2. 공이 bumper에 맞을 때 `bumper.mp3` 재생 기능 구현


## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| RED: 실패 테스트 작성 (playGameOverSound, playBumperSound) | `frontend/src/test/PinballSound.test.jsx` | 2개 테스트 실패 확인 |
| GREEN: pinballSound.js에 두 함수 구현 | `frontend/src/pinballSound.js` | 테스트 4/4 통과 |
| REFACTOR: Pinball.jsx에 사운드 연동 | `frontend/src/Pinball.jsx` | ref 추가, Audio 로드, 호출, cleanup |

## 주요 변경 사항

### 1. `frontend/src/test/PinballSound.test.jsx` 수정

**변경 전:**
```javascript
import { describe, it, expect, vi } from 'vitest'
import { playFlipperSound, playLifeDownSound } from '../pinballSound'

// playFlipperSound, playLifeDownSound 테스트만 존재
```

**변경 후:**
```javascript
import { describe, it, expect, vi } from 'vitest'
import { playFlipperSound, playLifeDownSound, playGameOverSound, playBumperSound } from '../pinballSound'

// ... 기존 테스트 ...

describe('playGameOverSound', () => {
  it('게임오버가 되면 gameover 사운드의 play()가 호출된다', () => {
    const mockPlay = vi.fn().mockResolvedValue(undefined)
    const mockAudio = { play: mockPlay, currentTime: 0 }

    playGameOverSound(mockAudio)

    expect(mockPlay).toHaveBeenCalledTimes(1)
  })
})

describe('playBumperSound', () => {
  it('공이 bumper에 맞으면 bumper 사운드의 play()가 호출된다', () => {
    const mockPlay = vi.fn().mockResolvedValue(undefined)
    const mockAudio = { play: mockPlay, currentTime: 0 }

    playBumperSound(mockAudio)

    expect(mockPlay).toHaveBeenCalledTimes(1)
  })
})
```

**특징:**
- TDD RED 단계: 함수가 없는 상태에서 먼저 작성하여 `is not a function` 오류로 실패 확인
- 기존 테스트 패턴(mock Audio 객체)과 동일한 방식 유지

---

### 2. `frontend/src/pinballSound.js` 수정

**변경 전:**
```javascript
export function playFlipperSound(audio) { ... }
export function playLifeDownSound(audio) { ... }
```

**변경 후:**
```javascript
export function playFlipperSound(audio) { ... }
export function playLifeDownSound(audio) { ... }

export function playGameOverSound(audio) {
  if (audio) {
    audio.currentTime = 0;
    audio.play();
  }
}

export function playBumperSound(audio) {
  if (audio) {
    audio.currentTime = 0;
    audio.play();
  }
}
```

**특징:**
- 기존 함수와 동일한 패턴으로 구현 (GREEN 단계: 최소한의 코드)
- `currentTime = 0` 으로 재생 위치 초기화 후 play() 호출

---

### 3. `frontend/src/Pinball.jsx` 수정

**변경 내용 1 — import 추가:**
```javascript
// 변경 전
import { playFlipperSound, playLifeDownSound } from './pinballSound';

// 변경 후
import { playFlipperSound, playLifeDownSound, playGameOverSound, playBumperSound } from './pinballSound';
```

**변경 내용 2 — ref 및 Audio 로드 추가:**
```javascript
// ref 추가
const gameoverSoundRef = useRef(null);
const bumperSoundRef = useRef(null);

// useEffect 내 Audio 로드
const gameoverSound = new Audio('/audio/gameover.mp3');
gameoverSound.volume = 0.7;
gameoverSoundRef.current = gameoverSound;

const bumperSound = new Audio('/audio/bumper.mp3');
bumperSound.volume = 0.7;
bumperSoundRef.current = bumperSound;
```

**변경 내용 3 — 사운드 호출:**
```javascript
// bumper 충돌 시
if ((bodyA.label === 'bumper' && bodyB === ball) || ...) {
  console.log('Bumper hit!');
  playBumperSound(bumperSoundRef.current);  // 추가
  ...
}

// 게임오버 시
World.remove(engine.world, ball);
console.log('Game Over!');
playGameOverSound(gameoverSoundRef.current);  // 추가
setOverlayState('gameOver');
```

**변경 내용 4 — cleanup 추가:**
```javascript
if (gameoverSoundRef.current) {
  gameoverSoundRef.current.pause();
  gameoverSoundRef.current.currentTime = 0;
}
if (bumperSoundRef.current) {
  bumperSoundRef.current.pause();
  bumperSoundRef.current.currentTime = 0;
}
```

**특징:**
- 기존 사운드(BGM, hitSound, flipperSound, lifeDownSound)와 동일한 패턴 적용
- 컴포넌트 언마운트 시 사운드 정리로 메모리 누수 방지

---

### 4. TDD 스킬 명령어 수정

**변경 전:**
```bash
cd frontend && npx vitest run src/test/[파일명].test.jsx
```

**변경 후:**
```bash
source ~/.nvm/nvm.sh && cd frontend && npx vitest run src/test/[파일명].test.jsx
```

**특징:**
- 이 프로젝트는 nvm으로 Node.js를 관리하므로 `source ~/.nvm/nvm.sh` 선행 필요
- SKILL.md와 references/frontend-test-env.md 두 파일 모두 수정
- 전체 테스트, Watch 모드 명령어도 동일하게 수정

## 결과
- 상태: 완료

## 배운 내용


## 다음 작업


---

# 업무일지

## 기본 정보
- 날짜: 2026-02-10 (화)
- 작성자: hexsera

## 진행 목표
1. 핀볼 게임오버 후 "다시 시작" 버튼 클릭 시 게임을 처음부터 재시작하는 기능 구현 (TDD)

---

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| RED: getRestartState 테스트 작성 | `frontend/src/test/pinball-restart.test.jsx` | 신규 생성, 4개 테스트 실패 확인 |
| GREEN: pinballRestart.js 생성 | `frontend/src/pinballRestart.js` | getRestartState 구현, 4개 테스트 통과 |
| REFACTOR: Pinball.jsx에 handleRestart 연결 | `frontend/src/Pinball.jsx` | ref 추가, 핸들러 구현, 버튼 onClick 연결 |

---

## 주요 변경 사항

### 1. `frontend/src/test/pinball-restart.test.jsx` 생성

**추가:**
```javascript
import { describe, it, expect } from 'vitest'
import { getRestartState } from '../pinballRestart'

describe('getRestartState', () => {
  it('재시작 시 overlayState가 null이 된다', () => {
    const result = getRestartState()
    expect(result.overlayState).toBe(null)
  })

  it('재시작 시 score가 0으로 초기화된다', () => {
    const result = getRestartState()
    expect(result.score).toBe(0)
  })

  it('재시작 시 lives가 3으로 초기화된다', () => {
    const result = getRestartState()
    expect(result.lives).toBe(3)
  })

  it('재시작 시 stage가 1로 초기화된다', () => {
    const result = getRestartState()
    expect(result.stage).toBe(1)
  })
})
```

**특징:**
- Matter.js 의존성 없이 재시작 초기 상태 값만 순수하게 검증
- RED 단계: `pinballRestart` 모듈 미존재로 `Failed to resolve import` 오류 발생 확인

---

### 2. `frontend/src/pinballRestart.js` 생성

**추가:**
```javascript
export function getRestartState() {
  return {
    overlayState: null,
    score: 0,
    lives: 3,
    stage: 1,
  };
}
```

**특징:**
- 재시작 시 필요한 초기 상태 값을 객체로 반환하는 순수 함수
- Matter.js, React 의존성 없이 독립적으로 테스트 가능

---

### 3. `frontend/src/Pinball.jsx` 수정

**변경 내용 1 — import 및 ref 추가:**
```javascript
// import 추가
import { getRestartState } from './pinballRestart';

// ref 추가 (Matter.js 객체 외부 접근용)
const engineRef = useRef(null);
const loadStageMapRef = useRef(null);
const plungerRef = useRef(null);
```

**변경 내용 2 — useEffect 내 ref 저장:**
```javascript
// 엔진 생성 후
engineRef.current = engine;

// plunger 생성 후
plungerRef.current = plunger;

// loadStageMap 정의 후
loadStageMapRef.current = loadStageMap;
```

**변경 내용 3 — handleRestart 함수 추가:**
```javascript
const handleRestart = () => {
  const { overlayState, score, lives, stage } = getRestartState();

  // React 상태 초기화
  setOverlayState(overlayState);
  setScore(score);
  setLives(lives);
  setStage(stage);

  // ref 초기화
  scoreRef.current = score;
  livesRef.current = lives;
  stageRef.current = stage;

  // Matter.js 물리 상태 초기화
  const ball = ballRef.current;
  const engine = engineRef.current;
  if (ball && engine) {
    // 게임오버 시 World에서 제거된 공을 다시 추가
    Matter.World.add(engine.world, ball);
    Matter.Body.setPosition(ball, { x: 662, y: 1020 });
    Matter.Body.setVelocity(ball, { x: 0, y: 0 });
    Matter.Body.setAngularVelocity(ball, 0);
  }

  // plunger 원래 위치로 복귀
  if (plungerRef.current) {
    Matter.Body.setPosition(plungerRef.current, { x: 662, y: 1050 });
  }

  // 스테이지 1 맵 다시 로딩
  if (loadStageMapRef.current) {
    loadStageMapRef.current(1);
  }
};
```

**변경 내용 4 — '다시 시작' 버튼 onClick 연결:**
```javascript
// 변경 전
<Button variant="contained" sx={{ ... }}>
  다시 시작
</Button>

// 변경 후
<Button variant="contained" onClick={handleRestart} sx={{ ... }}>
  다시 시작
</Button>
```

**재시작 시 초기화되는 항목:**
```
React 상태: overlayState(null), score(0), lives(3), stage(1)
Ref 값:     scoreRef(0), livesRef(3), stageRef(1)
Matter.js:  ball World 재추가, ball 위치(662, 1020), ball 속도(0,0)
            plunger 위치(662, 1050), 스테이지 1 맵 재로딩
```

---

## 아키텍처

### 재시작 로직 분리 구조

```
Pinball.jsx
  - handleRestart() 호출
      ↓ import
  pinballRestart.js
  - getRestartState() → { overlayState, score, lives, stage }
      ↓ mock 없이 테스트
  pinball-restart.test.jsx
  - expect(result.score).toBe(0) 등 순수 값 검증
```

### ref를 통한 Matter.js 접근 구조

```
useEffect 내부 (Matter.js 생성)
  engine → engineRef.current
  plunger → plungerRef.current
  loadStageMap → loadStageMapRef.current
        ↓
handleRestart (useEffect 외부)
  engineRef.current로 World 접근
  plungerRef.current로 위치 초기화
  loadStageMapRef.current(1)로 맵 재로딩
```

---

## 결과
- 상태: 완료
- 테스트: 4/4 통과

## 배운 내용
- Matter.js처럼 테스트하기 어려운 의존성이 있는 컴포넌트는 순수 로직을 별도 파일로 분리하면 TDD 적용 가능
- useEffect 내부에서 생성한 Matter.js 객체는 useRef를 통해 외부 함수(handleRestart)에서 접근 가능
- `loadStageMapRef.current = loadStageMap` 패턴으로 클로저 함수도 외부에서 호출 가능

## 다음 작업
- 재시작 시 BGM 처음부터 재생 여부 결정
