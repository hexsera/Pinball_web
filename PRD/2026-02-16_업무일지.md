# 업무일지

## 기본 정보
- 날짜: 2026-02-16 (월) 15:30~16:00
- 작성자: hexsera

## 진행 목표
`POST /api/v1/game_visits` 및 `PUT /api/v1/game_visits` 요청 시 `user_id`가 `users` 테이블에 존재하는지 사전 검증하여 DB FK 오류(IntegrityError) 방지

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| PRD 작성 | `PRD/game_visits fk검사prd.md` | 요구사항 정의 |
| 실행계획 작성 | `PRD/game_visits_fk검사-실행계획.md` | 코드베이스 분석 후 구현 계획 수립 |
| User 모델 import 추가 | `backend/app/api/v1/game_visits.py` | User 존재 여부 조회 위해 추가 |
| POST 엔드포인트 검증 로직 추가 | `backend/app/api/v1/game_visits.py` | user_id → users 테이블 조회 후 없으면 404 반환 |
| PUT 엔드포인트 검증 로직 추가 | `backend/app/api/v1/game_visits.py` | 동일 패턴 적용 |
| 테스트 (5 케이스) | - | curl로 POST/PUT 각 케이스 검증 |

**총 1시간**

## 주요 변경 사항

### 1. `backend/app/api/v1/game_visits.py` 수정

**변경 전:**
```python
from models import GameVisit
```

**변경 후:**
```python
from models import GameVisit, User
```

**특징:**
- User 모델을 import하여 user_id 존재 여부 조회에 사용

---

**변경 전 (POST 엔드포인트):**
```python
def create_game_visit(...):
    """게임 접속 기록 생성 (오늘 날짜 + IP 기준 중복 방지)"""
    # 클라이언트 IP 추출
    client_ip = get_client_ip(request)
    ...
```

**변경 후 (POST 엔드포인트):**
```python
def create_game_visit(...):
    """게임 접속 기록 생성 (오늘 날짜 + IP 기준 중복 방지)"""
    # user_id가 전달된 경우 users 테이블에서 존재 여부 확인
    if visit_data.user_id is not None:
        user = db.query(User).filter(User.id == visit_data.user_id).first()
        if user is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"User with id {visit_data.user_id} not found"
            )

    # 클라이언트 IP 추출
    client_ip = get_client_ip(request)
    ...
```

**특징:**
- `user_id`가 `None`이면 검증 건너뜀 (비로그인 사용자 허용)
- `user_id`가 있을 때만 DB 조회 → 없으면 HTTP 404 반환 후 INSERT 차단

---

**변경 전 (PUT 엔드포인트):**
```python
def update_game_visit(...):
    """IP 주소 기반 게임 접속 기록 업데이트 (is_visits = True)"""
    # IP 주소로 레코드 조회
    game_visit = db.query(GameVisit).filter(...)
    ...
```

**변경 후 (PUT 엔드포인트):**
```python
def update_game_visit(...):
    """IP 주소 기반 게임 접속 기록 업데이트 (is_visits = True)"""
    # user_id가 전달된 경우 users 테이블에서 존재 여부 확인
    if visit_data.user_id is not None:
        user = db.query(User).filter(User.id == visit_data.user_id).first()
        if user is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"User with id {visit_data.user_id} not found"
            )

    # IP 주소로 레코드 조회
    game_visit = db.query(GameVisit).filter(...)
    ...
```

**특징:**
- POST와 동일한 패턴으로 검증 로직 추가

## 테스트 결과

| # | 케이스 | 기대 결과 | 실제 결과 |
|---|--------|-----------|-----------|
| 1 | POST — 존재하지 않는 `user_id=99999` | 404 | ✅ 404 |
| 2 | POST — `user_id=null` (비로그인) | 201 | ✅ 201 |
| 3 | POST — 유효한 `user_id=1` | 201 | ✅ 201 |
| 4 | PUT — 존재하지 않는 `user_id=99999` | 404 | ✅ 404 |
| 5 | PUT — 유효한 `user_id=2` | 200 | ✅ 200 |

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
- 없음

---

## 기본 정보 (2차 작업)
- 날짜: 2026-02-16 (월) 16:00~16:30
- 작성자: hexsera

## 진행 목표
`monthly_scores` API에서 이번 달(1일~말일) 범위의 레코드만 대상으로 조회·등록되도록 제한하여, 월이 바뀌었을 때 이전 달 점수가 이번 달 점수로 오인되는 문제 방지

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 실행계획 확인 | `PRD/monthly_scores_이번달범위제한-실행계획.md` | 요구사항 및 구현 방법 검토 |
| 헬퍼 함수 `get_current_month_range()` 추가 | `backend/app/api/v1/monthly_scores.py` | POST/GET 공통 사용, 중복 제거 |
| POST 기존 점수 조회에 이번 달 범위 필터 추가 | `backend/app/api/v1/monthly_scores.py` | 이전 달 레코드를 별개 레코드로 취급 |
| GET `/` 전체 조회 `date` → `datetime` 타입 교체 | `backend/app/api/v1/monthly_scores.py` | 말일 00:00:00 이후 데이터 누락 버그 수정 |
| GET `/{user_id}` 단일 조회에 이번 달 범위 필터 추가 | `backend/app/api/v1/monthly_scores.py` | 이전 달 레코드만 있으면 404 반환 |
| 미사용 `date` import 제거 | `backend/app/api/v1/monthly_scores.py` | 코드 정리 |

## 주요 변경 사항

### `backend/app/api/v1/monthly_scores.py`

**헬퍼 함수 추가:**
```python
def get_current_month_range():
    """이번 달 시작(1일 00:00:00)과 끝(말일 23:59:59)을 반환"""
    now = datetime.now()
    year, month = now.year, now.month
    _, last_day = monthrange(year, month)
    start = datetime(year, month, 1, 0, 0, 0)
    end = datetime(year, month, last_day, 23, 59, 59)
    return start, end
```

**POST — 이번 달 범위 필터 적용:**
```python
# 변경 전
existing_score = db.query(MonthlyScore).filter(
    MonthlyScore.user_id == score_data.user_id
).first()

# 변경 후
start, end = get_current_month_range()
existing_score = db.query(MonthlyScore).filter(
    MonthlyScore.user_id == score_data.user_id,
    MonthlyScore.created_at >= start,
    MonthlyScore.created_at <= end
).first()
```

**GET `/` — `date` → `datetime` 타입 교체:**
```python
# 변경 전: date 타입 비교 → 말일 00:00:00 이후 데이터 누락
start_date = date(year, month, 1)
end_date = date(year, month, last_day)

# 변경 후: datetime 타입으로 말일 23:59:59까지 포함
start, end = get_current_month_range()
```

**GET `/{user_id}` — 이번 달 범위 필터 추가:**
```python
# 변경 전: 날짜 필터 없음
score = db.query(MonthlyScore).filter(
    MonthlyScore.user_id == user_id
).first()

# 변경 후
start, end = get_current_month_range()
score = db.query(MonthlyScore).filter(
    MonthlyScore.user_id == user_id,
    MonthlyScore.created_at >= start,
    MonthlyScore.created_at <= end
).first()
```

## 결과
- 상태: 완료

---

## 기본 정보 (3차 작업)
- 날짜: 2026-02-16 (월) 17:00~17:50
- 작성자: hexsera

## 진행 목표
핀볼 게임의 소리 아이콘 on/off 시 BGM뿐 아니라 모든 효과음까지 일괄 음소거되도록 마스터 볼륨 제어 기능 구현

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 상태 변수 교체 | `frontend/src/pages/Pinball/Pinball.jsx` | `isPlaying` → `isMuted` |
| `handleToggleMusic` 수정 | `frontend/src/pages/Pinball/Pinball.jsx` | BGM만 pause/play → 전체 Audio muted 일괄 제어 |
| `startGame` 정리 | `frontend/src/pages/Pinball/Pinball.jsx` | 미사용 `setIsPlaying(true)` 제거 |
| 아이콘 조건 변경 | `frontend/src/pages/Pinball/Pinball.jsx` | `isPlaying` → `!isMuted` 기반 렌더링 |

## 주요 변경 사항

### 1. `frontend/src/pages/Pinball/Pinball.jsx` 수정

**변경 전 (상태 변수):**
```javascript
const [isPlaying, setIsPlaying] = useState(false);
```

**변경 후 (상태 변수):**
```javascript
const [isMuted, setIsMuted] = useState(false);
```

**특징:**
- BGM 재생 여부 추적 변수에서 전체 음소거 여부 추적 변수로 의미 변경
- `false` = 소리 켜짐, `true` = 전체 음소거

---

**변경 전 (`handleToggleMusic`):**
```javascript
// 음악 재생/정지 토글 핸들러
const handleToggleMusic = () => {
  if (bgmRef.current) {
    if (isPlaying) {
      bgmRef.current.pause();
      setIsPlaying(false);
    } else {
      bgmRef.current.play();
      setIsPlaying(true);
    }
  }
};
```

**변경 후 (`handleToggleMusic`):**
```javascript
// 마스터 볼륨 음소거 토글 핸들러
const handleToggleMusic = () => {
  const allRefs = [bgmRef, hitSoundRef, fliperSoundRef, lifeDownSoundRef, gameoverSoundRef, bumperSoundRef];
  const nextMuted = !isMuted;
  allRefs.forEach(ref => {
    if (ref.current) ref.current.muted = nextMuted;
  });
  setIsMuted(nextMuted);
};
```

**특징:**
- BGM만 제어하던 방식에서 6개 Audio 객체 전체를 일괄 제어하는 방식으로 변경
- `Audio.muted` 프로퍼티 사용 — 볼륨 값을 유지한 채 출력만 차단하므로 on 복귀 시 원래 볼륨 즉시 복원
- BGM을 `pause/play` 하지 않으므로 off → on 시 꺼진 지점부터 이어서 재생

---

**변경 전 (`startGame`):**
```javascript
bgmRef.current?.play().catch(() => {});
setIsPlaying(true);
```

**변경 후 (`startGame`):**
```javascript
bgmRef.current?.play().catch(() => {});
```

**특징:**
- 더 이상 사용하지 않는 `setIsPlaying(true)` 제거
- `bgmRef.current?.play()` 는 그대로 유지 — 크롬 자동재생 차단 정책은 사용자 인터랙션(클릭/키) 이후 호출이므로 영향 없음

---

**변경 전 (아이콘 렌더링):**
```javascript
{isPlaying ? (
  <VolumeUpIcon sx={{ fontSize: '36px' }} />
) : (
  <VolumeOffIcon sx={{ fontSize: '36px' }} />
)}
```

**변경 후 (아이콘 렌더링):**
```javascript
{!isMuted ? (
  <VolumeUpIcon sx={{ fontSize: '36px' }} />
) : (
  <VolumeOffIcon sx={{ fontSize: '36px' }} />
)}
```

**특징:**
- 아이콘 표시 기준을 BGM 재생 여부(`isPlaying`)에서 전체 음소거 여부(`isMuted`)로 변경
- `isMuted: false` → VolumeUpIcon, `isMuted: true` → VolumeOffIcon

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
- 없음

# 업무일지

## 기본 정보
- 날짜: 2026-02-16 (월) 18:00~18:30, 19:00~19:30
- 작성자: hexsera

## 진행 목표

pytest TDD 환경에서 testDB(`hexdb_test`)가 프로덕션 DB 환경과 동일하게 동작하도록 `conftest.py`와 `session.py`를 수정하고, `/api/debug/db-info` 엔드포인트의 `AttributeError` 를 해결한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| testDB 세션 실행계획 작성 | `PRD/testDB-세션일치-실행계획.md` 생성 | SAVEPOINT 패턴 적용 계획 |
| SQLAlchemy 2.0 방식으로 Base 변경 | `backend/app/db/session.py` 수정 | `declarative_base()` → `DeclarativeBase` 클래스 상속 |
| conftest.py db_session fixture 수정 | `backend/tests/conftest.py` 수정 | SAVEPOINT 패턴 + Engine bind 방식 적용 |
| AttributeError 실행계획 작성 | `PRD/debug-db-info-AttributeError-실행계획.md` 생성 | `db.get_bind()`가 `Engine` 반환하도록 수정 계획 |
| conftest.py db_session fixture 재수정 | `backend/tests/conftest.py` 수정 | `TestSessionLocal()` — `bind=connection` 제거, `session.connection()` join 방식으로 변경 |

## 주요 변경 사항

### 1. `backend/app/db/session.py` 수정

**변경 전:**
```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()
```

**변경 후:**
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import DeclarativeBase, sessionmaker

class Base(DeclarativeBase):
    pass
```

**특징:**
- SQLAlchemy 1.x 레거시 방식인 `declarative_base()` 함수 호출을 SQLAlchemy 2.0 표준인 `DeclarativeBase` 클래스 상속으로 변경
- 기존 모든 모델은 `Base`를 상속하므로 모델 코드 변경 불필요

---

### 2. `backend/tests/conftest.py` 수정 (1차 — SAVEPOINT 패턴 적용)

**변경 전:**
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

def db_session():
    connection = test_engine.connect()
    transaction = connection.begin()
    session = TestSessionLocal(bind=connection)  # Connection에 bind

    yield session

    session.close()
    transaction.rollback()
    connection.close()
```

**변경 후 (1차):**
```python
from sqlalchemy import create_engine, event
from sqlalchemy.orm import sessionmaker

def db_session():
    connection = test_engine.connect()
    transaction = connection.begin()
    session = TestSessionLocal(bind=connection)  # 아직 Connection bind 유지

    @event.listens_for(session, "after_transaction_end")
    def restart_savepoint(session, trans):
        if trans.nested and not trans._parent.nested:
            session.begin_nested()

    session.begin_nested()  # SAVEPOINT 생성
    yield session

    session.close()
    transaction.rollback()
    connection.close()
```

**특징:**
- `event.listens_for`로 `after_transaction_end` 이벤트를 구독하여 SAVEPOINT가 끝나면 자동으로 새 SAVEPOINT 시작
- `session.begin_nested()`로 테스트 내 `commit()`이 실제 DB에 반영되지 않도록 처리

---

### 3. `backend/tests/conftest.py` 수정 (2차 — Engine bind 방식으로 변경)

**문제 발견:**
- 1차 수정 후에도 `TestSessionLocal(bind=connection)`으로 세션 생성 시 `db.get_bind()`가 `Connection`을 반환
- `/api/debug/db-info`에서 `db.get_bind().url` 호출 시 `AttributeError: 'Connection' object has no attribute 'url'` 발생
- 원인: 프로덕션 `get_db()`는 `SessionLocal()`로 생성하여 `db.get_bind()`가 `Engine` 반환, 테스트는 `Connection` 반환으로 불일치

**변경 후 (2차 최종):**
```python
def db_session():
    connection = test_engine.connect()
    transaction = connection.begin()

    # Engine에 bind된 세션 생성 (프로덕션과 동일하게 db.get_bind()가 Engine을 반환)
    session = TestSessionLocal()  # bind=connection 제거

    @event.listens_for(session, "after_transaction_end")
    def restart_savepoint(session, trans):
        if trans.nested and not trans._parent.nested:
            session.begin_nested()

    # 세션의 실제 쿼리 실행을 외부 connection으로 연결
    session.connection(bind_arguments={"bind": connection})
    session.begin_nested()

    yield session

    session.close()
    transaction.rollback()
    connection.close()
```

**특징:**
- `TestSessionLocal()` — `bind=connection` 인자 없이 생성하므로 `db.get_bind()`가 `Engine` 반환 (프로덕션과 동일)
- `session.connection(bind_arguments={"bind": connection})` — 실제 쿼리 실행은 외부 `connection`을 통해 수행하여 트랜잭션 격리 유지
- `/api/debug/db-info` 엔드포인트에서 `db.get_bind().url` 정상 동작 확인

## 결과

- 상태: 완료

## 배운 내용

## 다음 작업

---

# 업무일지

## 기본 정보
- 날짜: 2026-02-16 (월) 19:30~20:10
- 작성자: hexsera

## 진행 목표

1. HighScore 기능(API, 모델, 테스트) 완전 삭제
2. 테스트 환경을 프로덕션과 동일한 세션 구조로 근본적 개선 (conftest.py 재작성)

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| HighScore 삭제 실행계획 작성 | `PRD/pytest-tdd-테스트수정-실행계획.md` | 삭제 대상 파일/코드 목록 작성 |
| HighScore 모델 삭제 | `backend/models.py` | `HighScore` 클래스 블록 제거 |
| HighScore 라우터 등록 제거 | `backend/main.py` | import 및 `include_router` 제거 |
| HighScore 파일 3개 삭제 | `high_scores.py`, `high_score.py`, `test_high_scores.py` | 파일시스템에서 완전 삭제 |
| 관련 참조 제거 | `base.py`, `schemas/__init__.py`, `api/v1/__init__.py`, `users.py` | import/export/쿼리 전체 정리 |
| Alembic 마이그레이션 생성 및 적용 | `e529d64d1a07_drop_high_scores_table.py` 생성 | `high_scores` 테이블 DB에서 drop |
| TRUNCATE 기반 conftest 실행계획 작성 | `PRD/테스트DB구조-개선-실행계획.md` | SAVEPOINT 방식 한계 분석 및 대안 설계 |
| conftest.py 전면 재작성 | `backend/tests/conftest.py` | SAVEPOINT → TRUNCATE 방식으로 교체 |
| test_friend_requests.py flush → commit 복원 | `backend/tests/test_friend_requests.py` | 프로덕션 패턴과 동일하게 복원 |

## 주요 변경 사항

### 1. HighScore 관련 파일 및 코드 삭제

**삭제된 파일:**
- `backend/app/api/v1/high_scores.py`
- `backend/app/schemas/high_score.py`
- `backend/tests/test_high_scores.py`

**수정된 파일 요약:**

| 파일 | 변경 내용 |
|------|-----------|
| `backend/models.py` | `HighScore` 클래스 블록 전체 제거 |
| `backend/main.py` | `high_scores` import 및 `include_router` 제거 |
| `backend/app/db/base.py` | `HighScore` import/export 제거 |
| `backend/app/schemas/__init__.py` | `HighScoreCreate`, `HighScoreResponse` import/export 제거 |
| `backend/app/api/v1/__init__.py` | `high_scores` 모듈 import/export 제거 |
| `backend/app/api/v1/users.py` | `HighScore` import 및 유저 삭제 시 HighScore 연쇄 삭제 쿼리 제거 |

**Alembic 마이그레이션 (autogenerate로 자동 생성):**
```python
def upgrade() -> None:
    op.drop_index('ix_high_scores_created_at', table_name='high_scores')
    op.drop_index('ix_high_scores_id', table_name='high_scores')
    op.drop_index('ix_high_scores_score', table_name='high_scores')
    op.drop_index('ix_high_scores_user_id', table_name='high_scores')
    op.drop_table('high_scores')
```

---

### 2. conftest.py 전면 재작성 (SAVEPOINT → TRUNCATE)

**실패 원인 (SAVEPOINT 방식의 구조적 한계):**

SAVEPOINT 방식은 `commit()`이 실제로 DB에 반영되지 않도록 막는다. 프로덕션 API 코드(`friends.py`, `users.py`, `scores.py`, `monthly_scores.py`) 전체가 `db.commit()` 직후 즉시 `db.refresh()`를 호출한다. `after_transaction_end` 이벤트로 새 SAVEPOINT를 재시작해도, `refresh()`는 이벤트 발생 전에 실행되어 인스턴스가 expired 상태가 되고 `sqlalchemy.exc.InvalidRequestError`가 발생한다. 프로덕션 코드 패턴(`commit → refresh`)이 SAVEPOINT 구조와 근본적으로 양립 불가능하다.

**변경 전 (SAVEPOINT 방식):**
```python
@pytest.fixture(scope="function")
def db_session():
    connection = test_engine.connect()
    transaction = connection.begin()
    session = TestSessionLocal()

    @event.listens_for(session, "after_transaction_end")
    def restart_savepoint(session, trans):
        if trans.nested and not trans._parent.nested:
            session.begin_nested()

    session.connection(bind_arguments={"bind": connection})
    session.begin_nested()
    yield session
    session.close()
    transaction.rollback()
    connection.close()
```

**변경 후 (TRUNCATE 방식):**
```python
TABLES_TO_TRUNCATE = [
    "friendships", "monthly_scores", "game_visits", "scores", "users",
]

@pytest.fixture(scope="function", autouse=True)
def truncate_tables():
    yield
    with test_engine.connect() as conn:
        for table in TABLES_TO_TRUNCATE:
            conn.execute(text(f"TRUNCATE TABLE {table} RESTART IDENTITY CASCADE"))
        conn.commit()

@pytest.fixture(scope="function")
def db_session():
    session = TestSessionLocal()
    try:
        yield session
    finally:
        session.close()
```

**특징:**
- `db_session`이 프로덕션 `get_db()`와 완전히 동일한 구조 — `commit()`이 실제 DB에 반영됨
- `truncate_tables` fixture가 `autouse=True`로 모든 테스트 함수 종료 후 자동 실행
- `RESTART IDENTITY`: auto-increment 시퀀스 초기화로 테스트 간 ID 값 일관성 보장
- `CASCADE`: FK 제약조건 있는 자식 테이블도 연쇄 삭제

---

### 3. test_friend_requests.py commit() 복원

**변경 전 (SAVEPOINT 구조 임시 우회):**
```python
db_session.add(friendship)
db_session.flush()
```

**변경 후 (프로덕션 패턴과 동일):**
```python
db_session.add(friendship)
db_session.commit()
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
- 없음
