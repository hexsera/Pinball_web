# 업무일지

## 기본 정보
- 날짜: 2026-02-20 (금)
- 작성자: hexsera

## 진행 목표

Gemini API를 사용하는 채팅 테스트 엔드포인트를 백엔드에 추가한다. 사용자가 텍스트를 입력하면 Gemini 모델의 응답을 반환하는 `POST /api/v1/chat` 엔드포인트를 구현한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 실행계획 작성 | `PRD/gemini-api-chat-실행계획.md` | 신규 생성 |
| Gemini 모델 변경 | `PRD/gemini-api-chat-실행계획.md` | `gemini-pro` → `gemini-2.0-flash` (무료 티어) |
| GEMINI_API_KEY 환경변수 추가 | `backend/.env` | API Key 등록 |
| GEMINI_API_KEY 템플릿 추가 | `backend/.env.example` | 빈 값으로 문서화 |
| GEMINI_API_KEY 설정 필드 추가 | `backend/app/core/config.py` | Settings 클래스 확장 |
| ChatRequest/ChatResponse 스키마 생성 | `backend/app/schemas/chat.py` | 신규 생성 |
| 채팅 라우터 생성 | `backend/app/api/v1/chat.py` | 신규 생성, Gemini REST API 호출 |
| 라우터 등록 | `backend/main.py` | `/api/v1/chat` 경로로 연결 |
| Docker 컨테이너 재빌드 | — | `docker compose up -d --build fastapi` |
| 동작 테스트 및 오류 원인 분석 | — | API Key 할당량 문제 확인 |

**총 1시간**

## 주요 변경 사항

### 1. backend/.env 수정

**변경 전:**
```bash
ADMIN_BIRTH_DATE=2000-01-01
```

**변경 후:**
```bash
ADMIN_BIRTH_DATE=2000-01-01

# Gemini API
GEMINI_API_KEY=AIzaSyBxYvwQC20gr4wT2Q0BQAaSVUk_-Ezm5us
```

**특징:**
- API Key를 코드에 하드코딩하지 않고 환경변수로 관리

---

### 2. backend/app/core/config.py 수정

**변경 전:**
```python
    ADMIN_BIRTH_DATE: str = os.getenv("ADMIN_BIRTH_DATE")

settings = Settings()
```

**변경 후:**
```python
    ADMIN_BIRTH_DATE: str = os.getenv("ADMIN_BIRTH_DATE")

    # Gemini API
    GEMINI_API_KEY: str = os.getenv("GEMINI_API_KEY")

settings = Settings()
```

**특징:**
- 앱 전체에서 `settings.GEMINI_API_KEY`로 접근 가능

---

### 3. backend/app/schemas/chat.py 생성

**추가:**
```python
from pydantic import BaseModel

class ChatRequest(BaseModel):
    message: str

class ChatResponse(BaseModel):
    reply: str
```

**특징:**
- `message`: 사용자 입력 텍스트
- `reply`: Gemini 응답 텍스트
- Pydantic 스키마로 자동 유효성 검증 및 `/docs` 자동 문서화

---

### 4. backend/app/api/v1/chat.py 생성

**추가:**
```python
import httpx
from fastapi import APIRouter, HTTPException
from app.core.config import settings
from app.schemas.chat import ChatRequest, ChatResponse

router = APIRouter()

GEMINI_URL = (
    "https://generativelanguage.googleapis.com/v1beta/models/"
    "gemini-2.0-flash:generateContent"
)

@router.post("/chat", response_model=ChatResponse)
def chat(request: ChatRequest):
    payload = {
        "contents": [{"parts": [{"text": request.message}]}]
    }
    params = {"key": settings.GEMINI_API_KEY}
    with httpx.Client(timeout=30) as client:
        res = client.post(GEMINI_URL, json=payload, params=params)
    if res.status_code != 200:
        raise HTTPException(status_code=502, detail="Gemini API 호출 실패")
    data = res.json()
    reply = data["candidates"][0]["content"]["parts"][0]["text"]
    return ChatResponse(reply=reply)
```

**특징:**
- 추가 패키지 설치 없이 기존 `httpx`로 Gemini REST API 직접 호출
- 무료 모델 `gemini-2.0-flash` 사용
- Gemini 오류 시 HTTP 502 반환

---

### 5. backend/main.py 수정

**변경 전:**
```python
from app.api.v1 import users, auth, monthly_scores, game_visits, friends
...
app.include_router(friends.router, prefix="/api/friend-requests", tags=["Friends"])
```

**변경 후:**
```python
from app.api.v1 import users, auth, monthly_scores, game_visits, friends, chat
...
app.include_router(friends.router, prefix="/api/friend-requests", tags=["Friends"])
app.include_router(chat.router, prefix="/api/v1", tags=["Chat"])
```

**특징:**
- `POST /api/v1/chat` 경로로 채팅 엔드포인트 노출

---

### 요청 흐름

```
클라이언트 POST /api/v1/chat
        {"message": "안녕"}
             │
             ▼
      FastAPI (chat.py)
             │
             ▼ HTTP POST (httpx)
  Gemini REST API (gemini-2.0-flash)
             │
             ▼
      FastAPI 응답 반환
        {"reply": "..."}
```

## 결과
- 상태: 보류

코드 구현 및 Docker 배포는 완료되었으나, PRD에 명시된 API Key(`AIzaSyB...`)의 Google Cloud 프로젝트에서 **무료 티어 할당량이 0**으로 설정되어 있어 실제 호출이 불가능한 상태.
(`limit: 0` — 프로젝트에 Gemini API가 활성화되지 않은 것으로 판단)

## 배운내용


## 다음 작업
- [Google AI Studio](https://aistudio.google.com/apikey)에서 새 API Key 발급
- `backend/.env`의 `GEMINI_API_KEY` 값 교체 후 `docker compose restart fastapi`로 재시작
- `POST /api/v1/chat` 실제 응답 확인 및 체크리스트 완료 처리

---

# 업무일지 (2차)

## 기본 정보
- 날짜: 2026-02-20 (금)
- 작성자: hexsera

## 진행 목표

1차 작업에서 httpx REST API 직접 호출로 구현된 chat.py를 **google-genai 공식 SDK** 방식으로 전환한다.
추가로 현재 API 키로 사용 가능한 Gemini 모델 목록을 반환하는 엔드포인트를 구현한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 실행계획 SDK 방식으로 수정 | `PRD/Gemini-AI-핀볼대결-채팅-실행계획.md` | httpx → google-genai SDK |
| google-genai 패키지 추가 | `backend/requirements.txt` | Gemini 공식 Python SDK |
| chat.py SDK 방식으로 전면 교체 | `backend/app/api/v1/chat.py` | 시스템 프롬프트(역할 부여) 포함 |
| 모델 목록 API 추가 | `backend/app/api/v1/chat.py` | `GET /api/v1/chat/models` |
| Docker 컨테이너 재빌드 | — | `docker compose up -d --build fastapi` |
| 동작 테스트 | — | 모델 목록 API 정상 응답 확인 |

**총 30분**

## 주요 변경 사항

### 1. backend/requirements.txt 수정

**변경 전:**
```text
Faker==24.0.0
```

**변경 후:**
```text
Faker==24.0.0
google-genai
```

**특징:**
- `google-genai`는 Google에서 공식 배포하는 Gemini Python SDK 패키지
- Docker 이미지 빌드 시 자동 설치됨

---

### 2. backend/app/api/v1/chat.py 전면 교체

**변경 전 (httpx REST 방식):**
```python
import httpx
from fastapi import APIRouter, HTTPException
from app.core.config import settings
from app.schemas.chat import ChatRequest, ChatResponse

router = APIRouter()

GEMINI_URL = (
    "https://generativelanguage.googleapis.com/v1beta/models/"
    "gemini-2.0-flash:generateContent"
)

@router.post("/chat", response_model=ChatResponse)
def chat(request: ChatRequest):
    payload = {
        "contents": [{"parts": [{"text": request.message}]}]
    }
    params = {"key": settings.GEMINI_API_KEY}
    with httpx.Client(timeout=30) as client:
        res = client.post(GEMINI_URL, json=payload, params=params)
    if res.status_code != 200:
        raise HTTPException(status_code=502, detail="Gemini API 호출 실패")
    data = res.json()
    reply = data["candidates"][0]["content"]["parts"][0]["text"]
    return ChatResponse(reply=reply)
```

**변경 후 (google-genai SDK 방식):**
```python
from google import genai
from google.genai import types
from fastapi import APIRouter, HTTPException
from app.core.config import settings
from app.schemas.chat import ChatRequest, ChatResponse

router = APIRouter()

SYSTEM_PROMPT = (
    "너는 핀볼 게임에서 사용자와 대결 중인 AI 상대방이다. "
    "경쟁자 입장에서 짧고 도발적이거나 친근하게 대화한다. "
    "핀볼 점수, 게임 전략, 승부에 관한 이야기를 한다. "
    "한국어로 대화하며, 게임 외 주제는 핀볼 대결로 돌려서 답한다."
)

@router.get("/chat/models")
def list_models():
    client = genai.Client(api_key=settings.GEMINI_API_KEY)
    models = [m.name for m in client.models.list()]
    return {"models": models}

@router.post("/chat", response_model=ChatResponse)
def chat(request: ChatRequest):
    client = genai.Client(api_key=settings.GEMINI_API_KEY)
    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=request.message,
        config=types.GenerateContentConfig(
            system_instruction=SYSTEM_PROMPT,
        ),
    )
    return ChatResponse(reply=response.text)
```

**특징:**
- `genai.Client(api_key=...)` 로 SDK 클라이언트 생성 — URL, 헤더 등 저수준 처리를 SDK가 담당
- `types.GenerateContentConfig(system_instruction=...)` 으로 AI에게 "핀볼 대결 상대방" 역할 부여
- `GET /api/v1/chat/models` — API 키로 접근 가능한 전체 모델 목록 반환
- httpx, GEMINI_URL 등 REST 관련 코드 제거

---

### 요청 흐름 (변경 후)

```
클라이언트 POST /api/v1/chat
        {"message": "안녕"}
             │
             ▼
      FastAPI (chat.py)
      genai.Client 생성
             │
             ▼  SDK 내부 처리
      Gemini API (gemini-2.5-flash)
      system_instruction 적용
             │
             ▼
      FastAPI 응답 반환
        {"reply": "..."}
```

## 결과
- 상태: 부분 완료

`GET /api/v1/chat/models` 정상 동작 확인 (43개 모델 목록 반환).
`POST /api/v1/chat`은 API 키의 `gemini-2.5-flash` quota 문제로 미확인 상태.

## 배운내용


## 다음 작업
- API 키 quota 문제 해결 후 `POST /api/v1/chat` 실제 응답 확인
- 프론트엔드 채팅창에 `/api/v1/chat` 엔드포인트 연결

---

# 업무일지 (3차)

## 기본 정보
- 날짜: 2026-02-20 (금)
- 작성자: hexsera

## 진행 목표

채팅 API에 멀티턴 대화(이전 대화 내용 기억) 기능을 추가한다.
`client.chats.create()`로 세션을 생성하고, `chat_id`로 세션을 식별해 대화 히스토리를 유지한다.
디버그 목적으로 `response.model_dump()`로 Gemini 응답 전체를 반환하는 임시 엔드포인트도 추가한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 디버그용 response 전체 반환 | `backend/app/api/v1/chat.py` | `response_model` 제거, `model_dump()` 반환 |
| ChatRequest에 chat_id 추가 | `backend/app/schemas/chat.py` | Optional 필드 |
| ChatResponse에 chat_id 추가 | `backend/app/schemas/chat.py` | 세션 식별자 반환 |
| chats.create() 세션 방식으로 교체 | `backend/app/api/v1/chat.py` | 메모리 dict로 세션 관리 |
| 동작 테스트 | — | 2회 연속 호출로 이전 대화 기억 확인 |

**총 20분**

## 주요 변경 사항

### 1. backend/app/schemas/chat.py 수정

**변경 전:**
```python
class ChatRequest(BaseModel):
    message: str

class ChatResponse(BaseModel):
    reply: str
```

**변경 후:**
```python
class ChatRequest(BaseModel):
    chat_id: Optional[str] = None
    message: str

class ChatResponse(BaseModel):
    chat_id: str
    reply: str
```

**특징:**
- `chat_id`는 선택 필드 — 없으면 새 세션 생성, 있으면 기존 세션 재사용
- 응답에 `chat_id`를 포함해 클라이언트가 다음 요청에서 재사용할 수 있도록 함

---

### 2. backend/app/api/v1/chat.py 수정

**변경 전:**
```python
@router.post("/chat")
def chat(request: ChatRequest):
    client = _get_client()
    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=request.message,
        config=types.GenerateContentConfig(system_instruction=SYSTEM_PROMPT),
    )
    return response.model_dump()
```

**변경 후:**
```python
_sessions: dict = {}

@router.post("/chat", response_model=ChatResponse)
def chat(request: ChatRequest):
    client = _get_client()

    if request.chat_id and request.chat_id in _sessions:
        chat_session = _sessions[request.chat_id]
        chat_id = request.chat_id
    else:
        chat_session = client.chats.create(
            model="gemini-2.5-flash",
            config=types.GenerateContentConfig(system_instruction=SYSTEM_PROMPT),
        )
        chat_id = str(uuid.uuid4())
        _sessions[chat_id] = chat_session

    response = chat_session.send_message(request.message)
    return ChatResponse(chat_id=chat_id, reply=response.text)
```

**특징:**
- `_sessions` dict에 `chat_id → Chat 객체` 형태로 세션 보관
- `client.chats.create()`로 생성된 Chat 객체가 내부적으로 대화 히스토리를 관리
- `chat_session.send_message()`로 메시지를 보내면 이전 대화가 자동으로 context에 포함됨
- 세션은 서버 메모리에만 저장되므로 서버 재시작 시 초기화됨

---

### 세션 흐름

```
첫 번째 요청 {"message": "안녕"}
             │
             ▼
     chat_id 없음 → 새 세션 생성
     _sessions["uuid-1234"] = chat_session
             │
             ▼
     응답 {"chat_id": "uuid-1234", "reply": "..."}

두 번째 요청 {"chat_id": "uuid-1234", "message": "아까 내가 뭐라고 했지?"}
             │
             ▼
     chat_id 있음 → 기존 세션 재사용
     chat_session.send_message() → 히스토리 포함
             │
             ▼
     응답 {"chat_id": "uuid-1234", "reply": "안녕이라고 했지..."}
```

## 결과
- 상태: 완료

`chat_id` 없이 첫 요청 → 새 세션 생성 및 응답 확인.
동일 `chat_id`로 두 번째 요청 시 이전 대화 내용을 정확히 기억하는 것 확인.

## 배운내용


## 다음 작업
- 서버 재시작 시 세션 유지가 필요하면 Redis 등 외부 스토리지 연동 검토
- 프론트엔드 채팅창에 `chat_id` 관리 로직 추가 후 엔드포인트 연결
