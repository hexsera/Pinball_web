# 업무일지

## 기본 정보
- 날짜: 2026-01-28 (화) 11:04~12:07
- 작성자: hexsera

## 진행 목표
핀볼 게임에서 공이 죽음구역에 떨어지면 다시 살릴 수 있는 부활 기능 구현. 사용자에게 재도전 기회를 제공하여 난이도를 조절하고 입문 장벽을 낮춤.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 핀볼 부활 시스템 만듬 | react/main/src/Pinball.jsx | |
| 핀볼 생명갯수 오류 수정 | PRD/핀볼살리기-실행계획.md | |

**총 2시간 30분**

## 주요 변경 사항

### 1. react/main/src/Pinball.jsx 수정

#### 변경 1: ballRef 및 livesRef useRef 추가

**변경 전:**
```javascript
function Pinball() {
  const sceneRef = useRef(null);
  const bgmRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [score, setScore] = useState(30);
```

**변경 후:**
```javascript
function Pinball() {
  const sceneRef = useRef(null);
  const bgmRef = useRef(null);
  const ballRef = useRef(null);
  const livesRef = useRef(3);
  const [isPlaying, setIsPlaying] = useState(false);
  const [score, setScore] = useState(30);
  const [lives, setLives] = useState(3);
```

**특징:**
- `ballRef`: ball 객체를 컴포넌트 전역에서 접근 가능하게 만듦
- `livesRef`: 이벤트 리스너 내부에서 최신 lives 값을 읽기 위한 ref
- `lives`: UI 표시 및 React 상태 관리용

#### 변경 2: ball 객체를 ballRef에 저장

**추가:**
```javascript
const ball = Bodies.circle(250, 400, 15, {
  restitution: 0.8,
  friction: 0,
  frictionAir: 0,
  render: { fillStyle: '#e94560' }
});

ballRef.current = ball;  // ref에 저장
```

#### 변경 3: 죽음구역 충돌 로직 수정 (공 부활 기능)

**변경 전:**
```javascript
// 죽음구역 충돌 감지
if ((bodyA.label === 'deathZone' && bodyB === ball) ||
    (bodyB.label === 'deathZone' && bodyA === ball)) {
  console.log('Ball entered death zone!');
  World.remove(engine.world, ball);
}
```

**변경 후:**
```javascript
// 죽음구역 충돌 감지
if ((bodyA.label === 'deathZone' && bodyB === ball) ||
    (bodyB.label === 'deathZone' && bodyA === ball)) {
  console.log('Ball entered death zone!');

  // livesRef로 최신 lives 값 확인
  if (livesRef.current > 0) {
    // 공을 초기 위치로 이동
    Body.setPosition(ball, { x: 250, y: 400 });

    // 속도 초기화
    Body.setVelocity(ball, { x: 0, y: 0 });

    // 각속도 초기화 (회전 방지)
    Body.setAngularVelocity(ball, 0);

    // lives 감소 (상태와 ref 모두 업데이트)
    const newLives = livesRef.current - 1;
    livesRef.current = newLives;
    setLives(newLives);

    console.log(`Ball revived! Lives remaining: ${newLives}`);
  } else {
    // 생명이 없으면 공 제거 (게임 오버)
    World.remove(engine.world, ball);
    console.log('Game Over!');
  }
}
```

**특징:**
- `World.remove()` 호출을 조건부로 변경 (livesRef.current === 0일 때만)
- `Body.setPosition()`으로 공을 초기 위치 (250, 400)로 이동
- `Body.setVelocity()`로 속도를 (0, 0)으로 초기화하여 정지 상태로 만듦
- `Body.setAngularVelocity(0)`으로 회전도 초기화
- lives 감소: `livesRef.current - 1`을 계산하여 `livesRef.current`와 `setLives()` 모두 업데이트

### 문제 상황
```javascript
useEffect(() => {
  // lives = 3으로 고정된 시점에서 이벤트 리스너 등록
  Events.on(engine, 'collisionStart', (event) => {

    // setLives(prev => prev - 1)로 React 상태는 업데이트됨
    // 하지만 if (lives > 0)의 lives는 여전히 3

    if (lives > 0) {  // ❌ 항상 3 > 0이므로 계속 부활
      setLives(prev => prev - 1);
    }
  });
}, []);  // 의존성 배열이 비어있어 한 번만 실행
```

### 해결 방법

**방법 1: livesRef 사용 (채택)**
```javascript
useEffect(() => {
  Events.on(engine, 'collisionStart', (event) => {

    if (livesRef.current > 0) {  // ✅ ref는 항상 최신 값 참조
      const newLives = livesRef.current - 1;
      livesRef.current = newLives;
      setLives(newLives);
    }
  });
}, []);
```

### 데이터 흐름

```
공이 죽음구역 진입
        │
        ▼
충돌 이벤트 발생 (collisionStart)
        │
        ▼
livesRef.current 확인
        │
        ├─ > 0 ──────────┐
        │                │
        │                ▼
        │         공 위치 리셋
        │         속도 초기화
        │         livesRef.current - 1
        │         setLives(newLives)
        │                │
        │                ▼
        │         콘솔 로그 출력
        │
        └─ === 0 ────────┐
                         │
                         ▼
                  World.remove(ball)
                  게임 오버
```

## 결과
- 상태: 완료

## 배운내용
useState, useRef 에 대해(겉핥기)

## 다음 작업
- Lives UI 표시 기능 (좌측 상단에 "LIVES: X" 표시)
- 게임 오버 UI 표시 기능 (화면 중앙에 "GAME OVER" 메시지)
- 재시작 버튼 추가 (선택 사항)


## 기본 정보
- 날짜: 2026-01-28 (화) 1:05~1:13, 2:45~3:05 
- 작성자: hexsera

## 진행 목표
핀볼 게임에서 목표 오브젝트(target)를 구현하여 사용자에게 명확한 목표를 부여하고 도전 정신을 고취시킴.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| target Bodies 생성 | react/main/src/Pinball.jsx | 하늘색 원형 오브젝트 추가
| World에 target 추가 | react/main/src/Pinball.jsx | Matter.js 월드에 target 등록
| target 충돌 이벤트 추가 | react/main/src/Pinball.jsx | 충돌 감지 및 콘솔 메시지 출력



## 주요 변경 사항

### 1. react/main/src/Pinball.jsx 수정

#### 변경 1: target Bodies 생성

**추가:**
```javascript
// 목표 오브젝트 만들기 (충돌 시 강하게 튕겨냄)
const target = Bodies.circle(500, 500, 40, {
  isStatic: true,
  restitution: 1.5,
  label: 'target',
  render: { fillStyle: '#87CEEB' }
});
```

**특징:**
- 위치: (500, 500) - bumper와 다른 위치
- 반지름: 40 (bumper와 동일한 크기)
- `isStatic: true`: 고정된 위치
- `restitution: 1.5`: bumper와 동일한 반발력 (충돌 시 강하게 튕겨냄)
- `label: 'target'`: 충돌 감지를 위한 식별자
- `fillStyle: '#87CEEB'`: 하늘색 (Sky Blue)

#### 변경 2: World에 target 추가

**변경 전:**
```javascript
World.add(engine.world, [
  ground,
  leftWall,
  rightWall,
  upWall,
  deathZone,
  ball,
  obstacle1,
  obstacle2,
  bumper,
  leftFlipper,
  rightFlipper,
  leftFlipperConstraint,
  rightFlipperConstraint
]);
```

**변경 후:**
```javascript
World.add(engine.world, [
  ground,
  leftWall,
  rightWall,
  upWall,
  deathZone,
  ball,
  obstacle1,
  obstacle2,
  bumper,
  target,  // target 추가
  leftFlipper,
  rightFlipper,
  leftFlipperConstraint,
  rightFlipperConstraint
]);
```

**특징:**
- bumper 다음에 target 추가하여 가독성 향상
- Matter.js 엔진이 target을 물리 시뮬레이션에 포함

#### 변경 3: target 충돌 이벤트 추가

**추가:**
```javascript
// 공과 목표 오브젝트가 충돌했는지 확인
if ((bodyA.label === 'target' && bodyB === ball) ||
    (bodyB.label === 'target' && bodyA === ball)) {
  console.log('target 충돌했음');
}
```

**특징:**
- bumper 충돌 이벤트와 동일한 구조
- `bodyA.label === 'target'` 또는 `bodyB.label === 'target'`로 충돌 감지
- 콘솔에 "target 충돌했음" 메시지 출력
- bumper 충돌 이벤트 다음, 죽음구역 충돌 이벤트 이전에 배치

### 2. PRD/핀볼목표오브젝트-실행계획.md 생성

**추가:**
- 요구사항 요약: 목표 오브젝트의 목적과 필요성
- 현재상태 분석: 기존 bumper 구조 분석
- 구현 방법: bumper 코드 재사용 및 색상/label 변경
- 구현 단계: 3단계 (target 생성, World 추가, 충돌 이벤트)
- 완료 체크리스트: 화면 표시, 위치, 충돌 감지, 튕김 효과 확인

**특징:**
- bumper를 기반으로 target을 생성하여 개발 시간 단축
- 하늘색(#87CEEB)으로 bumper(빨간색)와 시각적 구분
- restitution 1.5로 충돌 시 강한 반발력 제공

## 게임 오브젝트 구조

```
핀볼 게임 오브젝트
├── 경계
│   ├── ground (바닥)
│   ├── leftWall (왼쪽 벽)
│   ├── rightWall (오른쪽 벽)
│   ├── upWall (위 벽)
│   └── deathZone (죽음 구역)
├── 공
│   └── ball
├── 장애물
│   ├── obstacle1
│   └── obstacle2
├── 상호작용 오브젝트
│   ├── bumper (빨간색, 위치: 400, 600)
│   └── target (하늘색, 위치: 500, 500) ← 새로 추가
└── 플레이어 컨트롤
    ├── leftFlipper
    ├── rightFlipper
    ├── leftFlipperConstraint
    └── rightFlipperConstraint
```

## 충돌 이벤트 처리 순서

```
collisionStart 이벤트 발생
        │
        ▼
pairs.forEach((pair) => {
  │
  ├─ bumper 충돌? ──→ 공에 추가 속도 부여 (bumperForce)
  │
  ├─ target 충돌? ──→ console.log('target 충돌했음') ← 새로 추가
  │
  └─ deathZone 충돌? ──→ 부활 또는 게임 오버
})
```

## 결과
- 상태: 완료

## 배운내용
없음

## 다음 작업
- target 충돌 시 점수 증가 기능 추가
- target 충돌 횟수 표시 UI 구현
- 여러 개의 target 배치 (난이도 조절)
- target 충돌 시 시각적 효과 추가 (색상 변경, 애니메이션 등)


## 기본 정보
- 날짜: 2026-01-28 (화) 15:10~16:00
- 작성자: hexsera

## 진행 목표
핀볼 게임에 스테이지 전환 시스템을 도입하여 사용자에게 다양한 맵을 제공하고 반복적인 지루함을 줄임. 테스트를 위해 'n' 키로 스테이지 전환 가능하도록 설계 방법을 알아본다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 실행계획 문서 작성 | PRD/핀볼-맵-전환-실행계획.md | 구현 방법 및 단계별 절차 수립 |


## 주요 설계 사항

### 1. 스테이지 데이터 구조 설계

**신규 파일: react/main/src/stages.js**
```javascript
const stages = [
  {
    name: 'Stage 1',
    background: '/images/pinball_back.png',
    obstacles: [
      { type: 'circle', x: 300, y: 300, radius: 30, options: { isStatic: true, render: { fillStyle: '#0f3460' } } },
      { type: 'circle', x: 500, y: 300, radius: 30, options: { isStatic: true, render: { fillStyle: '#0f3460' } } },
    ],
    bumpers: [
      { x: 400, y: 600, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e74c3c' } } },
    ],
    targets: [
      { x: 500, y: 500, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#87CEEB' } } },
    ],
  },
  // Stage 2...
];
```

**특징:**
- 스테이지별로 name, background, obstacles, bumpers, targets 배열 정의
- 벽, 플리퍼, 공, 죽음구역은 공통이므로 스테이지 데이터에서 제외
- 확장성: 새 스테이지 추가 시 배열에 객체만 추가하면 됨

### 2. 스테이지 전환 로직 설계

**함수 1: createStageBodies(stageData)**
```javascript
const createStageBodies = (stageData) => {
  const bodies = [];

  // 장애물 생성
  stageData.obstacles.forEach((obs) => {
    if (obs.type === 'circle') {
      bodies.push(Bodies.circle(obs.x, obs.y, obs.radius, obs.options));
    }
  });

  // 범퍼 생성
  stageData.bumpers.forEach((b) => {
    bodies.push(Bodies.circle(b.x, b.y, b.radius, b.options));
  });

  // 타겟 생성
  stageData.targets.forEach((t) => {
    bodies.push(Bodies.circle(t.x, t.y, t.radius, t.options));
  });

  return bodies;
};
```

**함수 2: loadStage(stageIndex)**
```javascript
let currentStageIndex = 0;
let currentStageBodies = [];

const loadStage = (stageIndex) => {
  // 1. 기존 스테이지 Bodies 제거
  if (currentStageBodies.length > 0) {
    World.remove(engine.world, currentStageBodies);
  }

  // 2. 새 스테이지 Bodies 생성 및 추가
  const stageData = stages[stageIndex];
  currentStageBodies = createStageBodies(stageData);
  World.add(engine.world, currentStageBodies);

  // 3. 공 위치/속도 초기화
  Body.setPosition(ball, { x: 250, y: 400 });
  Body.setVelocity(ball, { x: 0, y: 0 });
  Body.setAngularVelocity(ball, 0);

  // 4. 스테이지 인덱스 업데이트
  currentStageIndex = stageIndex;

  console.log(`Stage loaded: ${stageData.name}`);
};
```

**특징:**
- `currentStageBodies` 배열로 현재 스테이지의 Bodies 추적
- `World.remove()` → 새 Bodies 생성 → `World.add()` 순서로 전환
- 공 초기화로 새 스테이지에서 다시 시작

### 3. 키보드 입력 처리

**handleKeyDown 함수에 추가:**
```javascript
if (event.key === 'n' || event.key === 'N') {
  const nextIndex = (currentStageIndex + 1) % stages.length;
  loadStage(nextIndex);
  console.log(`Stage changed to: ${stages[nextIndex].name}`);
}
```

**특징:**
- 'n' 또는 'N' 키로 다음 스테이지 전환
- `% stages.length`로 마지막 스테이지 → 첫 스테이지 순환

### 4. 초기 로딩 구조 변경

**변경 전:**
```javascript
// 개별 Bodies 생성
const obstacle1 = Bodies.circle(300, 300, 30, { isStatic: true });
const obstacle2 = Bodies.circle(500, 300, 30, { isStatic: true });
const bumper = Bodies.circle(400, 600, 40, { isStatic: true, restitution: 1.5, label: 'bumper' });
const target = Bodies.circle(500, 500, 40, { isStatic: true, restitution: 1.5, label: 'target' });

// 모든 Bodies를 World.add
World.add(engine.world, [
  ground, leftWall, rightWall, upWall, deathZone,
  ball, obstacle1, obstacle2, bumper, target,
  leftFlipper, rightFlipper,
  leftFlipperConstraint, rightFlipperConstraint
]);
```

**변경 후:**
```javascript
// 공통 Bodies만 World.add (벽, 플리퍼, 공, 죽음구역)
World.add(engine.world, [
  ground, leftWall, rightWall, upWall, deathZone,
  ball,
  leftFlipper, rightFlipper,
  leftFlipperConstraint, rightFlipperConstraint
]);

// 첫 번째 스테이지 로드
loadStage(0);
```

**특징:**
- 하드코딩된 장애물/범퍼/타겟 생성 코드 제거
- 공통 Bodies와 스테이지별 Bodies 분리
- `loadStage(0)`으로 첫 스테이지 초기화

## 현재 상태 분석 결과

### Pinball.jsx 구조 파악
- useEffect 내부에 모든 Bodies가 하드코딩되어 있음
- 키보드 핸들러(handleKeyDown/handleKeyUp) 이미 구현됨
- `World.add()`/`World.remove()` 사용 가능
- `ballRef`, `livesRef` 등 ref 사용 중
- cleanup 함수에서 `Engine.clear()` 호출로 모든 Bodies 정리

### 확장성 고려사항
- 스테이지 데이터를 별도 파일로 분리하여 관리 용이
- `createStageBodies()` 함수로 재사용성 확보
- `loadStage()` 함수로 스테이지 전환 로직 캡슐화
- 향후 스테이지별 배경이미지 변경 가능 (background 속성)

## 실행계획 문서 구성

### PRD/핀볼-맵-전환-실행계획.md

**섹션 구성:**
1. 요구사항 요약: 스테이지 전환 목적 및 'n' 키 테스트 기능
2. 현재상태 분석: 하드코딩된 Bodies 구조, 스테이지 개념 부재
3. 구현 방법: 스테이지 데이터 배열화, 동적 Bodies 생성/제거
4. 구현 단계: 6단계 (stages.js 생성, createStageBodies, loadStage, 초기화 변경, 'n' 키 핸들러, cleanup)
5. 수정/생성할 파일 목록: stages.js (생성), Pinball.jsx (수정)
6. 완료 체크리스트: 8개 항목 (스테이지 표시, 전환, 공 초기화, 순환, 벽/플리퍼 동작, 로그, 에러 확인)

**각 구현 단계 구성:**
- 단계 제목
- 코드 블록 (실제 구현 코드)
- 코드 설명 (bullet point)

## 결과
- 상태: 실행계획 완료 (구현은 미진행)
- 산출물: PRD/핀볼-맵-전환-실행계획.md

## 배운내용
레벨이라는 배열이 필요하다.
레벨 배열 안에는 레벨 안에 들어갈 객체들의 정보를 넣는다.
객체들의 정보들은 데이터의 집합과 같다.
이 데이터 집합을 레벨이 바뀔때
객체를 배치해주는 공장(함수) 에 넣는다.
이미 적인 객체 유형, 옵션을 공장에 넣어주면 공장은 자동으로 객체를 배치해준다.
이렇게 배치한 객체들은 "현재 객체" 배열에 미리 넣어주고
wolrd.add 에도 "현재 객체" 배열로 처리.
wolrd.remove 도 "현재 객체" 배열로 지워준다.

## 다음 작업
- PRD/핀볼-맵-전환-실행계획.md 구현 (stages.js 생성, Pinball.jsx 수정)
- 스테이지별 배경이미지 변경 기능 추가 (선택 사항)
- 스테이지 번호 UI 표시 (우측 상단에 "STAGE: X" 표시)
- 스테이지 클리어 조건 추가 (모든 target 충돌 시 자동 전환)
