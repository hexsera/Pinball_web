# 업무일지

## 기본 정보
- 날짜: 2026-01-28 (화) 11:04~12:07
- 작성자: hexsera

## 진행 목표
핀볼 게임에서 공이 죽음구역에 떨어지면 다시 살릴 수 있는 부활 기능 구현. 사용자에게 재도전 기회를 제공하여 난이도를 조절하고 입문 장벽을 낮춤.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 핀볼 부활 시스템 만듬 | react/main/src/Pinball.jsx | |
| 핀볼 생명갯수 오류 수정 | PRD/핀볼살리기-실행계획.md | |

**총 2시간 30분**

## 주요 변경 사항

### 1. react/main/src/Pinball.jsx 수정

#### 변경 1: ballRef 및 livesRef useRef 추가

**변경 전:**
```javascript
function Pinball() {
  const sceneRef = useRef(null);
  const bgmRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [score, setScore] = useState(30);
```

**변경 후:**
```javascript
function Pinball() {
  const sceneRef = useRef(null);
  const bgmRef = useRef(null);
  const ballRef = useRef(null);
  const livesRef = useRef(3);
  const [isPlaying, setIsPlaying] = useState(false);
  const [score, setScore] = useState(30);
  const [lives, setLives] = useState(3);
```

**특징:**
- `ballRef`: ball 객체를 컴포넌트 전역에서 접근 가능하게 만듦
- `livesRef`: 이벤트 리스너 내부에서 최신 lives 값을 읽기 위한 ref
- `lives`: UI 표시 및 React 상태 관리용

#### 변경 2: ball 객체를 ballRef에 저장

**추가:**
```javascript
const ball = Bodies.circle(250, 400, 15, {
  restitution: 0.8,
  friction: 0,
  frictionAir: 0,
  render: { fillStyle: '#e94560' }
});

ballRef.current = ball;  // ref에 저장
```

#### 변경 3: 죽음구역 충돌 로직 수정 (공 부활 기능)

**변경 전:**
```javascript
// 죽음구역 충돌 감지
if ((bodyA.label === 'deathZone' && bodyB === ball) ||
    (bodyB.label === 'deathZone' && bodyA === ball)) {
  console.log('Ball entered death zone!');
  World.remove(engine.world, ball);
}
```

**변경 후:**
```javascript
// 죽음구역 충돌 감지
if ((bodyA.label === 'deathZone' && bodyB === ball) ||
    (bodyB.label === 'deathZone' && bodyA === ball)) {
  console.log('Ball entered death zone!');

  // livesRef로 최신 lives 값 확인
  if (livesRef.current > 0) {
    // 공을 초기 위치로 이동
    Body.setPosition(ball, { x: 250, y: 400 });

    // 속도 초기화
    Body.setVelocity(ball, { x: 0, y: 0 });

    // 각속도 초기화 (회전 방지)
    Body.setAngularVelocity(ball, 0);

    // lives 감소 (상태와 ref 모두 업데이트)
    const newLives = livesRef.current - 1;
    livesRef.current = newLives;
    setLives(newLives);

    console.log(`Ball revived! Lives remaining: ${newLives}`);
  } else {
    // 생명이 없으면 공 제거 (게임 오버)
    World.remove(engine.world, ball);
    console.log('Game Over!');
  }
}
```

**특징:**
- `World.remove()` 호출을 조건부로 변경 (livesRef.current === 0일 때만)
- `Body.setPosition()`으로 공을 초기 위치 (250, 400)로 이동
- `Body.setVelocity()`로 속도를 (0, 0)으로 초기화하여 정지 상태로 만듦
- `Body.setAngularVelocity(0)`으로 회전도 초기화
- lives 감소: `livesRef.current - 1`을 계산하여 `livesRef.current`와 `setLives()` 모두 업데이트

### 문제 상황
```javascript
useEffect(() => {
  // lives = 3으로 고정된 시점에서 이벤트 리스너 등록
  Events.on(engine, 'collisionStart', (event) => {

    // setLives(prev => prev - 1)로 React 상태는 업데이트됨
    // 하지만 if (lives > 0)의 lives는 여전히 3

    if (lives > 0) {  // ❌ 항상 3 > 0이므로 계속 부활
      setLives(prev => prev - 1);
    }
  });
}, []);  // 의존성 배열이 비어있어 한 번만 실행
```

### 해결 방법

**방법 1: livesRef 사용 (채택)**
```javascript
useEffect(() => {
  Events.on(engine, 'collisionStart', (event) => {

    if (livesRef.current > 0) {  // ✅ ref는 항상 최신 값 참조
      const newLives = livesRef.current - 1;
      livesRef.current = newLives;
      setLives(newLives);
    }
  });
}, []);
```

### 데이터 흐름

```
공이 죽음구역 진입
        │
        ▼
충돌 이벤트 발생 (collisionStart)
        │
        ▼
livesRef.current 확인
        │
        ├─ > 0 ──────────┐
        │                │
        │                ▼
        │         공 위치 리셋
        │         속도 초기화
        │         livesRef.current - 1
        │         setLives(newLives)
        │                │
        │                ▼
        │         콘솔 로그 출력
        │
        └─ === 0 ────────┐
                         │
                         ▼
                  World.remove(ball)
                  게임 오버
```

## 결과
- 상태: 완료

## 배운내용
useState, useRef 에 대해(겉핥기)

## 다음 작업
- Lives UI 표시 기능 (좌측 상단에 "LIVES: X" 표시)
- 게임 오버 UI 표시 기능 (화면 중앙에 "GAME OVER" 메시지)
- 재시작 버튼 추가 (선택 사항)
