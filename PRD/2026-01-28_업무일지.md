# 업무일지

## 기본 정보
- 날짜: 2026-01-28 (화) 11:04~12:07
- 작성자: hexsera

## 진행 목표
핀볼 게임에서 공이 죽음구역에 떨어지면 다시 살릴 수 있는 부활 기능 구현. 사용자에게 재도전 기회를 제공하여 난이도를 조절하고 입문 장벽을 낮춤.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 핀볼 부활 시스템 만듬 | react/main/src/Pinball.jsx | |
| 핀볼 생명갯수 오류 수정 | PRD/핀볼살리기-실행계획.md | |

**총 2시간 30분**

## 주요 변경 사항

### 1. react/main/src/Pinball.jsx 수정

#### 변경 1: ballRef 및 livesRef useRef 추가

**변경 전:**
```javascript
function Pinball() {
  const sceneRef = useRef(null);
  const bgmRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [score, setScore] = useState(30);
```

**변경 후:**
```javascript
function Pinball() {
  const sceneRef = useRef(null);
  const bgmRef = useRef(null);
  const ballRef = useRef(null);
  const livesRef = useRef(3);
  const [isPlaying, setIsPlaying] = useState(false);
  const [score, setScore] = useState(30);
  const [lives, setLives] = useState(3);
```

**특징:**
- `ballRef`: ball 객체를 컴포넌트 전역에서 접근 가능하게 만듦
- `livesRef`: 이벤트 리스너 내부에서 최신 lives 값을 읽기 위한 ref
- `lives`: UI 표시 및 React 상태 관리용

#### 변경 2: ball 객체를 ballRef에 저장

**추가:**
```javascript
const ball = Bodies.circle(250, 400, 15, {
  restitution: 0.8,
  friction: 0,
  frictionAir: 0,
  render: { fillStyle: '#e94560' }
});

ballRef.current = ball;  // ref에 저장
```

#### 변경 3: 죽음구역 충돌 로직 수정 (공 부활 기능)

**변경 전:**
```javascript
// 죽음구역 충돌 감지
if ((bodyA.label === 'deathZone' && bodyB === ball) ||
    (bodyB.label === 'deathZone' && bodyA === ball)) {
  console.log('Ball entered death zone!');
  World.remove(engine.world, ball);
}
```

**변경 후:**
```javascript
// 죽음구역 충돌 감지
if ((bodyA.label === 'deathZone' && bodyB === ball) ||
    (bodyB.label === 'deathZone' && bodyA === ball)) {
  console.log('Ball entered death zone!');

  // livesRef로 최신 lives 값 확인
  if (livesRef.current > 0) {
    // 공을 초기 위치로 이동
    Body.setPosition(ball, { x: 250, y: 400 });

    // 속도 초기화
    Body.setVelocity(ball, { x: 0, y: 0 });

    // 각속도 초기화 (회전 방지)
    Body.setAngularVelocity(ball, 0);

    // lives 감소 (상태와 ref 모두 업데이트)
    const newLives = livesRef.current - 1;
    livesRef.current = newLives;
    setLives(newLives);

    console.log(`Ball revived! Lives remaining: ${newLives}`);
  } else {
    // 생명이 없으면 공 제거 (게임 오버)
    World.remove(engine.world, ball);
    console.log('Game Over!');
  }
}
```

**특징:**
- `World.remove()` 호출을 조건부로 변경 (livesRef.current === 0일 때만)
- `Body.setPosition()`으로 공을 초기 위치 (250, 400)로 이동
- `Body.setVelocity()`로 속도를 (0, 0)으로 초기화하여 정지 상태로 만듦
- `Body.setAngularVelocity(0)`으로 회전도 초기화
- lives 감소: `livesRef.current - 1`을 계산하여 `livesRef.current`와 `setLives()` 모두 업데이트

### 문제 상황
```javascript
useEffect(() => {
  // lives = 3으로 고정된 시점에서 이벤트 리스너 등록
  Events.on(engine, 'collisionStart', (event) => {

    // setLives(prev => prev - 1)로 React 상태는 업데이트됨
    // 하지만 if (lives > 0)의 lives는 여전히 3

    if (lives > 0) {  // ❌ 항상 3 > 0이므로 계속 부활
      setLives(prev => prev - 1);
    }
  });
}, []);  // 의존성 배열이 비어있어 한 번만 실행
```

### 해결 방법

**방법 1: livesRef 사용 (채택)**
```javascript
useEffect(() => {
  Events.on(engine, 'collisionStart', (event) => {

    if (livesRef.current > 0) {  // ✅ ref는 항상 최신 값 참조
      const newLives = livesRef.current - 1;
      livesRef.current = newLives;
      setLives(newLives);
    }
  });
}, []);
```

### 데이터 흐름

```
공이 죽음구역 진입
        │
        ▼
충돌 이벤트 발생 (collisionStart)
        │
        ▼
livesRef.current 확인
        │
        ├─ > 0 ──────────┐
        │                │
        │                ▼
        │         공 위치 리셋
        │         속도 초기화
        │         livesRef.current - 1
        │         setLives(newLives)
        │                │
        │                ▼
        │         콘솔 로그 출력
        │
        └─ === 0 ────────┐
                         │
                         ▼
                  World.remove(ball)
                  게임 오버
```

## 결과
- 상태: 완료

## 배운내용
useState, useRef 에 대해(겉핥기)

## 다음 작업
- Lives UI 표시 기능 (좌측 상단에 "LIVES: X" 표시)
- 게임 오버 UI 표시 기능 (화면 중앙에 "GAME OVER" 메시지)
- 재시작 버튼 추가 (선택 사항)


## 기본 정보
- 날짜: 2026-01-28 (화) 1:05~1:13, 2:45~3:05 
- 작성자: hexsera

## 진행 목표
핀볼 게임에서 목표 오브젝트(target)를 구현하여 사용자에게 명확한 목표를 부여하고 도전 정신을 고취시킴.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| target Bodies 생성 | react/main/src/Pinball.jsx | 하늘색 원형 오브젝트 추가
| World에 target 추가 | react/main/src/Pinball.jsx | Matter.js 월드에 target 등록
| target 충돌 이벤트 추가 | react/main/src/Pinball.jsx | 충돌 감지 및 콘솔 메시지 출력



## 주요 변경 사항

### 1. react/main/src/Pinball.jsx 수정

#### 변경 1: target Bodies 생성

**추가:**
```javascript
// 목표 오브젝트 만들기 (충돌 시 강하게 튕겨냄)
const target = Bodies.circle(500, 500, 40, {
  isStatic: true,
  restitution: 1.5,
  label: 'target',
  render: { fillStyle: '#87CEEB' }
});
```

**특징:**
- 위치: (500, 500) - bumper와 다른 위치
- 반지름: 40 (bumper와 동일한 크기)
- `isStatic: true`: 고정된 위치
- `restitution: 1.5`: bumper와 동일한 반발력 (충돌 시 강하게 튕겨냄)
- `label: 'target'`: 충돌 감지를 위한 식별자
- `fillStyle: '#87CEEB'`: 하늘색 (Sky Blue)

#### 변경 2: World에 target 추가

**변경 전:**
```javascript
World.add(engine.world, [
  ground,
  leftWall,
  rightWall,
  upWall,
  deathZone,
  ball,
  obstacle1,
  obstacle2,
  bumper,
  leftFlipper,
  rightFlipper,
  leftFlipperConstraint,
  rightFlipperConstraint
]);
```

**변경 후:**
```javascript
World.add(engine.world, [
  ground,
  leftWall,
  rightWall,
  upWall,
  deathZone,
  ball,
  obstacle1,
  obstacle2,
  bumper,
  target,  // target 추가
  leftFlipper,
  rightFlipper,
  leftFlipperConstraint,
  rightFlipperConstraint
]);
```

**특징:**
- bumper 다음에 target 추가하여 가독성 향상
- Matter.js 엔진이 target을 물리 시뮬레이션에 포함

#### 변경 3: target 충돌 이벤트 추가

**추가:**
```javascript
// 공과 목표 오브젝트가 충돌했는지 확인
if ((bodyA.label === 'target' && bodyB === ball) ||
    (bodyB.label === 'target' && bodyA === ball)) {
  console.log('target 충돌했음');
}
```

**특징:**
- bumper 충돌 이벤트와 동일한 구조
- `bodyA.label === 'target'` 또는 `bodyB.label === 'target'`로 충돌 감지
- 콘솔에 "target 충돌했음" 메시지 출력
- bumper 충돌 이벤트 다음, 죽음구역 충돌 이벤트 이전에 배치

### 2. PRD/핀볼목표오브젝트-실행계획.md 생성

**추가:**
- 요구사항 요약: 목표 오브젝트의 목적과 필요성
- 현재상태 분석: 기존 bumper 구조 분석
- 구현 방법: bumper 코드 재사용 및 색상/label 변경
- 구현 단계: 3단계 (target 생성, World 추가, 충돌 이벤트)
- 완료 체크리스트: 화면 표시, 위치, 충돌 감지, 튕김 효과 확인

**특징:**
- bumper를 기반으로 target을 생성하여 개발 시간 단축
- 하늘색(#87CEEB)으로 bumper(빨간색)와 시각적 구분
- restitution 1.5로 충돌 시 강한 반발력 제공

## 게임 오브젝트 구조

```
핀볼 게임 오브젝트
├── 경계
│   ├── ground (바닥)
│   ├── leftWall (왼쪽 벽)
│   ├── rightWall (오른쪽 벽)
│   ├── upWall (위 벽)
│   └── deathZone (죽음 구역)
├── 공
│   └── ball
├── 장애물
│   ├── obstacle1
│   └── obstacle2
├── 상호작용 오브젝트
│   ├── bumper (빨간색, 위치: 400, 600)
│   └── target (하늘색, 위치: 500, 500) ← 새로 추가
└── 플레이어 컨트롤
    ├── leftFlipper
    ├── rightFlipper
    ├── leftFlipperConstraint
    └── rightFlipperConstraint
```

## 충돌 이벤트 처리 순서

```
collisionStart 이벤트 발생
        │
        ▼
pairs.forEach((pair) => {
  │
  ├─ bumper 충돌? ──→ 공에 추가 속도 부여 (bumperForce)
  │
  ├─ target 충돌? ──→ console.log('target 충돌했음') ← 새로 추가
  │
  └─ deathZone 충돌? ──→ 부활 또는 게임 오버
})
```

## 결과
- 상태: 완료

## 배운내용
없음

## 다음 작업
- target 충돌 시 점수 증가 기능 추가
- target 충돌 횟수 표시 UI 구현
- 여러 개의 target 배치 (난이도 조절)
- target 충돌 시 시각적 효과 추가 (색상 변경, 애니메이션 등)
