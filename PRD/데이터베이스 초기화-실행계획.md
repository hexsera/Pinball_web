# 데이터베이스 초기화 실행계획

## 요구사항 요약

**요구사항**: DB의 모든 테이블과 데이터를 삭제한 후 모델 기준으로 재생성. Alembic 마이그레이션 이력도 초기화.

**목적**: 잘못된 마이그레이션 이력, 불필요한 데이터, 또는 스키마 불일치를 완전히 제거하고 깨끗한 초기 상태로 돌아가기 위함.

## 현재상태 분석

- 테이블: `users`, `friendships`, `monthly_scores`, `game_visits`, `high_scores`, `scores` (6개)
- FK: friendships, monthly_scores, high_scores, game_visits → users.id (ON DELETE CASCADE 없음)
- 특수 Constraints:
  - `ck_no_self_friend`: friendships.requester_id != receiver_id (CheckConstraint)
  - `uq_friendship_pair`: (requester_id, receiver_id) UniqueConstraint
  - `high_scores.user_id`: UNIQUE (사용자당 1개)
- Alembic 마이그레이션: 6단계 체인 (None → 7c93967e31b7)
- PostgreSQL 확장: `uuid-ossp` (6fe36d8bc6a2 마이그레이션에서 설치됨)

## 구현 방법

1. DB에서 현재 constraints를 직접 조회하여 기록
2. `alembic downgrade base` 로 모든 마이그레이션 롤백 (테이블 삭제)
3. `versions/` 디렉토리의 기존 마이그레이션 파일 전부 삭제
4. `alembic revision --autogenerate` 로 단일 초기 마이그레이션 생성
5. `alembic upgrade head` 로 테이블 재생성
6. DB에서 constraints 재확인

## 구현 단계

### 1. 현재 DB constraints 조회 (기준값 기록)

```sql
-- 1-1. 모든 테이블의 FK constraints 조회
SELECT
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    kcu.column_name,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc
JOIN information_schema.key_column_usage AS kcu
    ON tc.constraint_name = kcu.constraint_name
    AND tc.table_schema = kcu.table_schema
LEFT JOIN information_schema.constraint_column_usage AS ccu
    ON ccu.constraint_name = tc.constraint_name
WHERE tc.table_schema = 'public'
  AND tc.constraint_type IN ('FOREIGN KEY', 'UNIQUE', 'CHECK')
ORDER BY tc.table_name, tc.constraint_type;

-- 1-2. 현재 alembic 버전 확인
SELECT version_num FROM alembic_version;
```

- **무엇을 하는가**: 초기화 전 DB에 실제 존재하는 constraints를 기록하여 재생성 후 비교 기준으로 사용
- `information_schema`는 PostgreSQL 표준 시스템 카탈로그로 별도 권한 없이 조회 가능
- 실행 위치: `docker-compose exec postgres psql -U hexsera -d hexdb`

### 2. Alembic downgrade로 모든 테이블 제거

```bash
docker-compose exec fastapi alembic downgrade base
```

- **무엇을 하는가**: Alembic이 마이그레이션 파일의 `downgrade()` 함수를 역순으로 실행하여 테이블을 삭제
- `base`는 마이그레이션 체인의 시작점(revision=None) 이전 상태, 즉 모든 테이블이 없는 상태
- 단, `eccd28617903`의 downgrade()가 `pass`이므로, 이 단계 이전 테이블(`users`, `scores`)은 수동 삭제 필요

### 3. 잔여 테이블 수동 삭제 및 alembic_version 초기화

```sql
-- CASCADE로 참조 무결성 무시하고 강제 삭제
DROP TABLE IF EXISTS scores CASCADE;
DROP TABLE IF EXISTS users CASCADE;
DROP TABLE IF EXISTS alembic_version CASCADE;
```

- **무엇을 하는가**: `downgrade base` 후에도 남아있는 테이블과 alembic 이력 테이블을 완전히 제거
- `CASCADE`는 해당 테이블을 참조하는 다른 FK constraints도 함께 제거
- 실행 위치: `docker-compose exec postgres psql -U hexsera -d hexdb`

### 4. 기존 마이그레이션 파일 삭제

```bash
rm /home/hexsera/Pinball_web/backend/alembic/versions/*.py
rm -rf /home/hexsera/Pinball_web/backend/alembic/versions/__pycache__
```

- **무엇을 하는가**: 이전 마이그레이션 이력 파일을 전부 제거하여 새 단일 마이그레이션의 시작점을 만듦
- `versions_mysql_backup/`은 백업 디렉토리이므로 삭제하지 않음

### 5. 새 초기 마이그레이션 생성 및 적용

```bash
# 현재 모델(models.py) 기준으로 단일 마이그레이션 파일 자동 생성
docker-compose exec fastapi alembic revision --autogenerate -m "initial_schema"

# 생성된 마이그레이션을 DB에 적용 (테이블 재생성)
docker-compose exec fastapi alembic upgrade head
```

- **무엇을 하는가**: 현재 `models.py`에 정의된 모든 테이블과 constraints를 하나의 마이그레이션으로 생성하고 DB에 적용
- `--autogenerate`는 `models.py`의 SQLAlchemy 모델과 현재 DB 상태를 비교하여 차이를 마이그레이션으로 생성
- 생성된 파일을 반드시 검토(`alembic/versions/` 디렉토리)하여 누락된 항목이 없는지 확인

### 6. 재생성 후 constraints 확인

```sql
-- 1단계와 동일한 쿼리로 재조회하여 기준값과 비교
SELECT
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    kcu.column_name,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc
JOIN information_schema.key_column_usage AS kcu
    ON tc.constraint_name = kcu.constraint_name
    AND tc.table_schema = kcu.table_schema
LEFT JOIN information_schema.constraint_column_usage AS ccu
    ON ccu.constraint_name = tc.constraint_name
WHERE tc.table_schema = 'public'
  AND tc.constraint_type IN ('FOREIGN KEY', 'UNIQUE', 'CHECK')
ORDER BY tc.table_name, tc.constraint_type;
```

- **무엇을 하는가**: 재생성된 테이블의 constraints가 모델 정의와 일치하는지 DB 레벨에서 직접 검증
- 확인 대상: FK 6개, UNIQUE 3개(`users.user_id`, `users.email`, `high_scores.user_id`), UniqueConstraint 1개(`uq_friendship_pair`), CheckConstraint 1개(`ck_no_self_friend`)

## 수정/생성할 파일 목록

| 파일 경로 | 작업 유형 | 변경 내용 |
|-----------|-----------|-----------|
| `backend/alembic/versions/*.py` | 삭제 | 기존 마이그레이션 파일 6개 전부 삭제 |
| `backend/alembic/versions/__pycache__/` | 삭제 | 캐시 디렉토리 삭제 |
| `backend/alembic/versions/<hash>_initial_schema.py` | 생성 | autogenerate로 생성되는 새 초기 마이그레이션 |

## 완료 체크리스트

- [ ] `docker-compose exec postgres psql -U hexsera -d hexdb -c "\dt"` 실행 시 6개 테이블(`users`, `friendships`, `monthly_scores`, `game_visits`, `high_scores`, `scores`)이 모두 표시된다
- [ ] `SELECT version_num FROM alembic_version;` 결과가 1개의 revision hash를 반환한다
- [ ] `alembic/versions/` 에 마이그레이션 파일이 정확히 1개만 존재한다
- [ ] DB constraints 조회 결과: FK 6개, UNIQUE 3개, CheckConstraint 1개, UniqueConstraint 1개가 모두 존재한다
- [ ] `docker-compose exec fastapi pytest` 실행 시 모든 테스트가 통과한다
