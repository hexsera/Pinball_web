# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 10:30~11:00
- 작성자: hexsera

## 진행 목표
`game_visits.user_id`에 `users.id`를 참조하는 FK 제약을 추가하고, User 삭제 시 `game_visits` 레코드를 삭제하지 않고 `user_id`를 NULL로 변환하여 방문 기록을 보존한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| GameVisit 모델에 FK 추가 | `backend/models.py` | `ForeignKey('users.id')` 추가 |
| Alembic 마이그레이션 생성 및 적용 | `backend/alembic/versions/7c93967e31b7_...py` | 고아 데이터 정리 후 FK 제약 적용 |
| User 삭제 로직에 NULL 처리 추가 | `backend/app/api/v1/users.py` | GameVisit import 추가 및 NULL 업데이트 쿼리 추가 |


## 주요 변경 사항

### 1. backend/models.py 수정

**변경 전:**
```python
class GameVisit(Base):
    __tablename__ = "game_visits"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=True, index=True)
```

**변경 후:**
```python
class GameVisit(Base):
    __tablename__ = "game_visits"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=True, index=True)
```

**특징:**
- `ForeignKey('users.id')` 추가로 ORM 레벨에서 `game_visits.user_id → users.id` 참조 관계 선언
- `nullable=True` 유지 — 익명 방문자(비로그인)는 user_id가 NULL로 저장되므로 제거 불가

---

### 2. backend/alembic/versions/7c93967e31b7_add_foreign_key_to_game_visits_user_id.py 생성

**추가:**
```python
def upgrade() -> None:
    # users 테이블에 존재하지 않는 고아 user_id를 NULL로 정리
    op.execute(
        "UPDATE game_visits SET user_id = NULL "
        "WHERE user_id IS NOT NULL "
        "AND user_id NOT IN (SELECT id FROM users)"
    )
    op.create_foreign_key(None, 'game_visits', 'users', ['user_id'], ['id'])

def downgrade() -> None:
    op.drop_constraint(None, 'game_visits', type_='foreignkey')
```

**특징:**
- FK 제약 추가 전 고아 데이터(users에 없는 user_id=3) 를 NULL로 정리하는 SQL을 먼저 실행
- 고아 데이터가 존재할 경우 `op.create_foreign_key()` 단독 실행 시 FK 위반 오류가 발생하므로 사전 정리 필수
- `down_revision = '0ceb423c2879'` 으로 기존 마이그레이션 체인에 연결

---

### 3. backend/app/api/v1/users.py 수정

**변경 전:**
```python
from models import User, MonthlyScore, Friendship, HighScore

# FK 참조 테이블 데이터 먼저 삭제
db.query(Friendship).filter(
    (Friendship.requester_id == user_id) | (Friendship.receiver_id == user_id)
).delete(synchronize_session=False)
```

**변경 후:**
```python
from models import User, MonthlyScore, Friendship, HighScore, GameVisit

# FK 참조 테이블 데이터 먼저 삭제
# GameVisit의 user_id를 NULL로 설정 (방문 기록 보존, FK 위반 방지)
db.query(GameVisit).filter(GameVisit.user_id == user_id)\
    .update({"user_id": None}, synchronize_session=False)

db.query(Friendship).filter(
    (Friendship.requester_id == user_id) | (Friendship.receiver_id == user_id)
).delete(synchronize_session=False)
```

**특징:**
- FK 제약 추가 후 User 삭제 시 발생하는 FK 위반 오류를 방지
- 레코드를 삭제하지 않고 `user_id`만 NULL로 변환하여 방문 통계 데이터 보존
- User 삭제(`db.delete(user)`) 이전에 실행하여 FK 제약 위반 방지

---

### 데이터 흐름 변경

**User 삭제 순서 (변경 후):**
```
DELETE /api/v1/users/{user_id}
        │
        ▼
GameVisit.user_id → NULL  (방문 기록 보존)
        │
        ▼
Friendship 삭제  (requester_id / receiver_id)
        │
        ▼
MonthlyScore 삭제
        │
        ▼
HighScore 삭제
        │
        ▼
User 삭제
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
- gamevits post 할 때 user_id PK 없으면 오류 메시지 뜨도록 해야함

# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 11:40~12:20
- 작성자: hexsera

## 진행 목표
데이터베이스의 모든 테이블과 데이터를 완전히 제거한 후 재생성한다. Alembic 마이그레이션 이력도 단일 초기 revision으로 초기화한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| DB constraints 사전 조회 | - | 초기화 전 기준값 기록 |
| 모든 테이블 DROP | - | CASCADE로 6개 테이블 + alembic_version 제거 |
| 기존 마이그레이션 파일 삭제 | `backend/alembic/versions/*.py` | 6개 파일 + __pycache__ 삭제 |
| 새 초기 마이그레이션 파일 생성 | `backend/alembic/versions/60a77f2baf38_initial_schema.py` | autogenerate로 생성 |
| FastAPI 재기동으로 테이블 재생성 | - | 부트스트래핑으로 6개 테이블 자동 생성 |
| alembic stamp head | - | 현재 DB 상태를 HEAD로 등록 |
| constraints 재확인 | - | 초기화 전 기준값과 동일함 확인 |

## 주요 변경 사항

### 1. backend/alembic/versions/ 수정

**변경 전 (6개 파일):**
```
eccd28617903_initial_postgresql_migration.py
6fe36d8bc6a2_add_user_id_column_to_users_table.py
f38f15d3477d_add_foreign_key_constraints_to_.py
45f71363a042_add_foreign_key_to_high_scores_user_id.py
0ceb423c2879_add_foreign_key_to_monthly_scores_user_.py
7c93967e31b7_add_foreign_key_to_game_visits_user_id.py
```

**변경 후 (1개 파일):**
```
60a77f2baf38_initial_schema.py  (upgrade: pass, alembic stamp head로 등록)
```

**특징:**
- 기존 6단계 마이그레이션 체인을 단일 revision으로 통합
- 테이블 생성은 마이그레이션이 아닌 FastAPI 부트스트래핑이 담당
- `alembic stamp head`로 현재 DB 상태를 alembic_version에 등록

---

### 데이터베이스 초기화 흐름

```
DROP TABLE 6개 + alembic_version (CASCADE)
        │
        ▼
versions/*.py 삭제 (마이그레이션 이력 초기화)
        │
        ▼
alembic revision --autogenerate (빈 upgrade 파일 생성)
        │
        ▼
docker compose restart fastapi (부트스트래핑으로 테이블 재생성)
        │
        ▼
alembic stamp head (현재 상태를 HEAD로 등록)
```

---

### constraints 비교 (초기화 전 → 후)

```
friendships_requester_id_fkey  (FK)  : 유지
friendships_receiver_id_fkey   (FK)  : 유지
uq_friendship_pair             (UNIQUE + CHECK): 유지
game_visits_user_id_fkey       (FK)  : 유지
high_scores_user_id_fkey       (FK)  : 유지
monthly_scores_user_id_fkey    (FK)  : 유지
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업


---

# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 12:20:13:00
- 작성자: hexsera

## 진행 목표
`users` 테이블과 `monthly_scores` 테이블에 mock 데이터를 삽입하여 실제 서비스 환경과 유사한 데이터 상태를 구성한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| Faker 의존성 추가 | `backend/requirements.txt` | `Faker==24.0.0` 추가 |
| mock 디렉토리 구조 생성 | `backend/scripts/__init__.py`, `backend/scripts/mock/__init__.py` | 업계 표준 scripts/mock/ 구조 |
| mock 데이터 스크립트 작성 | `backend/scripts/mock/seed_mock_data.py` | User 50명 + MonthlyScore 50개 생성 |
| Docker 컨테이너 재빌드 및 실행 | - | Faker 설치 반영 후 스크립트 실행 |
| 한글 닉네임으로 수정 | `backend/scripts/mock/seed_mock_data.py` | `user_name()` → `last_name()+first_name()` 조합으로 변경 |

## 주요 변경 사항

### 1. backend/requirements.txt 수정

**변경 전:**
```text
httpx==0.27.0
```

**변경 후:**
```text
httpx==0.27.0
Faker==24.0.0
```

**특징:**
- Faker: 이름, 이메일, 날짜 등 현실적인 가짜 데이터를 생성하는 Python 표준 라이브러리

---

### 2. backend/scripts/mock/seed_mock_data.py 생성

**추가:**
```python
import sys, os, random
from datetime import datetime, timedelta

sys.path.insert(0, '/code')

from faker import Faker
from app.db.session import SessionLocal
from models import User, MonthlyScore

fake = Faker('ko_KR')

def _unique_korean_nickname(used: set) -> str:
    for _ in range(100):
        nickname = fake.last_name() + fake.first_name()
        if nickname not in used:
            used.add(nickname)
            return nickname
    raise ValueError("중복되지 않는 닉네임 생성 실패")

def create_mock_users(db, count=50):
    used_nicknames = set()
    for _ in range(count):
        user = User(
            email=fake.unique.email(),
            nickname=_unique_korean_nickname(used_nicknames),
            password="password123!",
            birth_date=fake.date_of_birth(minimum_age=15, maximum_age=60),
            role='user'
        )
        db.add(user)
    db.commit()
    db.expire_all()
    return db.query(User).filter(User.role == 'user').order_by(User.id.desc()).limit(count).all()

def create_mock_monthly_scores(db, users):
    for user in users:
        score = MonthlyScore(
            user_id=user.id,
            nickname=user.nickname,
            score=random.randint(1000, 59999),
            created_at=datetime.utcnow() - timedelta(days=random.randint(0, 30))
        )
        db.add(score)
    db.commit()
```

**특징:**
- `password="password123!"`: mock 데이터 전용, 평문 저장
- `user_id`당 MonthlyScore 1개만 삽입 (API의 upsert 설계 원칙 준수)
- `score`: 1,000~59,999 범위, `created_at`: 최근 30일 이내 랜덤
- `nickname`: `fake.last_name() + fake.first_name()` 조합으로 한글 닉네임 생성 (`user_name()`은 로케일 무관 영문 반환)
- `_unique_korean_nickname()`: 세션 내 중복 방지를 위한 set 기반 중복 검사

---

### 스크립트 실행 흐름

```
docker compose build fastapi  (Faker 패키지 설치)
        │
        ▼
docker compose up -d fastapi
        │
        ▼
docker compose exec fastapi python scripts/mock/seed_mock_data.py
        │
        ▼
users 50명 생성 (한글 닉네임, 평문 비밀번호)
        │
        ▼
monthly_scores 50개 생성 (user_id당 1개)
```

---

### 트러블슈팅

| 문제 | 원인 | 해결 |
|------|------|------|
| `ModuleNotFoundError: No module named 'app'` | 컨테이너 WORKDIR가 `/app`이 아닌 `/code` | `sys.path.insert(0, '/code')`로 수정 |
| 닉네임이 영문으로 생성됨 | `fake.user_name()`은 로케일 무관 영문 반환 | `fake.last_name() + fake.first_name()` 조합으로 변경 |

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
- 이메일 중복 제약사항 생성 고민
- 월간 테이블 post 시 이번달 범위에서만 중복 확인

---

# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 13:20~13:50
- 작성자: hexsera

## 진행 목표
`friendships` 테이블과 `game_visits` 테이블에 mock 데이터를 삽입하여 개발·테스트 환경에서 친구 관계 및 게임 방문 기록 데이터를 시뮬레이션한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| mock 스크립트 작성 | `backend/scripts/mock/seed_friendships_gamevisits.py` | 생성 |
| 컨테이너에서 스크립트 실행 | - | friendships 80건, game_visits 200건 삽입 완료 |

## 주요 변경 사항

### 1. backend/scripts/mock/seed_friendships_gamevisits.py 생성

**추가:**
```python
import sys, random
from datetime import datetime, timedelta

sys.path.insert(0, '/code')

from faker import Faker
from app.db.session import SessionLocal
from models import User, Friendship, GameVisit

fake = Faker('ko_KR')

def create_mock_friendships(db, count=80):
    users = db.query(User).all()
    user_ids = [u.id for u in users]
    existing_pairs = set()
    created = 0
    while created < count:
        a, b = random.sample(user_ids, 2)
        pair = (min(a, b), max(a, b))
        if pair in existing_pairs:
            continue
        existing_pairs.add(pair)
        friendship = Friendship(
            requester_id=a,
            receiver_id=b,
            status=random.choice(['pending', 'accepted', 'rejected']),
            created_at=datetime.utcnow() - timedelta(days=random.randint(0, 90))
        )
        db.add(friendship)
        created += 1
    db.commit()

def create_mock_game_visits(db, count=200):
    users = db.query(User).all()
    user_ids = [u.id for u in users]
    for _ in range(count):
        uid = None if random.random() < 0.3 else random.choice(user_ids)
        created = datetime.utcnow() - timedelta(days=random.randint(0, 60))
        visit = GameVisit(
            user_id=uid,
            ip_address=fake.ipv4(),
            is_visits=True,
            created_at=created,
            updated_at=created
        )
        db.add(visit)
    db.commit()
```

**특징:**
- `random.sample(user_ids, 2)`로 자기 자신과의 친구 요청(CHECK 제약 위반)을 원천 차단
- `(min, max)` 정규화로 (A→B), (B→A) 중복 쌍을 메모리에서 필터링해 UNIQUE 제약 위반 방지
- game_visits는 익명 방문(30%, user_id=None)과 로그인 방문(70%)을 혼합
- `is_visits=True` 고정으로 모든 방문을 실제 게임 플레이로 기록
- `created_at`과 `updated_at`을 명시적으로 동일 값 설정

### 스크립트 실행 흐름

```
docker compose exec fastapi python scripts/mock/seed_friendships_gamevisits.py
        │
        ▼
friendships 80건 생성
(users에서 2명 랜덤 샘플, UNIQUE 보장, status 랜덤)
        │
        ▼
game_visits 200건 생성
(익명 30% / 로그인 70%, ipv4 랜덤, is_visits=True)
        │
        ▼
완료!
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업

---

# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 15:20~16:00
- 작성자: hexsera

## 진행 목표
핀볼 게임에 모바일 터치 환경을 감지하고, 터치 디바이스에서만 흰색 반투명(20%) 원형 버튼 3개(좌 플리퍼, 플런저, 우 플리퍼)를 게임 하단에 표시하여 모바일에서도 핀볼을 조작할 수 있도록 한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| isTouchDevice state 추가 및 감지 로직 구현 | `frontend/src/pages/Pinball/Pinball.jsx` | `navigator.maxTouchPoints > 0` 기반 감지 |
| 플리퍼/플런저 제어 변수를 let → useRef로 승격 | `frontend/src/pages/Pinball/Pinball.jsx` | JSX에서 클로저 외부 접근 가능하도록 변환 |
| 플런저 충전/발사 함수를 ref로 노출 | `frontend/src/pages/Pinball/Pinball.jsx` | `plungerStartRef`, `plungerReleaseRef` 추가 |
| 캔버스 touchstart 등록 조건 분기 | `frontend/src/pages/Pinball/Pinball.jsx` | 터치 디바이스에서는 버튼 UI가 대체 |
| 모바일 조작 버튼 3개 JSX 추가 | `frontend/src/pages/Pinball/Pinball.jsx` | 게임 영역 하단 절대 위치 오버레이 |



## 주요 변경 사항

### 1. frontend/src/pages/Pinball/Pinball.jsx 수정

#### (1) isTouchDevice state 및 감지 useEffect 추가

**변경 전:**
```jsx
const [gameScale, setGameScale] = useState(1);
```

**변경 후:**
```jsx
const [gameScale, setGameScale] = useState(1);
const [isTouchDevice, setIsTouchDevice] = useState(false);

// 터치 디바이스 감지
useEffect(() => {
  setIsTouchDevice(navigator.maxTouchPoints > 0);
}, []);
```

**특징:**
- 화면 크기가 아닌 터치 포인트 지원 여부로 모바일 환경을 판단
- 마운트 시 1회만 실행

---

#### (2) 플리퍼/플런저 제어 변수를 useRef로 승격

**변경 전:**
```jsx
// useEffect 클로저 내부 let 변수
let isLeftKeyPressed = false;
let isRightKeyPressed = false;
let isSpacePressed = false;
let spaceHoldStartTime = 0;
```

**변경 후:**
```jsx
// 컴포넌트 최상단 ref 선언
const isLeftKeyPressedRef = useRef(false);
const isRightKeyPressedRef = useRef(false);
const isSpacePressedRef = useRef(false);
const spaceHoldStartTimeRef = useRef(0);

// useEffect 내부에서 별칭으로 사용
const isLeftKeyPressed = isLeftKeyPressedRef;
const isRightKeyPressed = isRightKeyPressedRef;
const isSpacePressed = isSpacePressedRef;
const spaceHoldStartTime = spaceHoldStartTimeRef;

// 값 읽기/쓰기는 .current로
isLeftKeyPressed.current = true;
if (isSpacePressed.current) { ... }
```

**특징:**
- `let` 변수는 useEffect 클로저 내부에 갇혀 JSX에서 접근 불가
- `useRef`로 선언하면 컴포넌트 전체에서 참조 가능
- 별칭 패턴으로 기존 내부 코드 변경 최소화

---

#### (3) 플런저 충전/발사 함수를 ref로 노출

**추가:**
```jsx
const plungerStartRef = useRef(null);
const plungerReleaseRef = useRef(null);

// useEffect 내부에서 함수 등록
plungerStartRef.current = () => {
  if (!isSpacePressed.current) {
    isSpacePressed.current = true;
    spaceHoldStartTime.current = Date.now();
  }
};

plungerReleaseRef.current = () => {
  if (isSpacePressed.current) {
    isSpacePressed.current = false;
    const holdDuration = Math.min(Date.now() - spaceHoldStartTime.current, 1500);
    const chargeRatio = Math.max(holdDuration / 1500, 0.1);
    const launchSpeed = PLUNGER_MAX_LAUNCH_SPEED * chargeRatio;
    const ballInLane = ball.position.x > 640 && ball.position.x < 685 &&
                       ball.position.y > 900 && ball.position.y < 1080;
    if (ballInLane) {
      Body.setVelocity(ball, { x: 0, y: -launchSpeed });
    }
    Body.setPosition(plunger, { x: PLUNGER_X, y: PLUNGER_REST_Y });
  }
};
```

**특징:**
- 기존 Space 키 로직과 동일한 충전/발사 로직을 JSX 버튼에서도 재사용 가능

---

#### (4) 캔버스 touchstart 등록 조건 분기

**변경 전:**
```jsx
if (sceneRef.current) {
  sceneRef.current.addEventListener('touchstart', handleTouchStart);
  sceneRef.current.addEventListener('touchend', handleTouchEnd);
}
```

**변경 후:**
```jsx
if (sceneRef.current && !(navigator.maxTouchPoints > 0)) {
  sceneRef.current.addEventListener('touchstart', handleTouchStart);
  sceneRef.current.addEventListener('touchend', handleTouchEnd);
}
```

**특징:**
- 터치 디바이스에서는 버튼 UI가 조작을 담당하므로 캔버스 전체 터치 이벤트와 충돌 방지
- 데스크탑에서는 기존 캔버스 터치 이벤트 유지

---

#### (5) 모바일 조작 버튼 3개 JSX 추가

**추가:**
```jsx
{isTouchDevice && (
  <Box sx={{
    position: 'absolute', bottom: '40px', left: 0,
    width: '100%', display: 'flex', justifyContent: 'space-between',
    alignItems: 'center', padding: '0 40px', zIndex: 20,
    pointerEvents: 'none', boxSizing: 'border-box',
  }}>
    {/* 왼쪽 플리퍼 버튼 */}
    <Box
      onPointerDown={() => { isLeftKeyPressedRef.current = true; playFlipperSound(fliperSoundRef.current); }}
      onPointerUp={() => { isLeftKeyPressedRef.current = false; }}
      onPointerLeave={() => { isLeftKeyPressedRef.current = false; }}
      sx={{ width: '100px', height: '100px', borderRadius: '50%',
            backgroundColor: 'rgba(255,255,255,0.2)', pointerEvents: 'auto',
            userSelect: 'none', touchAction: 'none' }}
    />
    {/* 플런저 버튼 */}
    <Box
      onPointerDown={() => { plungerStartRef.current && plungerStartRef.current(); }}
      onPointerUp={() => { plungerReleaseRef.current && plungerReleaseRef.current(); }}
      onPointerLeave={() => { plungerReleaseRef.current && plungerReleaseRef.current(); }}
      sx={{ width: '100px', height: '100px', borderRadius: '50%',
            backgroundColor: 'rgba(255,255,255,0.2)', pointerEvents: 'auto',
            userSelect: 'none', touchAction: 'none' }}
    />
    {/* 오른쪽 플리퍼 버튼 */}
    <Box
      onPointerDown={() => { isRightKeyPressedRef.current = true; playFlipperSound(fliperSoundRef.current); }}
      onPointerUp={() => { isRightKeyPressedRef.current = false; }}
      onPointerLeave={() => { isRightKeyPressedRef.current = false; }}
      sx={{ width: '100px', height: '100px', borderRadius: '50%',
            backgroundColor: 'rgba(255,255,255,0.2)', pointerEvents: 'auto',
            userSelect: 'none', touchAction: 'none' }}
    />
  </Box>
)}
```

**특징:**
- 부모 Box에 `pointerEvents: none`, 각 버튼에만 `pointerEvents: auto`로 버튼 외 영역의 게임 캔버스 터치를 막지 않음
- `onPointerLeave`로 손가락이 버튼 밖으로 벗어나도 플리퍼 자동 해제
- `touchAction: none`으로 버튼 위에서 브라우저 기본 스크롤 동작 차단

---

### 전체 데이터 흐름

```
터치 디바이스 접속
        │
        ▼
navigator.maxTouchPoints > 0 → true
        │
        ▼
isTouchDevice = true
        │
        ├── 캔버스 touchstart 이벤트 미등록
        │
        └── 버튼 3개 렌더링 (게임 영역 하단)
                │
                ├── 좌 버튼 PointerDown → isLeftKeyPressedRef.current = true
                ├── 가운데 버튼 PointerDown → plungerStartRef.current()
                └── 우 버튼 PointerDown → isRightKeyPressedRef.current = true
                        │
                        ▼
                Matter.js beforeUpdate 이벤트에서 ref.current 값 읽어 플리퍼/플런저 제어
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
