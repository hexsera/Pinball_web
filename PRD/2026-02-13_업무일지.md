# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 10:30~11:00
- 작성자: hexsera

## 진행 목표
`game_visits.user_id`에 `users.id`를 참조하는 FK 제약을 추가하고, User 삭제 시 `game_visits` 레코드를 삭제하지 않고 `user_id`를 NULL로 변환하여 방문 기록을 보존한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| GameVisit 모델에 FK 추가 | `backend/models.py` | `ForeignKey('users.id')` 추가 |
| Alembic 마이그레이션 생성 및 적용 | `backend/alembic/versions/7c93967e31b7_...py` | 고아 데이터 정리 후 FK 제약 적용 |
| User 삭제 로직에 NULL 처리 추가 | `backend/app/api/v1/users.py` | GameVisit import 추가 및 NULL 업데이트 쿼리 추가 |


## 주요 변경 사항

### 1. backend/models.py 수정

**변경 전:**
```python
class GameVisit(Base):
    __tablename__ = "game_visits"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=True, index=True)
```

**변경 후:**
```python
class GameVisit(Base):
    __tablename__ = "game_visits"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=True, index=True)
```

**특징:**
- `ForeignKey('users.id')` 추가로 ORM 레벨에서 `game_visits.user_id → users.id` 참조 관계 선언
- `nullable=True` 유지 — 익명 방문자(비로그인)는 user_id가 NULL로 저장되므로 제거 불가

---

### 2. backend/alembic/versions/7c93967e31b7_add_foreign_key_to_game_visits_user_id.py 생성

**추가:**
```python
def upgrade() -> None:
    # users 테이블에 존재하지 않는 고아 user_id를 NULL로 정리
    op.execute(
        "UPDATE game_visits SET user_id = NULL "
        "WHERE user_id IS NOT NULL "
        "AND user_id NOT IN (SELECT id FROM users)"
    )
    op.create_foreign_key(None, 'game_visits', 'users', ['user_id'], ['id'])

def downgrade() -> None:
    op.drop_constraint(None, 'game_visits', type_='foreignkey')
```

**특징:**
- FK 제약 추가 전 고아 데이터(users에 없는 user_id=3) 를 NULL로 정리하는 SQL을 먼저 실행
- 고아 데이터가 존재할 경우 `op.create_foreign_key()` 단독 실행 시 FK 위반 오류가 발생하므로 사전 정리 필수
- `down_revision = '0ceb423c2879'` 으로 기존 마이그레이션 체인에 연결

---

### 3. backend/app/api/v1/users.py 수정

**변경 전:**
```python
from models import User, MonthlyScore, Friendship, HighScore

# FK 참조 테이블 데이터 먼저 삭제
db.query(Friendship).filter(
    (Friendship.requester_id == user_id) | (Friendship.receiver_id == user_id)
).delete(synchronize_session=False)
```

**변경 후:**
```python
from models import User, MonthlyScore, Friendship, HighScore, GameVisit

# FK 참조 테이블 데이터 먼저 삭제
# GameVisit의 user_id를 NULL로 설정 (방문 기록 보존, FK 위반 방지)
db.query(GameVisit).filter(GameVisit.user_id == user_id)\
    .update({"user_id": None}, synchronize_session=False)

db.query(Friendship).filter(
    (Friendship.requester_id == user_id) | (Friendship.receiver_id == user_id)
).delete(synchronize_session=False)
```

**특징:**
- FK 제약 추가 후 User 삭제 시 발생하는 FK 위반 오류를 방지
- 레코드를 삭제하지 않고 `user_id`만 NULL로 변환하여 방문 통계 데이터 보존
- User 삭제(`db.delete(user)`) 이전에 실행하여 FK 제약 위반 방지

---

### 데이터 흐름 변경

**User 삭제 순서 (변경 후):**
```
DELETE /api/v1/users/{user_id}
        │
        ▼
GameVisit.user_id → NULL  (방문 기록 보존)
        │
        ▼
Friendship 삭제  (requester_id / receiver_id)
        │
        ▼
MonthlyScore 삭제
        │
        ▼
HighScore 삭제
        │
        ▼
User 삭제
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
- gamevits post 할 때 user_id PK 없으면 오류 메시지 뜨도록 해야함

# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 11:40~12:20
- 작성자: hexsera

## 진행 목표
데이터베이스의 모든 테이블과 데이터를 완전히 제거한 후 재생성한다. Alembic 마이그레이션 이력도 단일 초기 revision으로 초기화한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| DB constraints 사전 조회 | - | 초기화 전 기준값 기록 |
| 모든 테이블 DROP | - | CASCADE로 6개 테이블 + alembic_version 제거 |
| 기존 마이그레이션 파일 삭제 | `backend/alembic/versions/*.py` | 6개 파일 + __pycache__ 삭제 |
| 새 초기 마이그레이션 파일 생성 | `backend/alembic/versions/60a77f2baf38_initial_schema.py` | autogenerate로 생성 |
| FastAPI 재기동으로 테이블 재생성 | - | 부트스트래핑으로 6개 테이블 자동 생성 |
| alembic stamp head | - | 현재 DB 상태를 HEAD로 등록 |
| constraints 재확인 | - | 초기화 전 기준값과 동일함 확인 |

## 주요 변경 사항

### 1. backend/alembic/versions/ 수정

**변경 전 (6개 파일):**
```
eccd28617903_initial_postgresql_migration.py
6fe36d8bc6a2_add_user_id_column_to_users_table.py
f38f15d3477d_add_foreign_key_constraints_to_.py
45f71363a042_add_foreign_key_to_high_scores_user_id.py
0ceb423c2879_add_foreign_key_to_monthly_scores_user_.py
7c93967e31b7_add_foreign_key_to_game_visits_user_id.py
```

**변경 후 (1개 파일):**
```
60a77f2baf38_initial_schema.py  (upgrade: pass, alembic stamp head로 등록)
```

**특징:**
- 기존 6단계 마이그레이션 체인을 단일 revision으로 통합
- 테이블 생성은 마이그레이션이 아닌 FastAPI 부트스트래핑이 담당
- `alembic stamp head`로 현재 DB 상태를 alembic_version에 등록

---

### 데이터베이스 초기화 흐름

```
DROP TABLE 6개 + alembic_version (CASCADE)
        │
        ▼
versions/*.py 삭제 (마이그레이션 이력 초기화)
        │
        ▼
alembic revision --autogenerate (빈 upgrade 파일 생성)
        │
        ▼
docker compose restart fastapi (부트스트래핑으로 테이블 재생성)
        │
        ▼
alembic stamp head (현재 상태를 HEAD로 등록)
```

---

### constraints 비교 (초기화 전 → 후)

```
friendships_requester_id_fkey  (FK)  : 유지
friendships_receiver_id_fkey   (FK)  : 유지
uq_friendship_pair             (UNIQUE + CHECK): 유지
game_visits_user_id_fkey       (FK)  : 유지
high_scores_user_id_fkey       (FK)  : 유지
monthly_scores_user_id_fkey    (FK)  : 유지
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업

---

# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 12:20:13:00
- 작성자: hexsera

## 진행 목표
`users` 테이블과 `monthly_scores` 테이블에 mock 데이터를 삽입하여 실제 서비스 환경과 유사한 데이터 상태를 구성한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| Faker 의존성 추가 | `backend/requirements.txt` | `Faker==24.0.0` 추가 |
| mock 디렉토리 구조 생성 | `backend/scripts/__init__.py`, `backend/scripts/mock/__init__.py` | 업계 표준 scripts/mock/ 구조 |
| mock 데이터 스크립트 작성 | `backend/scripts/mock/seed_mock_data.py` | User 50명 + MonthlyScore 50개 생성 |
| Docker 컨테이너 재빌드 및 실행 | - | Faker 설치 반영 후 스크립트 실행 |
| 한글 닉네임으로 수정 | `backend/scripts/mock/seed_mock_data.py` | `user_name()` → `last_name()+first_name()` 조합으로 변경 |

## 주요 변경 사항

### 1. backend/requirements.txt 수정

**변경 전:**
```text
httpx==0.27.0
```

**변경 후:**
```text
httpx==0.27.0
Faker==24.0.0
```

**특징:**
- Faker: 이름, 이메일, 날짜 등 현실적인 가짜 데이터를 생성하는 Python 표준 라이브러리

---

### 2. backend/scripts/mock/seed_mock_data.py 생성

**추가:**
```python
import sys, os, random
from datetime import datetime, timedelta

sys.path.insert(0, '/code')

from faker import Faker
from app.db.session import SessionLocal
from models import User, MonthlyScore

fake = Faker('ko_KR')

def _unique_korean_nickname(used: set) -> str:
    for _ in range(100):
        nickname = fake.last_name() + fake.first_name()
        if nickname not in used:
            used.add(nickname)
            return nickname
    raise ValueError("중복되지 않는 닉네임 생성 실패")

def create_mock_users(db, count=50):
    used_nicknames = set()
    for _ in range(count):
        user = User(
            email=fake.unique.email(),
            nickname=_unique_korean_nickname(used_nicknames),
            password="password123!",
            birth_date=fake.date_of_birth(minimum_age=15, maximum_age=60),
            role='user'
        )
        db.add(user)
    db.commit()
    db.expire_all()
    return db.query(User).filter(User.role == 'user').order_by(User.id.desc()).limit(count).all()

def create_mock_monthly_scores(db, users):
    for user in users:
        score = MonthlyScore(
            user_id=user.id,
            nickname=user.nickname,
            score=random.randint(1000, 59999),
            created_at=datetime.utcnow() - timedelta(days=random.randint(0, 30))
        )
        db.add(score)
    db.commit()
```

**특징:**
- `password="password123!"`: mock 데이터 전용, 평문 저장
- `user_id`당 MonthlyScore 1개만 삽입 (API의 upsert 설계 원칙 준수)
- `score`: 1,000~59,999 범위, `created_at`: 최근 30일 이내 랜덤
- `nickname`: `fake.last_name() + fake.first_name()` 조합으로 한글 닉네임 생성 (`user_name()`은 로케일 무관 영문 반환)
- `_unique_korean_nickname()`: 세션 내 중복 방지를 위한 set 기반 중복 검사

---

### 스크립트 실행 흐름

```
docker compose build fastapi  (Faker 패키지 설치)
        │
        ▼
docker compose up -d fastapi
        │
        ▼
docker compose exec fastapi python scripts/mock/seed_mock_data.py
        │
        ▼
users 50명 생성 (한글 닉네임, 평문 비밀번호)
        │
        ▼
monthly_scores 50개 생성 (user_id당 1개)
```

---

### 트러블슈팅

| 문제 | 원인 | 해결 |
|------|------|------|
| `ModuleNotFoundError: No module named 'app'` | 컨테이너 WORKDIR가 `/app`이 아닌 `/code` | `sys.path.insert(0, '/code')`로 수정 |
| 닉네임이 영문으로 생성됨 | `fake.user_name()`은 로케일 무관 영문 반환 | `fake.last_name() + fake.first_name()` 조합으로 변경 |

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
- 이메일 중복 제약사항 생성 고민

