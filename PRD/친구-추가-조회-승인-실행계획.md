# 친구 추가 조회 승인 API 실행 계획

## 개요

친구 요청을 조회하고 승인/거절할 수 있는 API 엔드포인트를 구현합니다. 임시 메모리(배열)를 사용하여 친구 요청을 저장하며, DB 테이블은 생성하지 않습니다.

## 구현 범위

- **포함**: 친구 요청 조회, 친구 요청 승인/거절
- **제외**: 보안, 검증 로직, 데이터베이스 테이블

## 기술 스택

- **백엔드**: FastAPI
- **저장소**: 임시 메모리 (Python 리스트)
- **응답 형식**: JSON

## 데이터 구조

### 친구 요청 (FriendRequest)

```python
{
    "id": int,              # 요청자(친구 추가하는 사람) ID
    "requester_id": int,    # 피요청자(친구 요청받는 사람) ID
    "status": str           # "pending" | "accepted" | "rejected"
}
```

### 메모리 저장소

```python
# main.py 또는 별도 파일
friend_requests = []  # 전역 배열 (임시 메모리)
```

## API 엔드포인트 설계

### 1. 친구 요청 조회 (GET /api/friend-requests)

**요청**:
```http
GET /api/friend-requests?user_id={user_id}
```

**쿼리 파라미터**:
- `user_id` (필수): 조회할 사용자 ID (친구 요청을 받은 사람)

**응답** (200 OK):
```json
{
    "requests": [
        {
            "id": 1,
            "requester_id": 2,
            "status": "pending"
        },
        {
            "id": 3,
            "requester_id": 2,
            "status": "pending"
        }
    ]
}
```

**설명**:
- `requester_id`가 `user_id`와 일치하는 모든 친구 요청 반환
- `status`가 "pending"인 것만 필터링 가능 (선택 사항)

### 2. 친구 요청 승인 (POST /api/friend-requests/accept)

**요청**:
```http
POST /api/friend-requests/accept
Content-Type: application/json
```

```json
{
    "id": 1,
    "requester_id": 2
}
```

**요청 바디**:
- `id` (필수): 요청자 ID
- `requester_id` (필수): 피요청자 ID

**응답** (200 OK):
```json
{
    "message": "Friend request accepted",
    "id": 1,
    "requester_id": 2,
    "status": "accepted"
}
```

**응답** (404 Not Found):
```json
{
    "detail": "Friend request not found"
}
```

**설명**:
- `friend_requests` 배열에서 해당 요청을 찾아 `status`를 "accepted"로 변경
- 요청이 없으면 404 반환

### 3. 친구 요청 거절 (POST /api/friend-requests/reject)

**요청**:
```http
POST /api/friend-requests/reject
Content-Type: application/json
```

```json
{
    "id": 1,
    "requester_id": 2
}
```

**요청 바디**:
- `id` (필수): 요청자 ID
- `requester_id` (필수): 피요청자 ID

**응답** (200 OK):
```json
{
    "message": "Friend request rejected",
    "id": 1,
    "requester_id": 2,
    "status": "rejected"
}
```

**응답** (404 Not Found):
```json
{
    "detail": "Friend request not found"
}
```

**설명**:
- `friend_requests` 배열에서 해당 요청을 찾아 `status`를 "rejected"로 변경
- 요청이 없으면 404 반환

## Pydantic 스키마 설계

### FriendRequestBase

```python
class FriendRequestBase(BaseModel):
    id: int
    requester_id: int
```

### FriendRequestResponse

```python
class FriendRequestResponse(FriendRequestBase):
    status: str

    class Config:
        from_attributes = True
```

### FriendRequestListResponse

```python
class FriendRequestListResponse(BaseModel):
    requests: List[FriendRequestResponse]
```

### FriendRequestActionRequest

```python
class FriendRequestActionRequest(BaseModel):
    id: int
    requester_id: int
```

### FriendRequestActionResponse

```python
class FriendRequestActionResponse(BaseModel):
    message: str
    id: int
    requester_id: int
    status: str
```

## 구현 단계

### 단계 1: Pydantic 스키마 추가

**파일**: `fastapi/main.py` (또는 `fastapi/schemas.py`)

- FriendRequestBase
- FriendRequestResponse
- FriendRequestListResponse
- FriendRequestActionRequest
- FriendRequestActionResponse

### 단계 2: 메모리 저장소 초기화

**파일**: `fastapi/main.py`

```python
# 전역 변수 (임시 메모리)
friend_requests: List[dict] = []
```

### 단계 3: GET /api/friend-requests 엔드포인트 구현

**파일**: `fastapi/main.py`

```python
@app.get("/api/friend-requests", response_model=FriendRequestListResponse)
def get_friend_requests(user_id: int):
    """특정 사용자가 받은 친구 요청 조회"""
    # requester_id가 user_id와 일치하는 요청 필터링
    user_requests = [
        req for req in friend_requests
        if req["requester_id"] == user_id
    ]

    return FriendRequestListResponse(requests=user_requests)
```

### 단계 4: POST /api/friend-requests/accept 엔드포인트 구현

**파일**: `fastapi/main.py`

```python
@app.post("/api/friend-requests/accept", response_model=FriendRequestActionResponse)
def accept_friend_request(action: FriendRequestActionRequest):
    """친구 요청 승인"""
    # 해당 요청 찾기
    for req in friend_requests:
        if req["id"] == action.id and req["requester_id"] == action.requester_id:
            req["status"] = "accepted"
            return FriendRequestActionResponse(
                message="Friend request accepted",
                id=req["id"],
                requester_id=req["requester_id"],
                status=req["status"]
            )

    # 요청을 찾지 못한 경우
    raise HTTPException(status_code=404, detail="Friend request not found")
```

### 단계 5: POST /api/friend-requests/reject 엔드포인트 구현

**파일**: `fastapi/main.py`

```python
@app.post("/api/friend-requests/reject", response_model=FriendRequestActionResponse)
def reject_friend_request(action: FriendRequestActionRequest):
    """친구 요청 거절"""
    # 해당 요청 찾기
    for req in friend_requests:
        if req["id"] == action.id and req["requester_id"] == action.requester_id:
            req["status"] = "rejected"
            return FriendRequestActionResponse(
                message="Friend request rejected",
                id=req["id"],
                requester_id=req["requester_id"],
                status=req["status"]
            )

    # 요청을 찾지 못한 경우
    raise HTTPException(status_code=404, detail="Friend request not found")
```

### 단계 6: 테스트 데이터 추가 (선택 사항)

**파일**: `fastapi/main.py`

```python
# 앱 시작 시 테스트 데이터 추가
@app.on_event("startup")
def add_test_data():
    """테스트용 친구 요청 데이터 추가"""
    friend_requests.extend([
        {"id": 1, "requester_id": 2, "status": "pending"},
        {"id": 3, "requester_id": 2, "status": "pending"},
        {"id": 5, "requester_id": 4, "status": "pending"},
    ])
    print(f"Test friend requests added: {len(friend_requests)} requests")
```

## 테스트 시나리오

### 1. 친구 요청 조회 테스트

```bash
# user_id=2가 받은 친구 요청 조회
curl -X GET "http://localhost:8000/api/friend-requests?user_id=2"
```

**예상 응답**:
```json
{
    "requests": [
        {"id": 1, "requester_id": 2, "status": "pending"},
        {"id": 3, "requester_id": 2, "status": "pending"}
    ]
}
```

### 2. 친구 요청 승인 테스트

```bash
curl -X POST "http://localhost:8000/api/friend-requests/accept" \
  -H "Content-Type: application/json" \
  -d '{"id": 1, "requester_id": 2}'
```

**예상 응답**:
```json
{
    "message": "Friend request accepted",
    "id": 1,
    "requester_id": 2,
    "status": "accepted"
}
```

### 3. 친구 요청 거절 테스트

```bash
curl -X POST "http://localhost:8000/api/friend-requests/reject" \
  -H "Content-Type: application/json" \
  -d '{"id": 3, "requester_id": 2}'
```

**예상 응답**:
```json
{
    "message": "Friend request rejected",
    "id": 3,
    "requester_id": 2,
    "status": "rejected"
}
```

### 4. 존재하지 않는 요청 처리 테스트

```bash
curl -X POST "http://localhost:8000/api/friend-requests/accept" \
  -H "Content-Type: application/json" \
  -d '{"id": 999, "requester_id": 999}'
```

**예상 응답** (404):
```json
{
    "detail": "Friend request not found"
}
```

## 파일 구조

```
fastapi/
├── main.py                      # 엔드포인트 구현, 메모리 저장소
└── (선택) schemas.py            # Pydantic 스키마 분리
```

## 주의사항

### 1. 메모리 저장소의 한계
- **서버 재시작 시 데이터 손실**: 모든 친구 요청 데이터가 사라짐
- **동시성 문제**: 멀티 프로세스 환경에서 데이터 불일치 가능
- **확장성 제한**: 대량의 데이터 처리 어려움

### 2. 보안 미고려
- **인증 없음**: 누구나 모든 친구 요청 조회 가능
- **권한 검증 없음**: 다른 사용자의 요청도 승인/거절 가능
- **프로덕션에서는 JWT 토큰 기반 인증 필수**

### 3. 검증 로직 미구현
- **중복 요청 방지 없음**: 같은 요청을 여러 번 생성 가능
- **순환 요청 방지 없음**: A→B, B→A 동시 요청 가능
- **자기 자신에게 요청 방지 없음**: id == requester_id 가능

### 4. 데이터 정합성
- **상태 전이 검증 없음**: pending → accepted/rejected 외 다른 전이도 가능
- **중복 승인/거절 방지 없음**: 이미 처리된 요청 재처리 가능

## 향후 개선 사항

### 1. 데이터베이스 테이블 생성 (프로덕션)

```sql
CREATE TABLE friend_requests (
    id INT PRIMARY KEY,
    requester_id INT NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (id) REFERENCES users(id),
    FOREIGN KEY (requester_id) REFERENCES users(id),
    UNIQUE KEY unique_request (id, requester_id)
);
```

### 2. 인증 및 권한 검증

```python
@app.get("/api/friend-requests")
def get_friend_requests(
    user_id: int,
    current_user: User = Depends(get_current_user)  # JWT 토큰 검증
):
    # 본인의 요청만 조회 가능
    if current_user.id != user_id:
        raise HTTPException(status_code=403, detail="Forbidden")
    # ...
```

### 3. 검증 로직 추가

```python
# 중복 요청 방지
existing = db.query(FriendRequest).filter(
    FriendRequest.id == id,
    FriendRequest.requester_id == requester_id
).first()
if existing:
    raise HTTPException(status_code=400, detail="Friend request already exists")

# 자기 자신에게 요청 방지
if id == requester_id:
    raise HTTPException(status_code=400, detail="Cannot send friend request to yourself")
```

### 4. 페이지네이션

```python
@app.get("/api/friend-requests")
def get_friend_requests(
    user_id: int,
    skip: int = 0,
    limit: int = 10
):
    requests = friend_requests[skip : skip + limit]
    # ...
```

## 체크리스트

- [o] Pydantic 스키마 정의 (FriendRequestBase, FriendRequestResponse 등)
- [o] GET /api/friend-requests 엔드포인트 구현
- [o] POST /api/friend-requests/accept 엔드포인트 구현
- [o] POST /api/friend-requests/reject 엔드포인트 구현



## 완료 조건

1. ✅ 친구 요청 조회 API가 정상 작동 (GET /api/friend-requests)
2. ✅ 친구 요청 승인 API가 정상 작동 (POST /api/friend-requests/accept)
3. ✅ 친구 요청 거절 API가 정상 작동 (POST /api/friend-requests/reject)
4. ✅ 존재하지 않는 요청 처리 시 404 반환
5. ✅ Swagger UI에서 모든 엔드포인트 문서 확인 가능

## 참고 문서

- FastAPI 공식 문서: https://fastapi.tiangolo.com/
- Pydantic 공식 문서: https://docs.pydantic.dev/
- 기존 User CRUD API: `/home/hexsera/Pinball_web/PRD/user-crud-mysql.md`
- 기존 친구 요청 API: POST /api/friend-requests (이미 구현됨)
