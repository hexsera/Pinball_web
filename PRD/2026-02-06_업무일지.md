# 업무일지

## 기본 정보
- 날짜: 2026-02-06 (목요일) p1(10:30~11:00 11:30~12:00) p2(12:20~12:35) p3(12:35~1:20)
- 작성자: hexsera

## 진행 목표
핀볼 게임에 2단계 스테이지 시스템을 도입한다. 스테이지별로 장애물/범퍼/목표물 배치가 다른 맵 구성을 가지며, 'n' 키로 스테이지 전환을 테스트할 수 있도록 구현한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| PHASE 1: 스테이지 데이터 분리 및 상태 관리 | `frontend/src/stageConfigs.js` (생성) | 스테이지 설정 데이터 정의 |
| PHASE 1: STAGE_CONFIGS import | `frontend/src/Pinball.jsx` | import 문 추가 |
| PHASE 1: 스테이지 상태 추가 | `frontend/src/Pinball.jsx` | stage, stageRef, stageBodiesRef 추가 |
| PHASE 2: 맵 로딩 함수 구현 | `frontend/src/Pinball.jsx` | loadStageMap() 함수 생성 |
| PHASE 2: 하드코딩 장애물 제거 | `frontend/src/Pinball.jsx` | obstacle1, obstacle2, bumper, target 제거 |
| PHASE 2: 초기 맵 로딩 | `frontend/src/Pinball.jsx` | loadStageMap(1) 호출 추가 |
| PHASE 3: 'n' 키 스테이지 전환 | `frontend/src/Pinball.jsx` | handleKeyDown에 'n' 키 처리 추가 |

## 주요 변경 사항

### 1. stageConfigs.js 생성

**추가:**
```javascript
// 스테이지 설정 데이터 정의
export const STAGE_CONFIGS = {
  1: {
    name: 'Stage 1',
    targetScore: 1000,
    obstacles: [
      { type: 'circle', x: 300, y: 300, radius: 30, options: { isStatic: true, render: { fillStyle: '#0f3460' } } },
      { type: 'circle', x: 500, y: 300, radius: 30, options: { isStatic: true, render: { fillStyle: '#0f3460' } } }
    ],
    bumpers: [
      { x: 400, y: 600, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e74c3c' } } }
    ],
    targets: [
      { x: 500, y: 590, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#87CEEB' } } }
    ]
  },
  2: {
    name: 'Stage 2',
    targetScore: null,
    obstacles: [
      { type: 'circle', x: 200, y: 250, radius: 25, options: { isStatic: true, render: { fillStyle: '#8e44ad' } } },
      { type: 'circle', x: 400, y: 200, radius: 25, options: { isStatic: true, render: { fillStyle: '#8e44ad' } } },
      { type: 'circle', x: 500, y: 400, radius: 25, options: { isStatic: true, render: { fillStyle: '#8e44ad' } } }
    ],
    bumpers: [
      { x: 300, y: 500, radius: 35, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e74c3c' } } },
      { x: 500, y: 700, radius: 35, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e74c3c' } } }
    ],
    targets: [
      { x: 350, y: 350, radius: 35, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#87CEEB' } } },
      { x: 200, y: 600, radius: 35, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#87CEEB' } } }
    ]
  }
};
```

**특징:**
- 관심사 분리: 게임 데이터를 별도 파일로 분리
- 스테이지 1: 장애물 2개, 범퍼 1개, 목표물 1개
- 스테이지 2: 장애물 3개, 범퍼 2개, 목표물 2개 (스테이지 1보다 복잡)
- 확장성: 향후 스테이지 3, 4 추가 시 이 파일만 수정하면 됨

### 2. Pinball.jsx - import 추가

**변경 전:**
```javascript
import { useEffect, useRef, useState, useCallback } from 'react';
import Matter from 'matter-js';
import axios from 'axios';
import { Button, Box, Typography } from '@mui/material';
import { useAuth } from './AuthContext';
```

**변경 후:**
```javascript
import { useEffect, useRef, useState, useCallback } from 'react';
import Matter from 'matter-js';
import axios from 'axios';
import { Button, Box, Typography } from '@mui/material';
import { useAuth } from './AuthContext';
import { STAGE_CONFIGS } from './stageConfigs';
```

**특징:**
- stageConfigs.js에서 STAGE_CONFIGS를 import
- 스테이지 설정 데이터를 컴포넌트에서 사용 가능

### 3. Pinball.jsx - 스테이지 상태 추가

**변경 전:**
```javascript
const sceneRef = useRef(null);
const bgmRef = useRef(null);
const hitSoundRef = useRef(null);
const ballRef = useRef(null);
const livesRef = useRef(2);
const scoreRef = useRef(0);
const [isPlaying, setIsPlaying] = useState(false);
const [score, setScore] = useState(0);
const [lives, setLives] = useState(3);
const [overlayState, setOverlayState] = useState(null);
const [bestScore, setBestScore] = useState(null);
```

**변경 후:**
```javascript
const sceneRef = useRef(null);
const bgmRef = useRef(null);
const hitSoundRef = useRef(null);
const ballRef = useRef(null);
const livesRef = useRef(2);
const scoreRef = useRef(0);
const stageRef = useRef(1);
const stageBodiesRef = useRef([]);
const [isPlaying, setIsPlaying] = useState(false);
const [score, setScore] = useState(0);
const [lives, setLives] = useState(3);
const [stage, setStage] = useState(1);
const [overlayState, setOverlayState] = useState(null);
const [bestScore, setBestScore] = useState(null);
```

**특징:**
- `stageRef`: 현재 스테이지 번호 (이벤트 콜백 내부에서 참조)
- `stageBodiesRef`: 현재 스테이지의 동적 Bodies 저장 (스테이지 전환 시 제거용)
- `stage`: 현재 스테이지 번호 (UI 표시용)

### 4. Pinball.jsx - loadStageMap() 함수 추가

**추가:**
```javascript
// 맵 로딩 함수
const loadStageMap = (stageNumber) => {
  // 기존 스테이지 Bodies 제거
  if (stageBodiesRef.current.length > 0) {
    World.remove(engine.world, stageBodiesRef.current);
    stageBodiesRef.current = [];
  }

  const config = STAGE_CONFIGS[stageNumber];
  const newBodies = [];

  // 장애물 생성
  config.obstacles.forEach((obs) => {
    const body = Bodies.circle(obs.x, obs.y, obs.radius, obs.options);
    newBodies.push(body);
  });

  // 범퍼 생성
  config.bumpers.forEach((b) => {
    const body = Bodies.circle(b.x, b.y, b.radius, b.options);
    newBodies.push(body);
  });

  // 목표물 생성
  config.targets.forEach((t) => {
    const body = Bodies.circle(t.x, t.y, t.radius, t.options);
    newBodies.push(body);
  });

  // World에 추가
  World.add(engine.world, newBodies);
  stageBodiesRef.current = newBodies;
};
```

**특징:**
- 기존 스테이지 Bodies를 `World.remove()`로 제거
- `STAGE_CONFIGS`에서 스테이지 설정을 읽어 Bodies 생성
- 생성된 Bodies를 `stageBodiesRef.current`에 저장하여 다음 스테이지 전환 시 제거 가능

### 5. Pinball.jsx - 하드코딩된 장애물 제거

**변경 전:**
```javascript
ballRef.current = ball;

// 장애물 만들기
const obstacle1 = Bodies.circle(300, 300, 30, {
  isStatic: true,
  render: { fillStyle: '#0f3460' }
});

const obstacle2 = Bodies.circle(500, 300, 30, {
  isStatic: true,
  render: { fillStyle: '#0f3460' }
});

// 범퍼 만들기 (충돌 시 강하게 튕겨냄)
const bumper = Bodies.circle(400, 600, 40, {
  isStatic: true,
  restitution: 1.5,
  label: 'bumper',
  render: { fillStyle: '#e74c3c' }
});

// 목표 오브젝트 만들기 (충돌 시 강하게 튕겨냄)
const target = Bodies.circle(500, 500, 40, {
  isStatic: true,
  restitution: 1.5,
  label: 'target',
  render: { fillStyle: '#87CEEB' }
});

// 왼쪽 플리퍼 (회전축 x=270, 중심 = 회전축 + 길이절반50 = x=320)
```

**변경 후:**
```javascript
ballRef.current = ball;

// 왼쪽 플리퍼 (회전축 x=270, 중심 = 회전축 + 길이절반50 = x=320)
```

**특징:**
- `obstacle1`, `obstacle2`, `bumper`, `target` 변수 선언 및 생성 코드 제거
- 이제 `loadStageMap()` 함수가 동적으로 생성

### 6. Pinball.jsx - World.add() 수정 및 초기 맵 로딩

**변경 전:**
```javascript
World.add(engine.world, [
  leftWall,
  rightWall,
  rightWall2,
  upWall,
  leftFunnelWall,
  rightFunnelWall,
  deathZone,
  ball,
  obstacle1,
  obstacle2,
  bumper,
  target,
  leftFlipper,
  rightFlipper,
  leftFlipperConstraint,
  rightFlipperConstraint
]);
```

**변경 후:**
```javascript
World.add(engine.world, [
  leftWall,
  rightWall,
  rightWall2,
  upWall,
  leftFunnelWall,
  rightFunnelWall,
  deathZone,
  ball,
  leftFlipper,
  rightFlipper,
  leftFlipperConstraint,
  rightFlipperConstraint
]);

// 스테이지 1 맵 로딩
loadStageMap(1);
```

**특징:**
- `obstacle1`, `obstacle2`, `bumper`, `target`을 `World.add()` 배열에서 제거
- 벽, 깔대기, 죽음구역, 공, 플리퍼는 모든 스테이지 공통이므로 유지
- `loadStageMap(1)` 호출로 스테이지 1 맵 동적 로딩

### 7. Pinball.jsx - 'n' 키 스테이지 전환 추가

**변경 전:**
```javascript
const handleKeyDown = (event) => {
  if (event.key === 'ArrowLeft') {
    console.log('왼쪽 방향키 눌림');
    isLeftKeyPressed = true;
  }
  if (event.key === 'ArrowRight') {
    console.log('오른쪽 방향키 눌림');
    isRightKeyPressed = true;
  }
};
```

**변경 후:**
```javascript
const handleKeyDown = (event) => {
  if (event.key === 'ArrowLeft') {
    console.log('왼쪽 방향키 눌림');
    isLeftKeyPressed = true;
  }
  if (event.key === 'ArrowRight') {
    console.log('오른쪽 방향키 눌림');
    isRightKeyPressed = true;
  }
  // 'n' 키로 스테이지 전환 (테스트용)
  if (event.key === 'n' || event.key === 'N') {
    const currentStage = stageRef.current;
    const nextStage = currentStage + 1;
    if (STAGE_CONFIGS[nextStage]) {
      console.log(`Stage ${currentStage} → Stage ${nextStage} (테스트)`);

      // 스테이지 전환
      stageRef.current = nextStage;
      setStage(nextStage);

      // 생명 초기화
      livesRef.current = 2;  // lives 상태는 +1이므로 ref는 2
      setLives(3);

      // 공 초기 위치로 이동
      Body.setPosition(ball, { x: 250, y: 400 });
      Body.setVelocity(ball, { x: 0, y: 0 });
      Body.setAngularVelocity(ball, 0);

      // 맵 전환
      loadStageMap(nextStage);
    } else {
      console.log('마지막 스테이지입니다');
    }
  }
};
```

**특징:**
- 'n' 또는 'N' 키로 다음 스테이지로 강제 전환
- 스테이지 전환 시 생명 3개로 초기화
- 공의 위치, 속도, 각속도를 초기화
- `loadStageMap(nextStage)`로 새 맵 로딩
- 마지막 스테이지에서는 콘솔 메시지만 출력

## 아키텍처 구조

### 스테이지 시스템 데이터 흐름

```
┌───────────────────────────────────────┐
│      stageConfigs.js                  │
│  STAGE_CONFIGS = {                    │
│    1: { obstacles, bumpers, targets } │
│    2: { obstacles, bumpers, targets } │
│  }                                    │
└─────────────┬─────────────────────────┘
              │ export
              ▼
┌───────────────────────────────────────┐
│      Pinball.jsx                      │
│  - stageRef (현재 스테이지 번호)      │
│  - stageBodiesRef (동적 Bodies)      │
└─────────────┬─────────────────────────┘
              │
              ▼
      ┌───────────────┐
      │ loadStageMap()│
      └───────┬───────┘
              │
    ┌─────────┴─────────┐
    │                   │
    ▼                   ▼
World.remove()      STAGE_CONFIGS[n]
(기존 Bodies)       (새 스테이지 설정)
    │                   │
    └─────────┬─────────┘
              ▼
        Bodies 생성
    (obstacles, bumpers, targets)
              │
              ▼
        World.add()
    (Matter.js World에 추가)
              │
              ▼
     stageBodiesRef.current
        (참조 저장)
```

### 스테이지 전환 흐름

```
사용자 'n' 키 입력
        │
        ▼
  handleKeyDown()
        │
        ├─ stageRef.current++
        ├─ setStage()
        ├─ livesRef.current = 2
        ├─ setLives(3)
        ├─ Ball 위치/속도 초기화
        │
        ▼
  loadStageMap(nextStage)
        │
        ├─ World.remove(이전 Bodies)
        ├─ STAGE_CONFIGS[nextStage] 읽기
        ├─ 새 Bodies 생성
        ├─ World.add(새 Bodies)
        └─ stageBodiesRef.current 갱신
```

## 결과
- 상태: 완료


## 배운내용


## 다음 작업
- 해당 점수 도달하면 다음스테이지 전환

---

# 업무일지 2

## 기본 정보
- 날짜: 2026-02-06 (목요일) 13:30~14:30
- 작성자: hexsera

## 진행 목표
핀볼 게임에 Plunger(발사기) 기능을 추가한다. 스페이스바로 충전 후 발사하는 메커니즘을 구현하고, 공이 Plunger lane을 통해 게임 필드로 진입하도록 한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| Phase 1: Plunger lane 및 Body 생성 | `frontend/src/Pinball.jsx` | rightWall2 축소, plungerLaneGuide/plunger Body 추가, 공 위치 변경 |
| Phase 2: 키보드 이벤트 및 발사 로직 | `frontend/src/Pinball.jsx` | 스페이스바 이벤트, beforeUpdate 당기기, 리셋 위치 변경 |
| Phase 3 계획 수정 | `PRD/핀볼-Plunger-실행계획.md` | 모바일 터치 대응 → Plunger 발사력 강화로 변경 |


## 주요 변경 사항

### 1. 핀볼-Plunger-실행계획.md 생성

**추가:**
실행계획 문서를 3개 Phase로 구성:
- **Phase 1**: Plunger lane 및 Body 생성 (테스트 가능)
- **Phase 2**: 키보드 이벤트 및 발사 로직
- **Phase 3**: Plunger 발사력 강화 (PLUNGER_MAX_LAUNCH_SPEED 조정)

**특징:**
- Static Plunger + Ball Velocity 직접 적용 방식 채택
- 스페이스바 충전 시스템 (0.1초~1.5초, chargeRatio 0.1~1.0)
- Phase별로 테스트 가능한 구조

### 2. Pinball.jsx - Phase 1 구현

#### 2-1. rightWall2 높이 축소

**변경 전:**
```javascript
const rightWall2 = Bodies.rectangle(630, 550, 30, 1100, {
  isStatic: true,
  render: { fillStyle: '#16213e' }
});
```

**변경 후:**
```javascript
// rightWall2: y=200~1100 구간만 벽 유지 (상단 160px 개방하여 Plunger lane 출구 생성)
const rightWall2 = Bodies.rectangle(630, 650, 30, 900, {
  isStatic: true,
  render: { fillStyle: '#16213e' }
});
```

**특징:**
- 높이 1100 → 900, 중심 y좌표 550 → 650
- 상단 면이 y=200이 되어 y=40(천장)~y=200 구간에 출구 생성
- 공이 Plunger lane을 통해 위로 올라가 이 출구로 게임 필드 진입

#### 2-2. plungerLaneGuide 및 Plunger Body 추가

**추가:**
```javascript
// Plunger lane 상단 가이드 벽 (공이 왼쪽 게임 필드로 나가도록 유도)
const plungerLaneGuide = Bodies.rectangle(660, 200, 60, 10, {
  isStatic: true,
  angle: -0.3,
  render: { fillStyle: '#16213e' }
});

// Plunger 상수
const PLUNGER_X = 662;
const PLUNGER_REST_Y = 1050;
const PLUNGER_PULL_SPEED = 0.8;
const PLUNGER_MAX_PULL_Y = 1080;
const PLUNGER_MAX_LAUNCH_SPEED = 35;

// Plunger Body (시각적 표현, isStatic)
const plunger = Bodies.rectangle(PLUNGER_X, PLUNGER_REST_Y, 30, 15, {
  isStatic: true,
  label: 'plunger',
  render: { fillStyle: '#c0c0c0' }
});
```

**특징:**
- `plungerLaneGuide`: lane 상단 출구에 약간 왼쪽으로 기울어진 가이드 벽
- `plunger`: x=662 (rightWall2와 rightWall 사이 통로 중앙), isStatic으로 직접 제어
- PLUNGER_MAX_LAUNCH_SPEED = 35 (Phase 3에서 50 또는 60으로 증가 예정)

#### 2-3. 공 초기 위치 변경

**변경 전:**
```javascript
const ball = Bodies.circle(250, 400, 15, {
  restitution: 0.8,
  friction: 0,
  frictionAir: 0,
  render: { fillStyle: '#e94560' }
});
```

**변경 후:**
```javascript
// 핀볼 공 만들기 (Plunger lane에서 시작)
const ball = Bodies.circle(662, 1020, 15, {
  restitution: 0.8,
  friction: 0,
  frictionAir: 0,
  render: { fillStyle: '#e94560' }
});
```

**특징:**
- 초기 위치 (250, 400) → (662, 1020)
- Plunger(y=1050) 바로 위에 공이 놓임

#### 2-4. World.add에 새 Body 추가

**변경 전:**
```javascript
World.add(engine.world, [
  leftWall, rightWall, rightWall2, upWall,
  leftFunnelWall, rightFunnelWall, deathZone,
  ball, leftFlipper, rightFlipper,
  leftFlipperConstraint, rightFlipperConstraint
]);
```

**변경 후:**
```javascript
World.add(engine.world, [
  leftWall, rightWall, rightWall2, upWall,
  leftFunnelWall, rightFunnelWall, deathZone,
  ball, leftFlipper, rightFlipper,
  leftFlipperConstraint, rightFlipperConstraint,
  plunger,              // Phase 1에서 추가
  plungerLaneGuide      // Phase 1에서 추가
]);
```

**특징:**
- plunger와 plungerLaneGuide를 물리 세계에 등록
- Phase 1 완료 후 게임 실행 시 Plunger lane 확인 가능

### 3. Pinball.jsx - Phase 2 구현

#### 3-1. 키 상태 변수 추가

**변경 전:**
```javascript
let isLeftKeyPressed = false;
let isRightKeyPressed = false;
```

**변경 후:**
```javascript
let isLeftKeyPressed = false;
let isRightKeyPressed = false;
let isSpacePressed = false;
let spaceHoldStartTime = 0;
```

**특징:**
- `isSpacePressed`: 스페이스바 누름 상태
- `spaceHoldStartTime`: 스페이스바 누른 시각 (충전 시간 계산용)

#### 3-2. handleKeyDown에 스페이스바 처리 추가

**추가:**
```javascript
// 스페이스바로 Plunger 충전
if (event.key === ' ' || event.code === 'Space') {
  event.preventDefault();
  if (!isSpacePressed) {
    isSpacePressed = true;
    spaceHoldStartTime = Date.now();
    console.log('스페이스바 눌림 - Plunger 충전 시작');
  }
}
```

**특징:**
- `event.preventDefault()`로 페이지 스크롤 방지
- 첫 눌림 시에만 충전 시작 (키 반복 무시)

#### 3-3. handleKeyUp에 스페이스바 발사 처리 추가

**추가:**
```javascript
// 스페이스바 발사
if (event.key === ' ' || event.code === 'Space') {
  if (isSpacePressed) {
    isSpacePressed = false;

    const holdDuration = Math.min(Date.now() - spaceHoldStartTime, 1500);
    const chargeRatio = Math.max(holdDuration / 1500, 0.1);
    const launchSpeed = PLUNGER_MAX_LAUNCH_SPEED * chargeRatio;

    // 공이 plunger lane 안에 있을 때만 발사
    const ballInLane = ball.position.x > 640 && ball.position.x < 685 &&
                       ball.position.y > 900 && ball.position.y < 1080;

    if (ballInLane) {
      Body.setVelocity(ball, { x: 0, y: -launchSpeed });
      console.log(`Plunger 발사! 충전: ${(chargeRatio * 100).toFixed(0)}%`);
    }

    // Plunger 원래 위치로 복귀
    Body.setPosition(plunger, { x: PLUNGER_X, y: PLUNGER_REST_Y });
  }
}
```

**특징:**
- 충전 시간(최대 1.5초)에 비례하여 발사 속도 결정
- 공이 lane 영역 안에 있을 때만 발사 작동
- 발사 후 Plunger는 원래 위치로 즉시 복귀

#### 3-4. beforeUpdate에 Plunger 시각적 당기기 추가

**추가:**
```javascript
// Plunger 시각적 당기기 (스페이스바 누르고 있을 때)
if (isSpacePressed) {
  const currentY = plunger.position.y;
  if (currentY < PLUNGER_MAX_PULL_Y) {
    Body.setPosition(plunger, {
      x: PLUNGER_X,
      y: Math.min(currentY + PLUNGER_PULL_SPEED, PLUNGER_MAX_PULL_Y)
    });
  }
}
```

**특징:**
- 스페이스바를 누르고 있으면 Plunger가 아래로 천천히 이동 (당기는 시각 효과)
- PLUNGER_PULL_SPEED = 0.8 (매 프레임 0.8px씩 이동)
- PLUNGER_MAX_PULL_Y = 1080까지만 이동

#### 3-5. 공 리셋 위치 변경

**변경 전 (death zone):**
```javascript
// 공을 초기 위치로 이동
Body.setPosition(ball, { x: 250, y: 400 });
```

**변경 후 (death zone):**
```javascript
// 공을 Plunger lane으로 이동
Body.setPosition(ball, { x: 662, y: 1020 });
```

**변경 전 (N키 스테이지 전환):**
```javascript
// 공 초기 위치로 이동
Body.setPosition(ball, { x: 250, y: 400 });
```

**변경 후 (N키 스테이지 전환):**
```javascript
// 공을 Plunger lane으로 이동
Body.setPosition(ball, { x: 662, y: 1020 });
```

**특징:**
- 공이 죽거나 스테이지 전환 시 Plunger lane으로 리셋
- 매번 Plunger로 발사하여 게임 시작

## 아키텍처 구조

### Plunger 시스템 구조

```
┌──────────────────────────────────────────┐
│     Plunger Lane (x=645~680, 폭 35px)    │
│  ┌────────────────────────────────────┐  │
│  │  rightWall2 (상단 출구 개방)       │  │
│  │  y=200~1100 구간만 벽 유지         │  │
│  │                                    │  │
│  │  ┌──────────────────────┐         │  │
│  │  │ plungerLaneGuide     │         │  │
│  │  │ (y=200, 경사면)      │         │  │
│  │  └──────────────────────┘         │  │
│  │           ↓ 공 진입                │  │
│  │  ┌──────────────────────┐         │  │
│  │  │   게임 필드           │         │  │
│  │  └──────────────────────┘         │  │
│  │                                    │  │
│  │  ┌──────────────────────┐         │  │
│  │  │   Ball (662, 1020)   │         │  │
│  │  └──────────────────────┘         │  │
│  │  ┌──────────────────────┐         │  │
│  │  │  Plunger (662, 1050) │         │  │
│  │  └──────────────────────┘         │  │
│  └────────────────────────────────────┘  │
└──────────────────────────────────────────┘
```

### Plunger 발사 흐름

```
스페이스바 누름 (keydown)
        │
        ▼
  isSpacePressed = true
  spaceHoldStartTime = Date.now()
        │
        ▼
  beforeUpdate 이벤트
        │
        ├─ Plunger.y += 0.8 (당기기 애니메이션)
        └─ 최대 y=1080까지만 이동
        │
        ▼
스페이스바 뗌 (keyup)
        │
        ├─ holdDuration 계산 (최대 1500ms)
        ├─ chargeRatio 계산 (0.1~1.0)
        ├─ launchSpeed = 35 × chargeRatio
        │
        ├─ ballInLane 확인
        │   (x: 640~685, y: 900~1080)
        │
        └─ if (ballInLane)
            └─ Body.setVelocity(ball, {x: 0, y: -launchSpeed})
            └─ Body.setPosition(plunger, 원래 위치)
```

## 결과
- 상태: Phase 1, Phase 2 완료, Phase 3 완료

## 배운내용


## 다음 작업
- 모바일 터치 대응 (선택사항)

# 업무일지 2

## 기본 정보
- 날짜: 2026-02-06 (목) 4:00~4:30
- 작성자: hexsera

## 진행 목표
핀볼 게임의 "음악 시작" 버튼을 게임 UI 영역으로 이동하고, MUI 소리 아이콘으로 교체하여 토글 기능을 추가한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| Phase 1: 음악 시작 버튼 위치 이동 | frontend/src/Pinball.jsx | 게임 캔버스 바깥 → UI 영역(LIVES Box) 안으로 이동 |
| Phase 2: 소리 아이콘으로 교체 | frontend/src/Pinball.jsx | Button → IconButton, 토글 기능 추가 |

## 주요 변경 사항

### 1. frontend/src/Pinball.jsx 수정

#### 변경 1: MUI 아이콘 import 추가

**변경 전:**
```javascript
import { Button, Box, Typography } from '@mui/material';
```

**변경 후:**
```javascript
import { Button, Box, Typography, IconButton } from '@mui/material';
import VolumeUpIcon from '@mui/icons-material/VolumeUp';
import VolumeOffIcon from '@mui/icons-material/VolumeOff';
```

**특징:**
- `IconButton`: 아이콘 전용 버튼 컴포넌트
- `VolumeUpIcon`: 음악 재생 중 아이콘
- `VolumeOffIcon`: 음악 정지 중 아이콘

#### 변경 2: 음악 토글 핸들러로 교체

**변경 전:**
```javascript
// 음악 재생 버튼 클릭 핸들러
const handlePlayMusic = () => {
  if (bgmRef.current) {
    bgmRef.current.play();
    setIsPlaying(true);
  }
};
```

**변경 후:**
```javascript
// 음악 재생/정지 토글 핸들러
const handleToggleMusic = () => {
  if (bgmRef.current) {
    if (isPlaying) {
      bgmRef.current.pause();
      setIsPlaying(false);
    } else {
      bgmRef.current.play();
      setIsPlaying(true);
    }
  }
};
```

**특징:**
- 재생 중이면 일시정지, 정지 중이면 재생
- `isPlaying` 상태에 따라 분기 처리
- 양방향 토글 기능 구현

#### 변경 3: 게임 캔버스 바깥 버튼 제거

**변경 전:**
```javascript
<Box sx={{
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center'
}}>
  {!isPlaying && (
    <Button variant="contained" onClick={handlePlayMusic}>
      음악 시작
    </Button>
  )}
  <Box sx={{
    position: 'relative',
    // ...
```

**변경 후:**
```javascript
<Box sx={{
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center'
}}>
  <Box sx={{
    position: 'relative',
    // ...
```

**특징:**
- 최상위 Box 아래에 있던 "음악 시작" 버튼 제거
- 게임 컨테이너 바깥에 따로 떨어져 있던 버튼 삭제

#### 변경 4: UI 영역 레이아웃 변경 및 IconButton 추가

**변경 전:**
```javascript
{/* UI 영역 (상단 300px) */}
<Box sx={{
  width: '700px',
  height: '100px',
  backgroundColor: '#000000',
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center'
}}>
  <Typography sx={{
    fontSize: '32px',
    fontWeight: 'bold',
    color: '#ffffff'
  }}>
    LIVES: {lives}
  </Typography>
</Box>
```

**변경 후:**
```javascript
{/* UI 영역 (상단 300px) */}
<Box sx={{
  width: '700px',
  height: '100px',
  backgroundColor: '#000000',
  display: 'flex',
  flexDirection: 'row',
  justifyContent: 'space-between',
  alignItems: 'center',
  padding: '0 20px'
}}>
  <Typography sx={{
    fontSize: '32px',
    fontWeight: 'bold',
    color: '#ffffff'
  }}>
    LIVES: {lives}
  </Typography>

  <IconButton
    onClick={handleToggleMusic}
    sx={{
      color: '#FFD700',
      '&:hover': { color: '#FFC107' },
    }}
  >
    {isPlaying ? (
      <VolumeUpIcon sx={{ fontSize: '36px' }} />
    ) : (
      <VolumeOffIcon sx={{ fontSize: '36px' }} />
    )}
  </IconButton>
</Box>
```

**특징:**
- `flexDirection: 'column'` → `'row'`: LIVES와 아이콘을 좌우 배치
- `justifyContent: 'center'` → `'space-between'`: LIVES 왼쪽, 아이콘 오른쪽
- `padding: '0 20px'` 추가: 좌우 여백 확보
- `IconButton` 추가: 항상 표시 (조건부 렌더링 제거)
- 아이콘 크기: 36px
- `isPlaying` 상태에 따라 VolumeUp/VolumeOff 아이콘 전환

## UI 구조

**변경 전:**
```
┌─────────────────────────────────┐
│      "음악 시작" 버튼           │  ← 게임 캔버스 바깥
├─────────────────────────────────┤
│   ┌───────────────────────┐     │
│   │   UI 영역 (검은색)   │     │
│   │    LIVES: 3           │     │  ← 세로 중앙 정렬
│   └───────────────────────┘     │
│                                 │
│     게임 캔버스 (700×1100)      │
└─────────────────────────────────┘
```

**변경 후:**
```
┌─────────────────────────────────┐
│   ┌───────────────────────┐     │
│   │   UI 영역 (검은색)   │     │
│   │ LIVES: 3        🔇   │     │  ← 좌우 배치
│   └───────────────────────┘     │
│                                 │
│     게임 캔버스 (700×1100)      │
└─────────────────────────────────┘
```

## 결과
- 상태: 완료


## 배운내용


## 다음 작업
- 소리 아이콘 음악이 아니라 음소거로 만들기
- 소리 시스템 생성

---

# 업무일지 3

## 기본 정보
- 날짜: 2026-02-06 (목) 4:50~5:30
- 작성자: hexsera

## 진행 목표
핀볼 게임의 "LIVES: {숫자}" 텍스트를 제거하고, 남은 목숨 수만큼 하트 아이콘을 가로로 나열하는 UI로 교체한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 실행계획 작성 | PRD/핀볼-목숨-하트아이콘-UI-실행계획.md | Plan 스킬 사용하여 작성 |
| FavoriteIcon import 추가 | frontend/src/Pinball.jsx | MUI 하트 아이콘 import |
| Typography를 하트 아이콘 Box로 교체 | frontend/src/Pinball.jsx | LIVES 텍스트 → 하트 아이콘 3개 |


## 주요 변경 사항

### 1. frontend/src/Pinball.jsx 수정

#### 변경 1: FavoriteIcon import 추가

**변경 전:**
```javascript
import { Button, Box, Typography, IconButton } from '@mui/material';
import VolumeUpIcon from '@mui/icons-material/VolumeUp';
import VolumeOffIcon from '@mui/icons-material/VolumeOff';
```

**변경 후:**
```javascript
import { Button, Box, Typography, IconButton } from '@mui/material';
import VolumeUpIcon from '@mui/icons-material/VolumeUp';
import VolumeOffIcon from '@mui/icons-material/VolumeOff';
import FavoriteIcon from '@mui/icons-material/Favorite';
```

**특징:**
- `FavoriteIcon`: MUI의 채워진 하트 아이콘 (filled heart)
- 기존 음악 아이콘들과 동일한 import 패턴 사용

#### 변경 2: Typography를 하트 아이콘 Box로 교체

**변경 전:**
```javascript
<Typography sx={{
  fontSize: '32px',
  fontWeight: 'bold',
  color: '#ffffff'
}}>
  LIVES: {lives}
</Typography>
```

**변경 후:**
```javascript
<Box sx={{
  display: 'flex',
  flexDirection: 'row',
  alignItems: 'center',
  gap: '6px'
}}>
  {Array.from({ length: lives }).map((_, index) => (
    <FavoriteIcon
      key={index}
      sx={{
        fontSize: '36px',
        color: '#ff1744'
      }}
    />
  ))}
</Box>
```

**특징:**
- `Array.from({ length: lives })`: lives 상태값(3, 1, 0)만큼 하트 생성
- `fontSize: '36px'`: 우측 음악 아이콘과 동일한 크기
- `color: '#ff1744'`: MUI 빨간색 계열 (red[A400]), 검정 배경에서 높은 대비
- `gap: '6px'`: 하트 간 간격 (flexbox gap 속성)
- 동적 렌더링: lives=3이면 하트 3개, lives=1이면 1개, lives=0이면 빈 Box

## UI 구조

**변경 전:**
```
┌─────────────────────────────────┐
│   ┌───────────────────────┐     │
│   │   UI 영역 (검은색)   │     │
│   │ LIVES: 3        🔇   │     │  ← 텍스트 표시
│   └───────────────────────┘     │
│                                 │
│     게임 캔버스 (700×1100)      │
└─────────────────────────────────┘
```

**변경 후:**
```
┌─────────────────────────────────┐
│   ┌───────────────────────┐     │
│   │   UI 영역 (검은색)   │     │
│   │ ❤❤❤             🔇   │     │  ← 하트 아이콘 3개
│   └───────────────────────┘     │
│                                 │
│     게임 캔버스 (700×1100)      │
└─────────────────────────────────┘
```

## 하트 아이콘 동작

```
게임 시작 (lives = 3)
        │
        ▼
    ❤ ❤ ❤  (하트 3개 표시)
        │
        ▼
공이 죽음구역 진입 (lives = 1)
        │
        ▼
      ❤      (하트 1개 표시)
        │
        ▼
공이 죽음구역 진입 (lives = 0)
        │
        ▼
    (빈 Box)  (하트 없음, Game Over)
```

## 결과
- 상태: 완료

## 배운내용


## 다음 작업
- 죽을때 효과음 생성

# 업무일지 4

## 기본 정보
- 날짜: 2026-02-06 (목요일) 6:15~6:45
- 작성자: hexsera

## 진행 목표
핀볼 게임에 접속하면 백엔드 `/api/v1/game_visits` 엔드포인트로 POST 요청을 보내 게임 방문 기록을 서버에 저장한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| Pinball.jsx 수정 | frontend/src/Pinball.jsx | 게임 방문 기록 API 호출 useEffect 추가 |

## 주요 변경 사항


### 2. frontend/src/Pinball.jsx 수정

**변경 전:**
```javascript
  // 최적 스케일 계산 함수
  const calculateScale = useCallback(() => {
    const canvasWidth = 700;
    const canvasHeight = 1200;
    const padding = 120; // 여백

    // 화면 너비/높이 기준으로 각각 계산
    const scaleByWidth = (windowSize.width - padding) / canvasWidth;
    const scaleByHeight = (windowSize.height - padding) / canvasHeight;

    // 둘 중 작은 값을 선택하여 화면에 꽉 차지 않도록
    const optimalScale = Math.min(scaleByWidth, scaleByHeight, 1);

    setGameScale(optimalScale);
  }, [windowSize]);




  useEffect(() => {
```

**변경 후:**
```javascript
  // 최적 스케일 계산 함수
  const calculateScale = useCallback(() => {
    const canvasWidth = 700;
    const canvasHeight = 1200;
    const padding = 120; // 여백

    // 화면 너비/높이 기준으로 각각 계산
    const scaleByWidth = (windowSize.width - padding) / canvasWidth;
    const scaleByHeight = (windowSize.height - padding) / canvasHeight;

    // 둘 중 작은 값을 선택하여 화면에 꽉 차지 않도록
    const optimalScale = Math.min(scaleByWidth, scaleByHeight, 1);

    setGameScale(optimalScale);
  }, [windowSize]);

  // 게임 방문 기록 API 호출
  useEffect(() => {
    const recordGameVisit = async () => {
      try {
        await axios.post('/api/v1/game_visits', {
          user_id: user?.id || null
        });
      } catch (error) {
        console.error('Game visit recording failed:', error);
      }
    };

    recordGameVisit();
  }, []);

  useEffect(() => {
```

**특징:**
- `useEffect` 의존성 배열 `[]`로 컴포넌트 마운트 시 한 번만 실행
- `user?.id || null`로 로그인/비로그인 상태 모두 처리
- API 호출 실패 시에도 게임 플레이에 영향 없음 (에러 처리)
- async/await 패턴으로 비동기 처리
- 백엔드에서 IP 기준 중복 방지를 처리하므로 프론트엔드는 단순 호출만 수행


## 데이터 흐름

```
Pinball.jsx 마운트
        │
        ▼
  useEffect([]) 실행
        │
        ▼
  recordGameVisit() 호출
        │
        ├─ user?.id 확인
        │   ├─ 로그인: user_id = 숫자
        │   └─ 비로그인: user_id = null
        │
        ▼
  axios.post('/api/v1/game_visits', { user_id })
        │
        ▼
  FastAPI /api/v1/game_visits
        │
        ├─ get_client_ip(request) → IP 추출
        ├─ 오늘 날짜 + IP로 기존 레코드 조회
        │
        ├─ if 레코드 존재:
        │   ├─ 기존 user_id == null && 새 user_id != null
        │   │   └─ user_id 업데이트
        │   └─ response: is_new_record = False
        │
        └─ else:
            ├─ 새 GameVisit 레코드 생성
            └─ response: is_new_record = True
```

## 결과
- 상태: 완료

## 배운내용


## 다음 작업

