# 업무일지

## 기본 정보
- 날짜: 2026-02-06 (목요일) p1(10:30~11:00 11:30~12:00) p2(12:20~12:35) p3(12:35~1:20)
- 작성자: hexsera

## 진행 목표
핀볼 게임에 2단계 스테이지 시스템을 도입한다. 스테이지별로 장애물/범퍼/목표물 배치가 다른 맵 구성을 가지며, 'n' 키로 스테이지 전환을 테스트할 수 있도록 구현한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| PHASE 1: 스테이지 데이터 분리 및 상태 관리 | `frontend/src/stageConfigs.js` (생성) | 스테이지 설정 데이터 정의 |
| PHASE 1: STAGE_CONFIGS import | `frontend/src/Pinball.jsx` | import 문 추가 |
| PHASE 1: 스테이지 상태 추가 | `frontend/src/Pinball.jsx` | stage, stageRef, stageBodiesRef 추가 |
| PHASE 2: 맵 로딩 함수 구현 | `frontend/src/Pinball.jsx` | loadStageMap() 함수 생성 |
| PHASE 2: 하드코딩 장애물 제거 | `frontend/src/Pinball.jsx` | obstacle1, obstacle2, bumper, target 제거 |
| PHASE 2: 초기 맵 로딩 | `frontend/src/Pinball.jsx` | loadStageMap(1) 호출 추가 |
| PHASE 3: 'n' 키 스테이지 전환 | `frontend/src/Pinball.jsx` | handleKeyDown에 'n' 키 처리 추가 |

## 주요 변경 사항

### 1. stageConfigs.js 생성

**추가:**
```javascript
// 스테이지 설정 데이터 정의
export const STAGE_CONFIGS = {
  1: {
    name: 'Stage 1',
    targetScore: 1000,
    obstacles: [
      { type: 'circle', x: 300, y: 300, radius: 30, options: { isStatic: true, render: { fillStyle: '#0f3460' } } },
      { type: 'circle', x: 500, y: 300, radius: 30, options: { isStatic: true, render: { fillStyle: '#0f3460' } } }
    ],
    bumpers: [
      { x: 400, y: 600, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e74c3c' } } }
    ],
    targets: [
      { x: 500, y: 590, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#87CEEB' } } }
    ]
  },
  2: {
    name: 'Stage 2',
    targetScore: null,
    obstacles: [
      { type: 'circle', x: 200, y: 250, radius: 25, options: { isStatic: true, render: { fillStyle: '#8e44ad' } } },
      { type: 'circle', x: 400, y: 200, radius: 25, options: { isStatic: true, render: { fillStyle: '#8e44ad' } } },
      { type: 'circle', x: 500, y: 400, radius: 25, options: { isStatic: true, render: { fillStyle: '#8e44ad' } } }
    ],
    bumpers: [
      { x: 300, y: 500, radius: 35, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e74c3c' } } },
      { x: 500, y: 700, radius: 35, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e74c3c' } } }
    ],
    targets: [
      { x: 350, y: 350, radius: 35, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#87CEEB' } } },
      { x: 200, y: 600, radius: 35, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#87CEEB' } } }
    ]
  }
};
```

**특징:**
- 관심사 분리: 게임 데이터를 별도 파일로 분리
- 스테이지 1: 장애물 2개, 범퍼 1개, 목표물 1개
- 스테이지 2: 장애물 3개, 범퍼 2개, 목표물 2개 (스테이지 1보다 복잡)
- 확장성: 향후 스테이지 3, 4 추가 시 이 파일만 수정하면 됨

### 2. Pinball.jsx - import 추가

**변경 전:**
```javascript
import { useEffect, useRef, useState, useCallback } from 'react';
import Matter from 'matter-js';
import axios from 'axios';
import { Button, Box, Typography } from '@mui/material';
import { useAuth } from './AuthContext';
```

**변경 후:**
```javascript
import { useEffect, useRef, useState, useCallback } from 'react';
import Matter from 'matter-js';
import axios from 'axios';
import { Button, Box, Typography } from '@mui/material';
import { useAuth } from './AuthContext';
import { STAGE_CONFIGS } from './stageConfigs';
```

**특징:**
- stageConfigs.js에서 STAGE_CONFIGS를 import
- 스테이지 설정 데이터를 컴포넌트에서 사용 가능

### 3. Pinball.jsx - 스테이지 상태 추가

**변경 전:**
```javascript
const sceneRef = useRef(null);
const bgmRef = useRef(null);
const hitSoundRef = useRef(null);
const ballRef = useRef(null);
const livesRef = useRef(2);
const scoreRef = useRef(0);
const [isPlaying, setIsPlaying] = useState(false);
const [score, setScore] = useState(0);
const [lives, setLives] = useState(3);
const [overlayState, setOverlayState] = useState(null);
const [bestScore, setBestScore] = useState(null);
```

**변경 후:**
```javascript
const sceneRef = useRef(null);
const bgmRef = useRef(null);
const hitSoundRef = useRef(null);
const ballRef = useRef(null);
const livesRef = useRef(2);
const scoreRef = useRef(0);
const stageRef = useRef(1);
const stageBodiesRef = useRef([]);
const [isPlaying, setIsPlaying] = useState(false);
const [score, setScore] = useState(0);
const [lives, setLives] = useState(3);
const [stage, setStage] = useState(1);
const [overlayState, setOverlayState] = useState(null);
const [bestScore, setBestScore] = useState(null);
```

**특징:**
- `stageRef`: 현재 스테이지 번호 (이벤트 콜백 내부에서 참조)
- `stageBodiesRef`: 현재 스테이지의 동적 Bodies 저장 (스테이지 전환 시 제거용)
- `stage`: 현재 스테이지 번호 (UI 표시용)

### 4. Pinball.jsx - loadStageMap() 함수 추가

**추가:**
```javascript
// 맵 로딩 함수
const loadStageMap = (stageNumber) => {
  // 기존 스테이지 Bodies 제거
  if (stageBodiesRef.current.length > 0) {
    World.remove(engine.world, stageBodiesRef.current);
    stageBodiesRef.current = [];
  }

  const config = STAGE_CONFIGS[stageNumber];
  const newBodies = [];

  // 장애물 생성
  config.obstacles.forEach((obs) => {
    const body = Bodies.circle(obs.x, obs.y, obs.radius, obs.options);
    newBodies.push(body);
  });

  // 범퍼 생성
  config.bumpers.forEach((b) => {
    const body = Bodies.circle(b.x, b.y, b.radius, b.options);
    newBodies.push(body);
  });

  // 목표물 생성
  config.targets.forEach((t) => {
    const body = Bodies.circle(t.x, t.y, t.radius, t.options);
    newBodies.push(body);
  });

  // World에 추가
  World.add(engine.world, newBodies);
  stageBodiesRef.current = newBodies;
};
```

**특징:**
- 기존 스테이지 Bodies를 `World.remove()`로 제거
- `STAGE_CONFIGS`에서 스테이지 설정을 읽어 Bodies 생성
- 생성된 Bodies를 `stageBodiesRef.current`에 저장하여 다음 스테이지 전환 시 제거 가능

### 5. Pinball.jsx - 하드코딩된 장애물 제거

**변경 전:**
```javascript
ballRef.current = ball;

// 장애물 만들기
const obstacle1 = Bodies.circle(300, 300, 30, {
  isStatic: true,
  render: { fillStyle: '#0f3460' }
});

const obstacle2 = Bodies.circle(500, 300, 30, {
  isStatic: true,
  render: { fillStyle: '#0f3460' }
});

// 범퍼 만들기 (충돌 시 강하게 튕겨냄)
const bumper = Bodies.circle(400, 600, 40, {
  isStatic: true,
  restitution: 1.5,
  label: 'bumper',
  render: { fillStyle: '#e74c3c' }
});

// 목표 오브젝트 만들기 (충돌 시 강하게 튕겨냄)
const target = Bodies.circle(500, 500, 40, {
  isStatic: true,
  restitution: 1.5,
  label: 'target',
  render: { fillStyle: '#87CEEB' }
});

// 왼쪽 플리퍼 (회전축 x=270, 중심 = 회전축 + 길이절반50 = x=320)
```

**변경 후:**
```javascript
ballRef.current = ball;

// 왼쪽 플리퍼 (회전축 x=270, 중심 = 회전축 + 길이절반50 = x=320)
```

**특징:**
- `obstacle1`, `obstacle2`, `bumper`, `target` 변수 선언 및 생성 코드 제거
- 이제 `loadStageMap()` 함수가 동적으로 생성

### 6. Pinball.jsx - World.add() 수정 및 초기 맵 로딩

**변경 전:**
```javascript
World.add(engine.world, [
  leftWall,
  rightWall,
  rightWall2,
  upWall,
  leftFunnelWall,
  rightFunnelWall,
  deathZone,
  ball,
  obstacle1,
  obstacle2,
  bumper,
  target,
  leftFlipper,
  rightFlipper,
  leftFlipperConstraint,
  rightFlipperConstraint
]);
```

**변경 후:**
```javascript
World.add(engine.world, [
  leftWall,
  rightWall,
  rightWall2,
  upWall,
  leftFunnelWall,
  rightFunnelWall,
  deathZone,
  ball,
  leftFlipper,
  rightFlipper,
  leftFlipperConstraint,
  rightFlipperConstraint
]);

// 스테이지 1 맵 로딩
loadStageMap(1);
```

**특징:**
- `obstacle1`, `obstacle2`, `bumper`, `target`을 `World.add()` 배열에서 제거
- 벽, 깔대기, 죽음구역, 공, 플리퍼는 모든 스테이지 공통이므로 유지
- `loadStageMap(1)` 호출로 스테이지 1 맵 동적 로딩

### 7. Pinball.jsx - 'n' 키 스테이지 전환 추가

**변경 전:**
```javascript
const handleKeyDown = (event) => {
  if (event.key === 'ArrowLeft') {
    console.log('왼쪽 방향키 눌림');
    isLeftKeyPressed = true;
  }
  if (event.key === 'ArrowRight') {
    console.log('오른쪽 방향키 눌림');
    isRightKeyPressed = true;
  }
};
```

**변경 후:**
```javascript
const handleKeyDown = (event) => {
  if (event.key === 'ArrowLeft') {
    console.log('왼쪽 방향키 눌림');
    isLeftKeyPressed = true;
  }
  if (event.key === 'ArrowRight') {
    console.log('오른쪽 방향키 눌림');
    isRightKeyPressed = true;
  }
  // 'n' 키로 스테이지 전환 (테스트용)
  if (event.key === 'n' || event.key === 'N') {
    const currentStage = stageRef.current;
    const nextStage = currentStage + 1;
    if (STAGE_CONFIGS[nextStage]) {
      console.log(`Stage ${currentStage} → Stage ${nextStage} (테스트)`);

      // 스테이지 전환
      stageRef.current = nextStage;
      setStage(nextStage);

      // 생명 초기화
      livesRef.current = 2;  // lives 상태는 +1이므로 ref는 2
      setLives(3);

      // 공 초기 위치로 이동
      Body.setPosition(ball, { x: 250, y: 400 });
      Body.setVelocity(ball, { x: 0, y: 0 });
      Body.setAngularVelocity(ball, 0);

      // 맵 전환
      loadStageMap(nextStage);
    } else {
      console.log('마지막 스테이지입니다');
    }
  }
};
```

**특징:**
- 'n' 또는 'N' 키로 다음 스테이지로 강제 전환
- 스테이지 전환 시 생명 3개로 초기화
- 공의 위치, 속도, 각속도를 초기화
- `loadStageMap(nextStage)`로 새 맵 로딩
- 마지막 스테이지에서는 콘솔 메시지만 출력

## 아키텍처 구조

### 스테이지 시스템 데이터 흐름

```
┌───────────────────────────────────────┐
│      stageConfigs.js                  │
│  STAGE_CONFIGS = {                    │
│    1: { obstacles, bumpers, targets } │
│    2: { obstacles, bumpers, targets } │
│  }                                    │
└─────────────┬─────────────────────────┘
              │ export
              ▼
┌───────────────────────────────────────┐
│      Pinball.jsx                      │
│  - stageRef (현재 스테이지 번호)      │
│  - stageBodiesRef (동적 Bodies)      │
└─────────────┬─────────────────────────┘
              │
              ▼
      ┌───────────────┐
      │ loadStageMap()│
      └───────┬───────┘
              │
    ┌─────────┴─────────┐
    │                   │
    ▼                   ▼
World.remove()      STAGE_CONFIGS[n]
(기존 Bodies)       (새 스테이지 설정)
    │                   │
    └─────────┬─────────┘
              ▼
        Bodies 생성
    (obstacles, bumpers, targets)
              │
              ▼
        World.add()
    (Matter.js World에 추가)
              │
              ▼
     stageBodiesRef.current
        (참조 저장)
```

### 스테이지 전환 흐름

```
사용자 'n' 키 입력
        │
        ▼
  handleKeyDown()
        │
        ├─ stageRef.current++
        ├─ setStage()
        ├─ livesRef.current = 2
        ├─ setLives(3)
        ├─ Ball 위치/속도 초기화
        │
        ▼
  loadStageMap(nextStage)
        │
        ├─ World.remove(이전 Bodies)
        ├─ STAGE_CONFIGS[nextStage] 읽기
        ├─ 새 Bodies 생성
        ├─ World.add(새 Bodies)
        └─ stageBodiesRef.current 갱신
```

## 결과
- 상태: 완료


## 배운내용


## 다음 작업
- 해당 점수 도달하면 다음스테이지 전환
