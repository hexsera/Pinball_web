# 업무일지

## 기본 정보
- 날짜: 2026-02-14 (토) 12:00~13:00
- 작성자: hexsera

## 진행 목표
핀볼 게임 화면에서 발생하는 불필요한 세로 스크롤 제거 및 모바일 레이아웃 최적화

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 핀볼 세로 스크롤 제거 실행계획 작성 | `PRD/핀볼-세로스크롤-제거-실행계획.md` | 신규 생성 |
| 핀볼 세로 스크롤 제거 구현 | `PinballPage/PinballPage.jsx` | `minHeight→height`, `overflow:hidden`, marginBottom 음수 보정 |
| 핀볼 모바일 화면 개선 실행계획 작성 | `PRD/핀볼-모바일-화면-개선-실행계획.md` | 신규 생성 |
| 핀볼 모바일 레이아웃 구현 | `PinballPage/PinballPage.jsx` | 모바일 감지, 헤더 높이 측정, scale 계산 분기 |

**총 1시간 30분**

## 주요 변경 사항

### 1. PinballPage.jsx 수정 — 세로 스크롤 제거

**변경 전:**
```jsx
<Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh', backgroundColor: '#0F172A' }}>
  ...
  <Box sx={{ flexGrow: 1, display: 'flex', justifyContent: 'center', alignItems: 'flex-start', pt: 2 }}>
    <Box sx={{ transform: `scale(${gameScale})`, transformOrigin: 'top center' }}>
      <Pinball />
    </Box>
  </Box>
</Box>
```

**변경 후:**
```jsx
const scaledHeight = 1200 * gameScale;

<Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', overflow: 'hidden', backgroundColor: '#000000' }}>
  ...
  <Box sx={{ flexGrow: 1, display: 'flex', justifyContent: 'center', alignItems: 'flex-start', overflow: 'hidden', pt: 2 }}>
    <Box sx={{
      transform: `scale(${gameScale})`,
      transformOrigin: 'top center',
      width: 700,
      height: 1200,
      marginBottom: `${scaledHeight - 1200}px`,
      marginLeft: 'auto',
      marginRight: 'auto',
    }}>
      <Pinball />
    </Box>
  </Box>
</Box>
```

**특징:**
- `minHeight: '100vh'` → `height: '100vh'` + `overflow: 'hidden'` 변경으로 스크롤 원천 차단
- `transform: scale()`은 시각적 크기만 줄이고 DOM 레이아웃 공간은 원본(1200px)을 유지하는 문제를 `marginBottom` 음수 보정으로 해결
- `scale=0.7`이면 `marginBottom = (1200×0.7) - 1200 = -360px`이 되어 여분 공간 제거

### 2. PinballPage.jsx 수정 — 모바일 레이아웃 최적화

**변경 전:**
```jsx
import { useState, useEffect, useCallback } from 'react';

const calculateScale = useCallback(() => {
  const canvasWidth = 700;
  const canvasHeight = 1200;
  const padding = 120;
  const scaleByWidth = (windowSize.width - padding) / canvasWidth;
  const scaleByHeight = (windowSize.height - padding) / canvasHeight;
  setGameScale(Math.min(scaleByWidth, scaleByHeight, 1));
}, [windowSize]);
```

**변경 후:**
```jsx
import { useState, useEffect, useCallback, useRef } from 'react';
import { useTheme } from '@mui/material/styles';
import useMediaQuery from '@mui/material/useMediaQuery';

const theme = useTheme();
const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
const appBarRef = useRef(null);
const [headerHeight, setHeaderHeight] = useState(0);

useEffect(() => {
  if (appBarRef.current) {
    setHeaderHeight(appBarRef.current.offsetHeight);
  }
}, []);

const calculateScale = useCallback(() => {
  const canvasWidth = 700;
  const canvasHeight = 1200;

  if (isMobile) {
    const scaleByWidth = windowSize.width / canvasWidth;
    const scaleByHeight = (windowSize.height - headerHeight) / canvasHeight;
    setGameScale(Math.min(scaleByWidth, scaleByHeight, 1));
  } else {
    const padding = 120;
    const scaleByWidth = (windowSize.width - padding) / canvasWidth;
    const scaleByHeight = (windowSize.height - padding) / canvasHeight;
    setGameScale(Math.min(scaleByWidth, scaleByHeight, 1));
  }
}, [windowSize, isMobile, headerHeight]);
```

**특징:**
- MUI `useMediaQuery(theme.breakpoints.down('sm'))`으로 600px 이하를 모바일로 감지
- `appBarRef.current.offsetHeight`로 AppBar의 실제 렌더링 높이를 측정
- 모바일: padding 없이 뷰포트 전체를 기준으로 scale 계산 → 화면을 꽉 채움
- 데스크탑: 기존 `padding: 120` 방식 유지
- 게임 영역 상단 패딩을 `pt: isMobile ? 0 : 2`로 모바일에서 제거

## 결과
- 상태: 완료

## 배운내용


## 다음 작업

# 업무일지

## 기본 정보
- 날짜: 2026-02-14 (토) 13:00~13:20
- 작성자: hexsera

## 진행 목표
핀볼 게임 로딩 시 깨진 화면이 잠깐 보이는 문제를 로딩 스피너로 가려, 게임이 완전히 준비된 후 화면에 표시되도록 개선

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 핀볼 스피너 PRD 작성 | `PRD/핀볼 스피너 prd.md` | 신규 생성 |
| 핀볼 로딩 스피너 실행계획 작성 | `PRD/핀볼-로딩-스피너-실행계획.md` | 신규 생성, PinballPage 기반 방식으로 확정 |
| `Pinball.jsx` — onReady prop 추가 | `Pinball/Pinball.jsx` | 함수 시그니처 변경, afterRender 첫 프레임 감지 |
| `PinballPage.jsx` — 스피너 오버레이 추가 | `PinballPage/PinballPage.jsx` | isReady state, CircularProgress, visibility 제어 |

**총 30분**

## 주요 변경 사항

### 1. Pinball.jsx 수정

**변경 전:**
```jsx
function Pinball() {
  ...
  Events.on(render, 'afterRender', () => {
    const ctx = render.context;
    // 범퍼 글로우 렌더링...
  });
```

**변경 후:**
```jsx
function Pinball({ onReady }) {
  ...
  let firstFrameFired = false;
  Events.on(render, 'afterRender', () => {
    if (!firstFrameFired) {
      firstFrameFired = true;
      onReady?.();
    }
    const ctx = render.context;
    // 범퍼 글로우 렌더링...
  });
```

**특징:**
- `onReady` prop을 받아 Matter.js 첫 프레임 렌더링 완료 시점에 호출
- `firstFrameFired` 지역 변수로 단 1회만 실행되도록 제한
- `onReady?.()` 옵셔널 체이닝으로 prop 미전달 시에도 에러 없이 동작

### 2. PinballPage.jsx 수정

**변경 전:**
```jsx
import { Box, AppBar, Toolbar, IconButton } from '@mui/material';
...
const [gameScale, setGameScale] = useState(1);
...
<Box sx={{ transform: `scale(${gameScale})`, ... }}>
  <Pinball />
</Box>
```

**변경 후:**
```jsx
import { Box, AppBar, Toolbar, IconButton, CircularProgress } from '@mui/material';
...
const [gameScale, setGameScale] = useState(1);
const [isReady, setIsReady] = useState(false);
...
<Box sx={{ transform: `scale(${gameScale})`, ..., position: 'relative' }}>
  <Box sx={{ visibility: isReady ? 'visible' : 'hidden' }}>
    <Pinball onReady={() => setIsReady(true)} />
  </Box>
  {!isReady && (
    <Box sx={{
      position: 'absolute', top: 0, left: 0,
      width: '100%', height: '100%',
      backgroundColor: '#000000',
      display: 'flex', justifyContent: 'center', alignItems: 'center',
      zIndex: 50,
    }}>
      <CircularProgress size={64} sx={{ color: '#e94560' }} />
    </Box>
  )}
</Box>
```

**특징:**
- `isReady` state로 스피너/게임 표시를 `PinballPage`에서 일괄 제어
- `visibility: hidden` 사용 — `display: none`이면 `sceneRef.current`가 null이 되어 Matter.js 렌더러 초기화 실패하므로 사용 불가
- 스피너는 `position: absolute`로 게임 영역 위에 덮어씌움

**컴포넌트 데이터 흐름:**
```
PinballPage
├── isReady: false → 스피너 오버레이 표시
│                    Pinball (visibility: hidden, 초기화 진행 중)
│                           │
│                    Matter.js afterRender 첫 콜백
│                           │ onReady() 호출
│                           ▼
└── isReady: true → 스피너 제거
                    Pinball (visibility: visible, 게임 표시)
```

## 결과
- 상태: 완료

## 배운내용


## 다음 작업

# 업무일지

## 기본 정보
- 날짜: 2026-02-14 (토) 18:00~18:40
- 작성자: hexsera

## 진행 목표
핀볼 게임에서 방향키를 오래 누를 때 플리퍼 사운드가 연속 재생되는 문제를 해결한다. 플리퍼 상태(true/false) 변화 시에만 사운드를 재생하고, 사운드 관련 로직을 헬퍼 함수로 분리하여 코드 중복을 제거한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| PRD 파일 읽고 실행계획 작성 | `PRD/플리퍼-사운드-연속재생-방지-실행계획.md` | 생성 |
| 헬퍼 함수 분리 계획 추가 | `PRD/플리퍼-사운드-연속재생-방지-실행계획.md` | 수정 |
| 뗄 때 사운드 재생 요구사항 반영 | `PRD/플리퍼-사운드-연속재생-방지-실행계획.md` | 수정 |
| pressFlipperKeyRef/releaseFlipperKeyRef ref 추가 | `frontend/src/pages/Pinball/Pinball.jsx` | 수정 |
| pressFlipperKey/releaseFlipperKey 헬퍼 함수 추가 | `frontend/src/pages/Pinball/Pinball.jsx` | 수정 |
| handleKeyDown ArrowLeft/ArrowRight 헬퍼 호출로 교체 | `frontend/src/pages/Pinball/Pinball.jsx` | 수정 |
| handleTouchStart 헬퍼 호출로 교체 | `frontend/src/pages/Pinball/Pinball.jsx` | 수정 |
| handleKeyUp, handleTouchEnd 헬퍼 호출로 교체 | `frontend/src/pages/Pinball/Pinball.jsx` | 수정 |
| JSX onPointerDown/Up/Leave 헬퍼 호출로 교체 | `frontend/src/pages/Pinball/Pinball.jsx` | 수정 |

**총 1시간**

## 주요 변경 사항

### 1. Pinball.jsx 수정

**변경 전 (ref 선언):**
```javascript
const plungerStartRef = useRef(null);
const plungerReleaseRef = useRef(null);
```

**변경 후 (ref 선언):**
```javascript
const plungerStartRef = useRef(null);
const plungerReleaseRef = useRef(null);
const pressFlipperKeyRef = useRef(null);
const releaseFlipperKeyRef = useRef(null);
```

**특징:**
- 헬퍼 함수가 useEffect 내부에 선언되므로, JSX에서 접근하기 위해 ref로 노출한다.
- `plungerStartRef`와 동일한 패턴을 사용한다.

---

**변경 전 (인라인 로직):**
```javascript
// handleKeyDown
if (event.key === 'ArrowLeft') {
  isLeftKeyPressed.current = true;
  playFlipperSound(fliperSoundRef.current);
}

// handleTouchStart
isLeftKeyPressed.current = true;
playFlipperSound(fliperSoundRef.current);

// handleKeyUp
if (event.key === 'ArrowLeft') {
  isLeftKeyPressed.current = false;
}

// JSX
onPointerDown={() => { isLeftKeyPressedRef.current = true; playFlipperSound(fliperSoundRef.current); }}
onPointerUp={() => { isLeftKeyPressedRef.current = false; }}
```

**변경 후 (헬퍼 함수 + 호출):**
```javascript
// 헬퍼 함수 정의 (useEffect 내부)
const pressFlipperKey = (keyRef) => {
  if (!keyRef.current) {
    playFlipperSound(fliperSoundRef.current);
  }
  keyRef.current = true;
};
pressFlipperKeyRef.current = pressFlipperKey;

const releaseFlipperKey = (keyRef) => {
  if (keyRef.current) {
    playFlipperSound(fliperSoundRef.current);
  }
  keyRef.current = false;
};
releaseFlipperKeyRef.current = releaseFlipperKey;

// handleKeyDown
if (event.key === 'ArrowLeft') {
  pressFlipperKey(isLeftKeyPressed);
}

// handleKeyUp
if (event.key === 'ArrowLeft') {
  releaseFlipperKey(isLeftKeyPressed);
}

// JSX
onPointerDown={() => pressFlipperKeyRef.current?.(isLeftKeyPressedRef)}
onPointerUp={() => releaseFlipperKeyRef.current?.(isLeftKeyPressedRef)}
```

**특징:**
- `pressFlipperKey`: `keyRef.current`가 `false`일 때만 사운드 재생 → key repeat 중복 방지
- `releaseFlipperKey`: `keyRef.current`가 `true`일 때만 사운드 재생 → 키를 뗄 때 사운드 1회 재생
- 키보드(handleKeyDown/Up), 터치(handleTouchStart/End), 포인터(JSX) 모든 입력 경로에 동일하게 적용
- 사운드·상태 변경 로직이 헬퍼 함수 한 곳에 집중되어 추후 수정 시 한 곳만 변경하면 됨

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업

# 업무일지

## 기본 정보
- 날짜: 2026-02-14 (토) 19:00~19:50
- 작성자: hexsera

## 진행 목표
핀볼 게임의 타겟(target) 오브젝트를 실제 아케이드 핀볼 pop bumper 스타일로 시각적으로 꾸민다. 외부 링 + 방사형 그라디언트 본체 + 방사형 톱니 별 패턴 + 글로우 효과를 하늘색 계열로 구현한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| PRD 작성 | `PRD/핀볼 타겟 꾸미기prd.md` | 기존 파일 |
| 실행계획 작성 (1차: pop bumper 5레이어) | `PRD/핀볼 타겟 꾸미기-실행계획.md` | 생성 |
| stageConfigs.js 타겟 render 투명화 | `Pinball/stageConfigs.js` | Matter.js 기본 렌더링 숨김 |
| Pinball.jsx afterRender에 타겟 렌더링 추가 (1차) | `Pinball/Pinball.jsx` | pop bumper 5레이어 구조 |
| 실행계획 수정 (2차: 3단계 톱니 디자인) | `PRD/핀볼 타겟 꾸미기-실행계획.md` | 외부링+그라디언트+톱니 구조로 변경 |
| Pinball.jsx 타겟 렌더링 교체 (2차) | `Pinball/Pinball.jsx` | 3단계 디자인 적용 |
| 톱니 깊이 증가 + 내부 원 추가 + 외부 링 제거 | `Pinball/Pinball.jsx` | innerRadius 0.7→0.45, 내부 원 추가 |
| 글로우 효과 추가 | `Pinball/Pinball.jsx` | 범퍼와 동일한 2단계 글로우 구조 |


## 주요 변경 사항

### 1. stageConfigs.js 수정 — 타겟 render 투명화

**변경 전:**
```javascript
{ x: 500, y: 590, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#87CEEB' } } }
```

**변경 후:**
```javascript
{ x: 500, y: 590, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: 'transparent', opacity: 0 } } }
```

**특징:**
- Matter.js 기본 fillStyle 렌더링을 숨기고 afterRender에서 Canvas 2D API로 직접 그리도록 전환
- Stage 1, Stage 2 모든 targets에 동일 적용

### 2. Pinball.jsx 수정 — 타겟 pop bumper 렌더링 추가

**변경 전:**
```javascript
// afterRender 콜백에 타겟 렌더링 코드 없음
```

**변경 후:**
```javascript
// 타겟 pop bumper 스타일 렌더링
const targetBodies = stageBodiesRef.current.filter(b => b.label === 'target');

targetBodies.forEach((target) => {
  const { x, y } = target.position;
  const radius = target.circleRadius || 40;

  ctx.save();

  // ① 외곽 글로우 레이어 1
  ctx.beginPath();
  ctx.arc(x, y, radius + 10, 0, Math.PI * 2);
  ctx.shadowColor = '#00aaff';
  ctx.shadowBlur = 30;
  ctx.strokeStyle = 'rgba(186, 245, 255, 0.34)';
  ctx.lineWidth = 8;
  ctx.stroke();

  // ② 외곽 글로우 레이어 2
  ctx.beginPath();
  ctx.arc(x, y, radius + 3, 0, Math.PI * 2);
  ctx.shadowColor = '#33ccff';
  ctx.shadowBlur = 20;
  ctx.strokeStyle = 'rgba(93, 182, 255, 0.69)';
  ctx.lineWidth = 4;
  ctx.stroke();

  // ③ 본체 (방사형 그라디언트)
  const gradient = ctx.createRadialGradient(x, y, radius * 0.28, x, y, radius);
  gradient.addColorStop(0, '#DDFAFF');
  gradient.addColorStop(0.5, '#77DDFF');
  gradient.addColorStop(1, '#2299CC');
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle = gradient;
  ctx.fill();

  // ④ 방사형 톱니 별 패턴
  ctx.fillStyle = 'rgba(0, 120, 180, 0.55)';
  const numPoints = 16;
  const outerRadius = radius;
  const innerRadius = radius * 0.45;
  ctx.beginPath();
  for (let i = 0; i < numPoints * 2; i++) {
    const r = (i % 2 === 0) ? outerRadius : innerRadius;
    const angle = (i / (numPoints * 2)) * Math.PI * 2;
    const px = x + r * Math.cos(angle);
    const py = y + r * Math.sin(angle);
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill();

  // ⑤ 내부 원 (톱니 중앙)
  const innerCircleGrad = ctx.createRadialGradient(x, y, 0, x, y, innerRadius);
  innerCircleGrad.addColorStop(0, '#EEFAFF');
  innerCircleGrad.addColorStop(1, '#44BBEE');
  ctx.beginPath();
  ctx.arc(x, y, innerRadius, 0, Math.PI * 2);
  ctx.fillStyle = innerCircleGrad;
  ctx.fill();

  ctx.restore();
});
```

**렌더링 레이어 구조:**
```
타겟 렌더링 순서 (아래→위)
├── ① 글로우 레이어 1 (radius+10, shadowBlur 30, 넓게 번짐)
├── ② 글로우 레이어 2 (radius+3, shadowBlur 20, 중간 강도)
├── ③ 본체 원 (RadialGradient: #DDFAFF → #77DDFF → #2299CC)
├── ④ 톱니 별 패턴 (16개 톱니, innerRadius 45%, 반투명 파란색)
└── ⑤ 내부 원 (RadialGradient: #EEFAFF → #44BBEE)
```

**특징:**
- 범퍼와 동일한 `afterRender` Canvas 2D API 방식으로 타겟 렌더링
- 글로우 2단계 구조는 범퍼(빨간 글로우)와 동일, 색상만 하늘색(`#00aaff`, `#33ccff`)으로 변경
- 톱니 `innerRadius`를 `0.7 → 0.45`로 줄여 톱니가 중앙으로 깊게 파이도록 조정
- 내부 원으로 톱니 중앙부를 밝게 채워 핀볼 범퍼의 조명 효과 표현

## 결과
- 상태: 완료

## 배운내용

## 다음 작업
