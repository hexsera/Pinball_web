# 업무일지

## 기본 정보
- 날짜: 2026-02-14 (토) 12:00~1:00
- 작성자: hexsera

## 진행 목표
핀볼 게임 화면에서 발생하는 불필요한 세로 스크롤 제거 및 모바일 레이아웃 최적화

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 핀볼 세로 스크롤 제거 실행계획 작성 | `PRD/핀볼-세로스크롤-제거-실행계획.md` | 신규 생성 |
| 핀볼 세로 스크롤 제거 구현 | `PinballPage/PinballPage.jsx` | `minHeight→height`, `overflow:hidden`, marginBottom 음수 보정 |
| 핀볼 모바일 화면 개선 실행계획 작성 | `PRD/핀볼-모바일-화면-개선-실행계획.md` | 신규 생성 |
| 핀볼 모바일 레이아웃 구현 | `PinballPage/PinballPage.jsx` | 모바일 감지, 헤더 높이 측정, scale 계산 분기 |

**총 1시간 30분**

## 주요 변경 사항

### 1. PinballPage.jsx 수정 — 세로 스크롤 제거

**변경 전:**
```jsx
<Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh', backgroundColor: '#0F172A' }}>
  ...
  <Box sx={{ flexGrow: 1, display: 'flex', justifyContent: 'center', alignItems: 'flex-start', pt: 2 }}>
    <Box sx={{ transform: `scale(${gameScale})`, transformOrigin: 'top center' }}>
      <Pinball />
    </Box>
  </Box>
</Box>
```

**변경 후:**
```jsx
const scaledHeight = 1200 * gameScale;

<Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', overflow: 'hidden', backgroundColor: '#000000' }}>
  ...
  <Box sx={{ flexGrow: 1, display: 'flex', justifyContent: 'center', alignItems: 'flex-start', overflow: 'hidden', pt: 2 }}>
    <Box sx={{
      transform: `scale(${gameScale})`,
      transformOrigin: 'top center',
      width: 700,
      height: 1200,
      marginBottom: `${scaledHeight - 1200}px`,
      marginLeft: 'auto',
      marginRight: 'auto',
    }}>
      <Pinball />
    </Box>
  </Box>
</Box>
```

**특징:**
- `minHeight: '100vh'` → `height: '100vh'` + `overflow: 'hidden'` 변경으로 스크롤 원천 차단
- `transform: scale()`은 시각적 크기만 줄이고 DOM 레이아웃 공간은 원본(1200px)을 유지하는 문제를 `marginBottom` 음수 보정으로 해결
- `scale=0.7`이면 `marginBottom = (1200×0.7) - 1200 = -360px`이 되어 여분 공간 제거

### 2. PinballPage.jsx 수정 — 모바일 레이아웃 최적화

**변경 전:**
```jsx
import { useState, useEffect, useCallback } from 'react';

const calculateScale = useCallback(() => {
  const canvasWidth = 700;
  const canvasHeight = 1200;
  const padding = 120;
  const scaleByWidth = (windowSize.width - padding) / canvasWidth;
  const scaleByHeight = (windowSize.height - padding) / canvasHeight;
  setGameScale(Math.min(scaleByWidth, scaleByHeight, 1));
}, [windowSize]);
```

**변경 후:**
```jsx
import { useState, useEffect, useCallback, useRef } from 'react';
import { useTheme } from '@mui/material/styles';
import useMediaQuery from '@mui/material/useMediaQuery';

const theme = useTheme();
const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
const appBarRef = useRef(null);
const [headerHeight, setHeaderHeight] = useState(0);

useEffect(() => {
  if (appBarRef.current) {
    setHeaderHeight(appBarRef.current.offsetHeight);
  }
}, []);

const calculateScale = useCallback(() => {
  const canvasWidth = 700;
  const canvasHeight = 1200;

  if (isMobile) {
    const scaleByWidth = windowSize.width / canvasWidth;
    const scaleByHeight = (windowSize.height - headerHeight) / canvasHeight;
    setGameScale(Math.min(scaleByWidth, scaleByHeight, 1));
  } else {
    const padding = 120;
    const scaleByWidth = (windowSize.width - padding) / canvasWidth;
    const scaleByHeight = (windowSize.height - padding) / canvasHeight;
    setGameScale(Math.min(scaleByWidth, scaleByHeight, 1));
  }
}, [windowSize, isMobile, headerHeight]);
```

**특징:**
- MUI `useMediaQuery(theme.breakpoints.down('sm'))`으로 600px 이하를 모바일로 감지
- `appBarRef.current.offsetHeight`로 AppBar의 실제 렌더링 높이를 측정
- 모바일: padding 없이 뷰포트 전체를 기준으로 scale 계산 → 화면을 꽉 채움
- 데스크탑: 기존 `padding: 120` 방식 유지
- 게임 영역 상단 패딩을 `pt: isMobile ? 0 : 2`로 모바일에서 제거

## 결과
- 상태: 완료

## 배운내용


## 다음 작업

