# 업무일지

## 기본 정보
- 날짜: 2026-02-14 (토) 12:00~13:00
- 작성자: hexsera

## 진행 목표
핀볼 게임 화면에서 발생하는 불필요한 세로 스크롤 제거 및 모바일 레이아웃 최적화

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 핀볼 세로 스크롤 제거 실행계획 작성 | `PRD/핀볼-세로스크롤-제거-실행계획.md` | 신규 생성 |
| 핀볼 세로 스크롤 제거 구현 | `PinballPage/PinballPage.jsx` | `minHeight→height`, `overflow:hidden`, marginBottom 음수 보정 |
| 핀볼 모바일 화면 개선 실행계획 작성 | `PRD/핀볼-모바일-화면-개선-실행계획.md` | 신규 생성 |
| 핀볼 모바일 레이아웃 구현 | `PinballPage/PinballPage.jsx` | 모바일 감지, 헤더 높이 측정, scale 계산 분기 |

**총 1시간 30분**

## 주요 변경 사항

### 1. PinballPage.jsx 수정 — 세로 스크롤 제거

**변경 전:**
```jsx
<Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh', backgroundColor: '#0F172A' }}>
  ...
  <Box sx={{ flexGrow: 1, display: 'flex', justifyContent: 'center', alignItems: 'flex-start', pt: 2 }}>
    <Box sx={{ transform: `scale(${gameScale})`, transformOrigin: 'top center' }}>
      <Pinball />
    </Box>
  </Box>
</Box>
```

**변경 후:**
```jsx
const scaledHeight = 1200 * gameScale;

<Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', overflow: 'hidden', backgroundColor: '#000000' }}>
  ...
  <Box sx={{ flexGrow: 1, display: 'flex', justifyContent: 'center', alignItems: 'flex-start', overflow: 'hidden', pt: 2 }}>
    <Box sx={{
      transform: `scale(${gameScale})`,
      transformOrigin: 'top center',
      width: 700,
      height: 1200,
      marginBottom: `${scaledHeight - 1200}px`,
      marginLeft: 'auto',
      marginRight: 'auto',
    }}>
      <Pinball />
    </Box>
  </Box>
</Box>
```

**특징:**
- `minHeight: '100vh'` → `height: '100vh'` + `overflow: 'hidden'` 변경으로 스크롤 원천 차단
- `transform: scale()`은 시각적 크기만 줄이고 DOM 레이아웃 공간은 원본(1200px)을 유지하는 문제를 `marginBottom` 음수 보정으로 해결
- `scale=0.7`이면 `marginBottom = (1200×0.7) - 1200 = -360px`이 되어 여분 공간 제거

### 2. PinballPage.jsx 수정 — 모바일 레이아웃 최적화

**변경 전:**
```jsx
import { useState, useEffect, useCallback } from 'react';

const calculateScale = useCallback(() => {
  const canvasWidth = 700;
  const canvasHeight = 1200;
  const padding = 120;
  const scaleByWidth = (windowSize.width - padding) / canvasWidth;
  const scaleByHeight = (windowSize.height - padding) / canvasHeight;
  setGameScale(Math.min(scaleByWidth, scaleByHeight, 1));
}, [windowSize]);
```

**변경 후:**
```jsx
import { useState, useEffect, useCallback, useRef } from 'react';
import { useTheme } from '@mui/material/styles';
import useMediaQuery from '@mui/material/useMediaQuery';

const theme = useTheme();
const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
const appBarRef = useRef(null);
const [headerHeight, setHeaderHeight] = useState(0);

useEffect(() => {
  if (appBarRef.current) {
    setHeaderHeight(appBarRef.current.offsetHeight);
  }
}, []);

const calculateScale = useCallback(() => {
  const canvasWidth = 700;
  const canvasHeight = 1200;

  if (isMobile) {
    const scaleByWidth = windowSize.width / canvasWidth;
    const scaleByHeight = (windowSize.height - headerHeight) / canvasHeight;
    setGameScale(Math.min(scaleByWidth, scaleByHeight, 1));
  } else {
    const padding = 120;
    const scaleByWidth = (windowSize.width - padding) / canvasWidth;
    const scaleByHeight = (windowSize.height - padding) / canvasHeight;
    setGameScale(Math.min(scaleByWidth, scaleByHeight, 1));
  }
}, [windowSize, isMobile, headerHeight]);
```

**특징:**
- MUI `useMediaQuery(theme.breakpoints.down('sm'))`으로 600px 이하를 모바일로 감지
- `appBarRef.current.offsetHeight`로 AppBar의 실제 렌더링 높이를 측정
- 모바일: padding 없이 뷰포트 전체를 기준으로 scale 계산 → 화면을 꽉 채움
- 데스크탑: 기존 `padding: 120` 방식 유지
- 게임 영역 상단 패딩을 `pt: isMobile ? 0 : 2`로 모바일에서 제거

## 결과
- 상태: 완료

## 배운내용


## 다음 작업

# 업무일지

## 기본 정보
- 날짜: 2026-02-14 (토) 13:00~13:20
- 작성자: hexsera

## 진행 목표
핀볼 게임 로딩 시 깨진 화면이 잠깐 보이는 문제를 로딩 스피너로 가려, 게임이 완전히 준비된 후 화면에 표시되도록 개선

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 핀볼 스피너 PRD 작성 | `PRD/핀볼 스피너 prd.md` | 신규 생성 |
| 핀볼 로딩 스피너 실행계획 작성 | `PRD/핀볼-로딩-스피너-실행계획.md` | 신규 생성, PinballPage 기반 방식으로 확정 |
| `Pinball.jsx` — onReady prop 추가 | `Pinball/Pinball.jsx` | 함수 시그니처 변경, afterRender 첫 프레임 감지 |
| `PinballPage.jsx` — 스피너 오버레이 추가 | `PinballPage/PinballPage.jsx` | isReady state, CircularProgress, visibility 제어 |

**총 30분**

## 주요 변경 사항

### 1. Pinball.jsx 수정

**변경 전:**
```jsx
function Pinball() {
  ...
  Events.on(render, 'afterRender', () => {
    const ctx = render.context;
    // 범퍼 글로우 렌더링...
  });
```

**변경 후:**
```jsx
function Pinball({ onReady }) {
  ...
  let firstFrameFired = false;
  Events.on(render, 'afterRender', () => {
    if (!firstFrameFired) {
      firstFrameFired = true;
      onReady?.();
    }
    const ctx = render.context;
    // 범퍼 글로우 렌더링...
  });
```

**특징:**
- `onReady` prop을 받아 Matter.js 첫 프레임 렌더링 완료 시점에 호출
- `firstFrameFired` 지역 변수로 단 1회만 실행되도록 제한
- `onReady?.()` 옵셔널 체이닝으로 prop 미전달 시에도 에러 없이 동작

### 2. PinballPage.jsx 수정

**변경 전:**
```jsx
import { Box, AppBar, Toolbar, IconButton } from '@mui/material';
...
const [gameScale, setGameScale] = useState(1);
...
<Box sx={{ transform: `scale(${gameScale})`, ... }}>
  <Pinball />
</Box>
```

**변경 후:**
```jsx
import { Box, AppBar, Toolbar, IconButton, CircularProgress } from '@mui/material';
...
const [gameScale, setGameScale] = useState(1);
const [isReady, setIsReady] = useState(false);
...
<Box sx={{ transform: `scale(${gameScale})`, ..., position: 'relative' }}>
  <Box sx={{ visibility: isReady ? 'visible' : 'hidden' }}>
    <Pinball onReady={() => setIsReady(true)} />
  </Box>
  {!isReady && (
    <Box sx={{
      position: 'absolute', top: 0, left: 0,
      width: '100%', height: '100%',
      backgroundColor: '#000000',
      display: 'flex', justifyContent: 'center', alignItems: 'center',
      zIndex: 50,
    }}>
      <CircularProgress size={64} sx={{ color: '#e94560' }} />
    </Box>
  )}
</Box>
```

**특징:**
- `isReady` state로 스피너/게임 표시를 `PinballPage`에서 일괄 제어
- `visibility: hidden` 사용 — `display: none`이면 `sceneRef.current`가 null이 되어 Matter.js 렌더러 초기화 실패하므로 사용 불가
- 스피너는 `position: absolute`로 게임 영역 위에 덮어씌움

**컴포넌트 데이터 흐름:**
```
PinballPage
├── isReady: false → 스피너 오버레이 표시
│                    Pinball (visibility: hidden, 초기화 진행 중)
│                           │
│                    Matter.js afterRender 첫 콜백
│                           │ onReady() 호출
│                           ▼
└── isReady: true → 스피너 제거
                    Pinball (visibility: visible, 게임 표시)
```

## 결과
- 상태: 완료

## 배운내용


## 다음 작업

# 업무일지

## 기본 정보
- 날짜: 2026-02-14 (토) 18:00~18:40
- 작성자: hexsera

## 진행 목표
핀볼 게임에서 방향키를 오래 누를 때 플리퍼 사운드가 연속 재생되는 문제를 해결한다. 플리퍼 상태(true/false) 변화 시에만 사운드를 재생하고, 사운드 관련 로직을 헬퍼 함수로 분리하여 코드 중복을 제거한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| PRD 파일 읽고 실행계획 작성 | `PRD/플리퍼-사운드-연속재생-방지-실행계획.md` | 생성 |
| 헬퍼 함수 분리 계획 추가 | `PRD/플리퍼-사운드-연속재생-방지-실행계획.md` | 수정 |
| 뗄 때 사운드 재생 요구사항 반영 | `PRD/플리퍼-사운드-연속재생-방지-실행계획.md` | 수정 |
| pressFlipperKeyRef/releaseFlipperKeyRef ref 추가 | `frontend/src/pages/Pinball/Pinball.jsx` | 수정 |
| pressFlipperKey/releaseFlipperKey 헬퍼 함수 추가 | `frontend/src/pages/Pinball/Pinball.jsx` | 수정 |
| handleKeyDown ArrowLeft/ArrowRight 헬퍼 호출로 교체 | `frontend/src/pages/Pinball/Pinball.jsx` | 수정 |
| handleTouchStart 헬퍼 호출로 교체 | `frontend/src/pages/Pinball/Pinball.jsx` | 수정 |
| handleKeyUp, handleTouchEnd 헬퍼 호출로 교체 | `frontend/src/pages/Pinball/Pinball.jsx` | 수정 |
| JSX onPointerDown/Up/Leave 헬퍼 호출로 교체 | `frontend/src/pages/Pinball/Pinball.jsx` | 수정 |

**총 1시간**

## 주요 변경 사항

### 1. Pinball.jsx 수정

**변경 전 (ref 선언):**
```javascript
const plungerStartRef = useRef(null);
const plungerReleaseRef = useRef(null);
```

**변경 후 (ref 선언):**
```javascript
const plungerStartRef = useRef(null);
const plungerReleaseRef = useRef(null);
const pressFlipperKeyRef = useRef(null);
const releaseFlipperKeyRef = useRef(null);
```

**특징:**
- 헬퍼 함수가 useEffect 내부에 선언되므로, JSX에서 접근하기 위해 ref로 노출한다.
- `plungerStartRef`와 동일한 패턴을 사용한다.

---

**변경 전 (인라인 로직):**
```javascript
// handleKeyDown
if (event.key === 'ArrowLeft') {
  isLeftKeyPressed.current = true;
  playFlipperSound(fliperSoundRef.current);
}

// handleTouchStart
isLeftKeyPressed.current = true;
playFlipperSound(fliperSoundRef.current);

// handleKeyUp
if (event.key === 'ArrowLeft') {
  isLeftKeyPressed.current = false;
}

// JSX
onPointerDown={() => { isLeftKeyPressedRef.current = true; playFlipperSound(fliperSoundRef.current); }}
onPointerUp={() => { isLeftKeyPressedRef.current = false; }}
```

**변경 후 (헬퍼 함수 + 호출):**
```javascript
// 헬퍼 함수 정의 (useEffect 내부)
const pressFlipperKey = (keyRef) => {
  if (!keyRef.current) {
    playFlipperSound(fliperSoundRef.current);
  }
  keyRef.current = true;
};
pressFlipperKeyRef.current = pressFlipperKey;

const releaseFlipperKey = (keyRef) => {
  if (keyRef.current) {
    playFlipperSound(fliperSoundRef.current);
  }
  keyRef.current = false;
};
releaseFlipperKeyRef.current = releaseFlipperKey;

// handleKeyDown
if (event.key === 'ArrowLeft') {
  pressFlipperKey(isLeftKeyPressed);
}

// handleKeyUp
if (event.key === 'ArrowLeft') {
  releaseFlipperKey(isLeftKeyPressed);
}

// JSX
onPointerDown={() => pressFlipperKeyRef.current?.(isLeftKeyPressedRef)}
onPointerUp={() => releaseFlipperKeyRef.current?.(isLeftKeyPressedRef)}
```

**특징:**
- `pressFlipperKey`: `keyRef.current`가 `false`일 때만 사운드 재생 → key repeat 중복 방지
- `releaseFlipperKey`: `keyRef.current`가 `true`일 때만 사운드 재생 → 키를 뗄 때 사운드 1회 재생
- 키보드(handleKeyDown/Up), 터치(handleTouchStart/End), 포인터(JSX) 모든 입력 경로에 동일하게 적용
- 사운드·상태 변경 로직이 헬퍼 함수 한 곳에 집중되어 추후 수정 시 한 곳만 변경하면 됨

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
