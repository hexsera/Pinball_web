# 업무일지

## 기본 정보
- 날짜: 2026-02-14 (토) 12:00~13:00
- 작성자: hexsera

## 진행 목표
핀볼 게임 화면에서 발생하는 불필요한 세로 스크롤 제거 및 모바일 레이아웃 최적화

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 핀볼 세로 스크롤 제거 실행계획 작성 | `PRD/핀볼-세로스크롤-제거-실행계획.md` | 신규 생성 |
| 핀볼 세로 스크롤 제거 구현 | `PinballPage/PinballPage.jsx` | `minHeight→height`, `overflow:hidden`, marginBottom 음수 보정 |
| 핀볼 모바일 화면 개선 실행계획 작성 | `PRD/핀볼-모바일-화면-개선-실행계획.md` | 신규 생성 |
| 핀볼 모바일 레이아웃 구현 | `PinballPage/PinballPage.jsx` | 모바일 감지, 헤더 높이 측정, scale 계산 분기 |

**총 1시간 30분**

## 주요 변경 사항

### 1. PinballPage.jsx 수정 — 세로 스크롤 제거

**변경 전:**
```jsx
<Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh', backgroundColor: '#0F172A' }}>
  ...
  <Box sx={{ flexGrow: 1, display: 'flex', justifyContent: 'center', alignItems: 'flex-start', pt: 2 }}>
    <Box sx={{ transform: `scale(${gameScale})`, transformOrigin: 'top center' }}>
      <Pinball />
    </Box>
  </Box>
</Box>
```

**변경 후:**
```jsx
const scaledHeight = 1200 * gameScale;

<Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', overflow: 'hidden', backgroundColor: '#000000' }}>
  ...
  <Box sx={{ flexGrow: 1, display: 'flex', justifyContent: 'center', alignItems: 'flex-start', overflow: 'hidden', pt: 2 }}>
    <Box sx={{
      transform: `scale(${gameScale})`,
      transformOrigin: 'top center',
      width: 700,
      height: 1200,
      marginBottom: `${scaledHeight - 1200}px`,
      marginLeft: 'auto',
      marginRight: 'auto',
    }}>
      <Pinball />
    </Box>
  </Box>
</Box>
```

**특징:**
- `minHeight: '100vh'` → `height: '100vh'` + `overflow: 'hidden'` 변경으로 스크롤 원천 차단
- `transform: scale()`은 시각적 크기만 줄이고 DOM 레이아웃 공간은 원본(1200px)을 유지하는 문제를 `marginBottom` 음수 보정으로 해결
- `scale=0.7`이면 `marginBottom = (1200×0.7) - 1200 = -360px`이 되어 여분 공간 제거

### 2. PinballPage.jsx 수정 — 모바일 레이아웃 최적화

**변경 전:**
```jsx
import { useState, useEffect, useCallback } from 'react';

const calculateScale = useCallback(() => {
  const canvasWidth = 700;
  const canvasHeight = 1200;
  const padding = 120;
  const scaleByWidth = (windowSize.width - padding) / canvasWidth;
  const scaleByHeight = (windowSize.height - padding) / canvasHeight;
  setGameScale(Math.min(scaleByWidth, scaleByHeight, 1));
}, [windowSize]);
```

**변경 후:**
```jsx
import { useState, useEffect, useCallback, useRef } from 'react';
import { useTheme } from '@mui/material/styles';
import useMediaQuery from '@mui/material/useMediaQuery';

const theme = useTheme();
const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
const appBarRef = useRef(null);
const [headerHeight, setHeaderHeight] = useState(0);

useEffect(() => {
  if (appBarRef.current) {
    setHeaderHeight(appBarRef.current.offsetHeight);
  }
}, []);

const calculateScale = useCallback(() => {
  const canvasWidth = 700;
  const canvasHeight = 1200;

  if (isMobile) {
    const scaleByWidth = windowSize.width / canvasWidth;
    const scaleByHeight = (windowSize.height - headerHeight) / canvasHeight;
    setGameScale(Math.min(scaleByWidth, scaleByHeight, 1));
  } else {
    const padding = 120;
    const scaleByWidth = (windowSize.width - padding) / canvasWidth;
    const scaleByHeight = (windowSize.height - padding) / canvasHeight;
    setGameScale(Math.min(scaleByWidth, scaleByHeight, 1));
  }
}, [windowSize, isMobile, headerHeight]);
```

**특징:**
- MUI `useMediaQuery(theme.breakpoints.down('sm'))`으로 600px 이하를 모바일로 감지
- `appBarRef.current.offsetHeight`로 AppBar의 실제 렌더링 높이를 측정
- 모바일: padding 없이 뷰포트 전체를 기준으로 scale 계산 → 화면을 꽉 채움
- 데스크탑: 기존 `padding: 120` 방식 유지
- 게임 영역 상단 패딩을 `pt: isMobile ? 0 : 2`로 모바일에서 제거

## 결과
- 상태: 완료

## 배운내용


## 다음 작업

# 업무일지

## 기본 정보
- 날짜: 2026-02-14 (토) 13:00~13:20
- 작성자: hexsera

## 진행 목표
핀볼 게임 로딩 시 깨진 화면이 잠깐 보이는 문제를 로딩 스피너로 가려, 게임이 완전히 준비된 후 화면에 표시되도록 개선

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 핀볼 스피너 PRD 작성 | `PRD/핀볼 스피너 prd.md` | 신규 생성 |
| 핀볼 로딩 스피너 실행계획 작성 | `PRD/핀볼-로딩-스피너-실행계획.md` | 신규 생성, PinballPage 기반 방식으로 확정 |
| `Pinball.jsx` — onReady prop 추가 | `Pinball/Pinball.jsx` | 함수 시그니처 변경, afterRender 첫 프레임 감지 |
| `PinballPage.jsx` — 스피너 오버레이 추가 | `PinballPage/PinballPage.jsx` | isReady state, CircularProgress, visibility 제어 |

**총 30분**

## 주요 변경 사항

### 1. Pinball.jsx 수정

**변경 전:**
```jsx
function Pinball() {
  ...
  Events.on(render, 'afterRender', () => {
    const ctx = render.context;
    // 범퍼 글로우 렌더링...
  });
```

**변경 후:**
```jsx
function Pinball({ onReady }) {
  ...
  let firstFrameFired = false;
  Events.on(render, 'afterRender', () => {
    if (!firstFrameFired) {
      firstFrameFired = true;
      onReady?.();
    }
    const ctx = render.context;
    // 범퍼 글로우 렌더링...
  });
```

**특징:**
- `onReady` prop을 받아 Matter.js 첫 프레임 렌더링 완료 시점에 호출
- `firstFrameFired` 지역 변수로 단 1회만 실행되도록 제한
- `onReady?.()` 옵셔널 체이닝으로 prop 미전달 시에도 에러 없이 동작

### 2. PinballPage.jsx 수정

**변경 전:**
```jsx
import { Box, AppBar, Toolbar, IconButton } from '@mui/material';
...
const [gameScale, setGameScale] = useState(1);
...
<Box sx={{ transform: `scale(${gameScale})`, ... }}>
  <Pinball />
</Box>
```

**변경 후:**
```jsx
import { Box, AppBar, Toolbar, IconButton, CircularProgress } from '@mui/material';
...
const [gameScale, setGameScale] = useState(1);
const [isReady, setIsReady] = useState(false);
...
<Box sx={{ transform: `scale(${gameScale})`, ..., position: 'relative' }}>
  <Box sx={{ visibility: isReady ? 'visible' : 'hidden' }}>
    <Pinball onReady={() => setIsReady(true)} />
  </Box>
  {!isReady && (
    <Box sx={{
      position: 'absolute', top: 0, left: 0,
      width: '100%', height: '100%',
      backgroundColor: '#000000',
      display: 'flex', justifyContent: 'center', alignItems: 'center',
      zIndex: 50,
    }}>
      <CircularProgress size={64} sx={{ color: '#e94560' }} />
    </Box>
  )}
</Box>
```

**특징:**
- `isReady` state로 스피너/게임 표시를 `PinballPage`에서 일괄 제어
- `visibility: hidden` 사용 — `display: none`이면 `sceneRef.current`가 null이 되어 Matter.js 렌더러 초기화 실패하므로 사용 불가
- 스피너는 `position: absolute`로 게임 영역 위에 덮어씌움

**컴포넌트 데이터 흐름:**
```
PinballPage
├── isReady: false → 스피너 오버레이 표시
│                    Pinball (visibility: hidden, 초기화 진행 중)
│                           │
│                    Matter.js afterRender 첫 콜백
│                           │ onReady() 호출
│                           ▼
└── isReady: true → 스피너 제거
                    Pinball (visibility: visible, 게임 표시)
```

## 결과
- 상태: 완료

## 배운내용


## 다음 작업

