# 업무일지

## 기본 정보
- 날짜: 2026-02-11 (수) 11:30~12:00 12:30~12:40
- 작성자: hexsera

## 진행 목표
AdminUserMain.jsx의 DataGrid에 회원 수정 기능을 위한 연필 아이콘 버튼을 추가하고, 버튼 클릭 시 Dialog 팝업을 띄우는 기능 구현 (TDD 방식)

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| RED: 실패 테스트 작성 (연필 버튼 렌더링) | `src/test/AdminUserMain.test.jsx` 생성 | DataGrid mock 사용 |
| RED: 실패 테스트 작성 (Dialog 팝업) | `src/test/AdminUserMain.test.jsx` | 버튼 클릭 → Dialog open |
| Vitest CSS 에러 해결 | `vite.config.js`, `src/test/setup.js` | DataGrid mock으로 우회, 임시 코드 청소 |
| GREEN: 연필 아이콘 버튼 + Dialog 구현 | `src/pages/admin/AdminUserMain.jsx` | 테스트 2개 통과 |
| 연필 아이콘 위치 변경 (오른쪽 끝) | `src/pages/admin/AdminUserMain.jsx` | actions 컬럼을 맨 뒤로 이동 |


## 주요 변경 사항

### 1. `src/test/AdminUserMain.test.jsx` 생성

**추가:**
```jsx
// DataGrid CSS 문제 우회: @mui/x-data-grid 전체 mock
vi.mock('@mui/x-data-grid', () => ({
  DataGrid: ({ rows, columns }) => (
    <table data-testid="data-grid">
      <tbody>
        {rows.map((row) => (
          <tr key={row.id}>
            {columns.map((col) => (
              <td key={col.field}>
                {col.renderCell
                  ? col.renderCell({ row })
                  : row[col.field]}
              </td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  ),
}));

describe('AdminUserMain - 연필 아이콘 버튼', () => {
  it('각 레코드마다 연필 아이콘 버튼이 렌더링된다', async () => { ... });
  it('연필 아이콘 버튼 클릭 시 Dialog가 열린다', async () => { ... });
});
```

**특징:**
- `@mui/x-data-grid`가 내부적으로 `.css` 파일을 import하여 Vitest에서 에러 발생 → DataGrid 전체를 mock으로 교체하여 해결
- mock DataGrid는 `renderCell`을 지원하여 연필 버튼 렌더링 테스트 가능
- `axios`도 mock 처리하여 API 의존성 제거

### 2. `src/pages/admin/AdminUserMain.jsx` 수정

**변경 전:**
```jsx
const columns = [
  //{ field: 'id', headerName: 'ID', width: 70 },
  { field: 'email', headerName: '이메일', width: 200 },
  { field: 'nickname', headerName: '닉네임', width: 130 },
  { field: 'birth_date', headerName: '생년월일', width: 130 },
  { field: 'role', headerName: '역할', width: 100 },
];
```

**변경 후:**
```jsx
const columns = [
  { field: 'email', headerName: '이메일', width: 200 },
  { field: 'nickname', headerName: '닉네임', width: 130 },
  { field: 'birth_date', headerName: '생년월일', width: 130 },
  { field: 'role', headerName: '역할', width: 100 },
  {
    field: 'actions',
    headerName: '',
    width: 60,
    sortable: false,
    renderCell: (params) => (
      <IconButton
        aria-label="수정"
        size="small"
        onClick={() => handleEditClick(params.row)}
      >
        <EditIcon fontSize="small" />
      </IconButton>
    ),
  },
];
```

**특징:**
- `actions` 컬럼을 맨 오른쪽 끝에 배치
- 각 행마다 `EditIcon` 아이콘 버튼 렌더링
- 버튼 클릭 시 해당 row 데이터를 `selectedUser` 상태에 저장

**Dialog 추가:**
```jsx
// 상태 추가
const [editDialogOpen, setEditDialogOpen] = useState(false);
const [selectedUser, setSelectedUser] = useState(null);

// Dialog JSX
<Dialog open={editDialogOpen} onClose={handleDialogClose}>
  <DialogTitle>회원 수정</DialogTitle>
  <DialogContent>
    {selectedUser && (
      <Typography>
        {selectedUser.email} ({selectedUser.nickname})
      </Typography>
    )}
  </DialogContent>
  <DialogActions>
    <Button onClick={handleDialogClose}>닫기</Button>
  </DialogActions>
</Dialog>
```

### 3. `vite.config.js` 수정

**변경 전:**
```js
export default defineConfig({
  plugins: [react()],
  server: { ... },
});
```

**변경 후:**
```js
export default defineConfig({
  plugins: [react()],
  server: { ... },
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.js'],
  },
});
```

**특징:**
- Vitest 설정을 vite.config.js에 통합
- `jsdom` 환경으로 브라우저 DOM 시뮬레이션

## 결과
- 상태: 완료


## 배운 내용


## 다음 작업
- AdminUserMain.jsx Dialog에 API 연동 (GET로 폼 자동 채움, PUT으로 저장)

---

# 업무일지 2

## 기본 정보
- 날짜: 2026-02-11 (수) 12:50~13:10
- 작성자: hexsera

## 진행 목표
AdminUserMain.jsx의 Dialog 안에 유저 수정 폼 구현 (닉네임, 생년월일, 비밀번호, 역할 필드 + 저장/취소 버튼) - TDD 방식, API 연결 없음

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| RED: 닉네임 입력 필드 테스트 작성 | `src/test/AdminUserMain.test.jsx` | getByLabelText(/닉네임/i) 실패 확인 |
| GREEN: 닉네임 TextField 구현 | `src/pages/admin/AdminUserMain.jsx` | TextField label="닉네임" 추가 |
| RED: 생년월일/비밀번호/역할 필드 테스트 작성 | `src/test/AdminUserMain.test.jsx` | 3개 테스트 실패 확인 |
| GREEN: 생년월일/비밀번호/역할 필드 구현 | `src/pages/admin/AdminUserMain.jsx` | TextField 2개 + FormControl/Select 추가 |
| RED: 저장/취소 버튼 테스트 작성 | `src/test/AdminUserMain.test.jsx` | 저장 렌더링 + 취소 클릭 시 Dialog 닫힘 |
| GREEN: 저장/취소 버튼 구현 | `src/pages/admin/AdminUserMain.jsx` | 닫기 → 취소 변경, 저장 버튼 추가 |

## 주요 변경 사항

### 1. `src/test/AdminUserMain.test.jsx` 수정

**추가 (수정 폼 describe 블록):**
```jsx
describe('AdminUserMain - 수정 폼', () => {
  beforeEach(() => {
    axios.get.mockResolvedValue({ data: mockUsers });
  });

  async function openEditDialog() {
    const user = userEvent.setup();
    render(<AdminUserMain />);
    await waitFor(() => {
      expect(screen.getAllByRole('button', { name: /수정/i })).toHaveLength(mockUsers.length);
    });
    const editButtons = screen.getAllByRole('button', { name: /수정/i });
    await user.click(editButtons[0]);
    return user;
  }

  it('Dialog 안에 닉네임 입력 필드가 렌더링된다', async () => { ... });
  it('Dialog 안에 생년월일 입력 필드가 렌더링된다', async () => { ... });
  it('Dialog 안에 비밀번호 입력 필드가 렌더링된다', async () => { ... });
  it('Dialog 안에 역할 선택 필드가 렌더링된다', async () => { ... });
  it('Dialog 안에 저장 버튼이 렌더링된다', async () => { ... });
  it('취소 버튼 클릭 시 Dialog가 닫힌다', async () => { ... });
});
```

**특징:**
- `openEditDialog()` 헬퍼 함수로 Dialog 열기 과정 공유
- `취소 버튼 클릭 시 Dialog가 닫힌다` 테스트에서 MUI 애니메이션 대응을 위해 `waitFor` 사용

### 2. `src/pages/admin/AdminUserMain.jsx` 수정

**변경 전 (Dialog 내용):**
```jsx
import { ..., Button } from '@mui/material';

<Dialog open={editDialogOpen} onClose={handleDialogClose}>
  <DialogTitle>회원 수정</DialogTitle>
  <DialogContent>
    {selectedUser && (
      <Typography>
        {selectedUser.email} ({selectedUser.nickname})
      </Typography>
    )}
  </DialogContent>
  <DialogActions>
    <Button onClick={handleDialogClose}>닫기</Button>
  </DialogActions>
</Dialog>
```

**변경 후 (Dialog 내용):**
```jsx
import { ..., Button, TextField, Select, InputLabel, FormControl, MenuItem } from '@mui/material';

<Dialog open={editDialogOpen} onClose={handleDialogClose}>
  <DialogTitle>회원 수정</DialogTitle>
  <DialogContent>
    <TextField label="닉네임" fullWidth margin="dense" />
    <TextField
      label="생년월일"
      type="date"
      fullWidth
      margin="dense"
      InputLabelProps={{ shrink: true }}
    />
    <TextField label="비밀번호" type="password" fullWidth margin="dense" />
    <FormControl fullWidth margin="dense">
      <InputLabel id="role-label">역할</InputLabel>
      <Select labelId="role-label" label="역할">
        <MenuItem value="user">user</MenuItem>
        <MenuItem value="admin">admin</MenuItem>
      </Select>
    </FormControl>
  </DialogContent>
  <DialogActions>
    <Button onClick={handleDialogClose}>취소</Button>
    <Button variant="contained">저장</Button>
  </DialogActions>
</Dialog>
```

**특징:**
- 닉네임: 일반 텍스트 입력 (`TextField`)
- 생년월일: 날짜 선택 입력 (`type="date"`, `InputLabelProps={{ shrink: true }}`로 label 겹침 방지)
- 비밀번호: 비밀번호 마스킹 입력 (`type="password"`)
- 역할: `FormControl` + `Select`로 드롭다운 (user / admin 옵션)
- 기존 "닫기" 버튼 → "취소"로 변경, "저장" 버튼 신규 추가 (API 미연결)

## TDD 사이클 흐름

```
RED (닉네임 필드 테스트) → GREEN (TextField 추가)
        ↓
RED (생년월일/비밀번호/역할 테스트 3개) → GREEN (TextField 2개 + Select 추가)
        ↓
RED (저장/취소 버튼 테스트 2개) → GREEN (버튼 교체/추가)
        ↓
최종: 8개 테스트 모두 통과
```

## 결과
- 상태: 완료


## 배운 내용

## 다음 작업


---

# 업무일지 3

## 기본 정보
- 날짜: 2026-02-11 (수) 13:10~14:00
- 작성자: hexsera

## 진행 목표
AdminUserMain.jsx의 Dialog에 API를 연동한다.
1. 수정 버튼 클릭 시 GET `/api/v1/users/{user_id}`를 호출하여 닉네임, 생년월일, 역할을 폼에 자동으로 채운다. (비밀번호는 채우지 않음)
2. 저장 버튼 클릭 시 PUT `/api/v1/users/{user_id}`를 호출하여 수정된 회원 정보를 저장한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| RED: 폼 자동 채움 테스트 작성 (닉네임) | `src/test/AdminUserMain.test.jsx` | `nicknameInput.value` 가 비어있어 실패 확인 |
| GREEN: editForm state + handleEditClick에 폼 초기화 구현 | `src/pages/admin/AdminUserMain.jsx` | 행 데이터로 닉네임/생년월일/역할 채움 |
| RED: 폼 자동 채움 테스트 추가 (생년월일) | `src/test/AdminUserMain.test.jsx` | 실패 확인 |
| GREEN: 생년월일 TextField value 바인딩 | `src/pages/admin/AdminUserMain.jsx` | value + onChange 연결 |
| RED: 폼 자동 채움 테스트 추가 (역할) | `src/test/AdminUserMain.test.jsx` | MUI Select value가 undefined → 실패 확인 |
| GREEN: Select value 바인딩 | `src/pages/admin/AdminUserMain.jsx` | value + onChange 연결 |
| RED: 저장 버튼 PUT API 호출 테스트 작성 | `src/test/AdminUserMain.test.jsx` | axios.put 호출 횟수 0 → 실패 확인 |
| GREEN: handleSave 구현 (PUT 호출) | `src/pages/admin/AdminUserMain.jsx` | 빈 비밀번호 제외, try/catch 처리 |
| REFACTOR: InputLabelProps → slotProps 교체 | `src/pages/admin/AdminUserMain.jsx` | MUI v5 lint 경고 제거 |
| RED: dialog 오픈 시 GET API 호출 테스트 작성 | `src/test/AdminUserMain.test.jsx` | 행 데이터 직접 사용 → GET 미호출 → 실패 확인 |
| GREEN: handleEditClick async화, GET API 호출 추가 | `src/pages/admin/AdminUserMain.jsx` | 최신 데이터 조회 후 폼 채움 |
| REFACTOR: API Key 헤더 전체 제거 | `src/pages/admin/AdminUserMain.jsx`, `src/test/AdminUserMain.test.jsx` | 3곳 제거 |

## 주요 변경 사항

### 1. `src/pages/admin/AdminUserMain.jsx` 수정

**변경 전 (`handleEditClick` - 동기, API 미호출):**
```jsx
const handleEditClick = (user) => {
  setSelectedUser(user);
  setEditDialogOpen(true);
};
```

**변경 후 (`handleEditClick` - async, GET API 호출):**
```jsx
const [editForm, setEditForm] = useState({ nickname: '', birth_date: '', password: '', role: '' });

const handleEditClick = async (user) => {
  setSelectedUser(user);
  try {
    const response = await axios.get(`/api/v1/users/${user.id}`);
    const data = response.data;
    setEditForm({ nickname: data.nickname, birth_date: data.birth_date, password: '', role: data.role });
  } catch (error) {
    console.error('회원 정보 조회 실패:', error);
    setEditForm({ nickname: user.nickname, birth_date: user.birth_date, password: '', role: user.role });
  }
  setEditDialogOpen(true);
};
```

**특징:**
- GET API 호출 실패 시 행 데이터로 fallback하여 dialog는 정상 표시
- `editForm` state로 각 필드를 controlled component로 관리
- 비밀번호 필드는 항상 빈 문자열로 초기화 (보안)

**변경 전 (저장 버튼 - API 미연결):**
```jsx
<Button variant="contained">저장</Button>
```

**변경 후 (저장 버튼 - PUT API 연동):**
```jsx
const handleSave = async () => {
  if (!selectedUser) return;
  const body = { ...editForm };
  if (!body.password) delete body.password;
  try {
    await axios.put(`/api/v1/users/${selectedUser.id}`, body);
    handleDialogClose();
  } catch (error) {
    console.error('회원 정보 수정 실패:', error);
  }
};

<Button variant="contained" onClick={handleSave}>저장</Button>
```

**특징:**
- 비밀번호가 비어있으면 PUT body에서 제외 (변경하지 않을 때 덮어쓰기 방지)
- 저장 성공 시 dialog 자동 닫힘

**변경 전 (Dialog 폼 - uncontrolled):**
```jsx
<TextField label="닉네임" fullWidth margin="dense" />
<TextField label="생년월일" type="date" fullWidth margin="dense"
  InputLabelProps={{ shrink: true }} />
<Select labelId="role-label" label="역할">...</Select>
```

**변경 후 (Dialog 폼 - controlled):**
```jsx
<TextField label="닉네임" fullWidth margin="dense"
  value={editForm.nickname}
  onChange={(e) => setEditForm({ ...editForm, nickname: e.target.value })} />
<TextField label="생년월일" type="date" fullWidth margin="dense"
  slotProps={{ inputLabel: { shrink: true } }}
  value={editForm.birth_date}
  onChange={(e) => setEditForm({ ...editForm, birth_date: e.target.value })} />
<Select labelId="role-label" label="역할"
  value={editForm.role}
  onChange={(e) => setEditForm({ ...editForm, role: e.target.value })}>
  ...
</Select>
```

### 2. `src/test/AdminUserMain.test.jsx` 수정

**추가 (수정 폼 자동 채움 describe):**
```jsx
describe('AdminUserMain - 수정 폼 자동 채움', () => {
  beforeEach(() => {
    axios.get.mockImplementation((url) => {
      if (url === '/api/v1/users') return Promise.resolve({ data: mockUsers });
      if (url === `/api/v1/users/${mockUsers[0].id}`) return Promise.resolve({ data: mockUsers[0] });
      if (url === `/api/v1/users/${mockUsers[1].id}`) return Promise.resolve({ data: mockUsers[1] });
      return Promise.resolve({ data: {} });
    });
  });

  it('Dialog를 열면 닉네임 필드에 선택한 유저의 닉네임이 채워진다', ...);
  it('Dialog를 열면 생년월일 필드에 선택한 유저의 생년월일이 채워진다', ...);
  it('Dialog를 열면 역할 필드에 선택한 유저의 역할이 채워진다', ...);
});
```

**추가 (GET API 호출 + 저장 API 연동 describe):**
```jsx
describe('AdminUserMain - dialog 오픈 시 GET API 호출', () => {
  it('수정 버튼 클릭 시 GET /api/v1/users/{user_id}를 호출한다', async () => {
    expect(axios.get).toHaveBeenCalledWith(`/api/v1/users/${mockUsers[0].id}`);
  });
});

describe('AdminUserMain - 저장 API 연동', () => {
  it('저장 버튼 클릭 시 PUT /api/v1/users/{user_id}를 호출한다', async () => {
    expect(axios.put).toHaveBeenCalledWith(
      `/api/v1/users/${mockUsers[0].id}`,
      expect.any(Object)
    );
  });
});
```

**특징:**
- `axios.get.mockImplementation`으로 URL별 응답 분기 (목록: 배열, 단건: 객체)
- MUI Select는 `.value`로 접근 불가 → dialog `textContent` 포함 여부로 역할 검증

## TDD 사이클 흐름

```
RED (닉네임 자동 채움) → GREEN (editForm state + 닉네임 value 바인딩)
        ↓
RED (생년월일 자동 채움) → GREEN (생년월일 value 바인딩)
        ↓
RED (역할 자동 채움) → GREEN (Select value 바인딩)
        ↓
RED (저장 PUT API 호출) → GREEN (handleSave 구현)
        ↓
REFACTOR (InputLabelProps → slotProps)
        ↓
RED (dialog 오픈 시 GET API 호출) → GREEN (handleEditClick async화)
        ↓
REFACTOR (API Key 헤더 전체 제거)
        ↓
최종: 13개 테스트 모두 통과
```

## dialog 데이터 흐름

```
수정 버튼 클릭
      │
      ▼
handleEditClick(user)
      │
      ▼
GET /api/v1/users/{user.id}
      │
      ├─ 성공 → setEditForm(API 응답 데이터)
      └─ 실패 → setEditForm(행 데이터 fallback)
      │
      ▼
setEditDialogOpen(true) → Dialog 표시
      │
      ▼
사용자가 폼 수정
      │
      ▼
저장 버튼 클릭 → handleSave()
      │
      ▼
PUT /api/v1/users/{selectedUser.id}
(비밀번호 비어있으면 body에서 제외)
      │
      ├─ 성공 → handleDialogClose()
      └─ 실패 → console.error
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
