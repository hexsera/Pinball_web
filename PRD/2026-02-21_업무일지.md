# 업무일지

## 기본 정보
- 날짜: 2026-02-21 (토) 17:50~18:45
- 작성자: hexsera

## 진행 목표
기존 1인용 핀볼(`/pinball`)을 유지하면서, 같은 페이지 내에서 버튼 하나로 AI 대전 모드로 전환할 수 있는 기능 구현

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| "AI 대전" 버튼 방식으로 설계 변경 | `PRD/AI대전핀볼-실행계획.md` | 별도 라우트 → 페이지 내 토글로 수정 |
| AI 플리퍼 제어 방식 설계 변경 | `PRD/AI대전핀볼-실행계획.md` | 직접 속도 주입 → bool ref 판단/제어 분리로 수정 |
| AIPinball 컴포넌트 생성 | `frontend/src/pages/AIPinball/AIPinball.jsx` | Pinball.jsx 복사 후 수정 |
| re-export 파일 생성 | `frontend/src/pages/AIPinball/index.js` | 생성 |
| PinballPage에 AI 대전 토글 버튼 추가 | `frontend/src/pages/PinballPage/PinballPage.jsx` | 수정 |


## 주요 변경 사항

### 1. AIPinball/AIPinball.jsx 생성

Pinball.jsx를 복사 후 아래 내용을 수정/추가했다.

**제거:**
- `axios` import
- `useAuth` import 및 `user` 변수
- `bestScore` 상태(`useState`)
- `submitScore()` 함수 전체
- 게임오버 시 `submitScore()` 호출
- 게임오버 오버레이의 `최고 점수` 표시 줄

**타이틀 변경:**
```jsx
// 변경 전
PINBALL

// 변경 후
AI PINBALL
```

**안내문구 추가:**
```jsx
// SPACE 줄 아래에 추가
<Typography sx={{ color: '#aaaaaa', fontSize: '24px', mb: 4 }}>
  AI 플리퍼가 상단에서 공을 막습니다
</Typography>
```

**AI 플리퍼 각도 상수 추가:**
```javascript
const AI_LEFT_MIN_ANGLE  = -35 * Math.PI / 180;  // 올린 상태 (반시계)
const AI_LEFT_MAX_ANGLE  =  15 * Math.PI / 180;  // 내린 상태 (시계)
const AI_RIGHT_MIN_ANGLE = -15 * Math.PI / 180;  // 내린 상태 (반시계)
const AI_RIGHT_MAX_ANGLE =  35 * Math.PI / 180;  // 올린 상태 (시계)
```

**AI 플리퍼 bool ref 추가:**
```javascript
const isAILeftPressed  = { current: false };
const isAIRightPressed = { current: false };
```

**AI 플리퍼 Bodies/Constraint 추가 (기존 플리퍼의 y=995 → y=105, 좌우 반전):**
```javascript
const aiLeftFlipper  = Bodies.rectangle(400, 105, 100, 20, { ... fillStyle: '#e74c3c' });
const aiRightFlipper = Bodies.rectangle(265, 105, 100, 20, { ... fillStyle: '#e74c3c' });

const aiLeftConstraint  = Constraint.create({ bodyA: aiLeftFlipper,  pointA: { x: 40, y:0 }, pointB: { x: 440, y: 105 }, ... });
const aiRightConstraint = Constraint.create({ bodyA: aiRightFlipper, pointA: { x:-40, y:0 }, pointB: { x: 225, y: 105 }, ... });

World.add(engine.world, [..., aiLeftFlipper, aiRightFlipper, aiLeftConstraint, aiRightConstraint]);
```

**beforeUpdate에 AI 판단 + 물리 제어 추가:**
```javascript
// 판단부: bool 갱신
if (ballPos.y < AI_ACTIVATION_Y && ballVel.y < 0) {
  isAILeftPressed.current  = Math.abs(ballPos.x - AI_LEFT_CENTER_X)  < AI_REACTION_DISTANCE;
  isAIRightPressed.current = Math.abs(ballPos.x - AI_RIGHT_CENTER_X) < AI_REACTION_DISTANCE;
} else {
  isAILeftPressed.current  = false;
  isAIRightPressed.current = false;
}

// 제어부: bool 소비 (플레이어 플리퍼와 동일한 구조)
if (isAILeftPressed.current) {
  Body.setAngularVelocity(aiLeftFlipper, FLIPPER_SPEED);
} else {
  Body.setAngularVelocity(aiLeftFlipper, -FLIPPER_SPEED);
}
// ... 각도 클램핑 및 우플리퍼 동일 처리
```

**아키텍처 구조 — AI 플리퍼 판단/제어 흐름:**
```
beforeUpdate (매 프레임)
│
├─ [판단부] ball.position, ball.velocity 읽기
│       │
│       ├─ y < 300 && vy < 0  →  isAILeftPressed.current  = (거리 < 160)
│       │                         isAIRightPressed.current = (거리 < 160)
│       └─ 그 외             →  isAILeftPressed.current  = false
│                                isAIRightPressed.current = false
│
└─ [제어부] bool 읽어서 setAngularVelocity + setAngle 클램핑
         (플레이어 플리퍼 제어 패턴과 동일)
```

---

### 2. AIPinball/index.js 생성

```javascript
export { default } from './AIPinball';
```

---

### 3. PinballPage/PinballPage.jsx 수정

**import 추가:**
```jsx
// 변경 전
import { Box, AppBar, Toolbar, IconButton, CircularProgress } from '@mui/material';
import Pinball from '../Pinball';

// 변경 후
import { Box, AppBar, Toolbar, IconButton, CircularProgress, Button } from '@mui/material';
import Pinball from '../Pinball';
import AIPinball from '../AIPinball';
```

**isAIMode 상태 추가:**
```jsx
const [isAIMode, setIsAIMode] = useState(false);
```

**AppBar에 AI 대전 토글 버튼 추가:**
```jsx
// 변경 전
<IconButton onClick={() => navigate('/')} sx={{ color: '#F1F5F9' }}>
  <HomeIcon />
</IconButton>

// 변경 후
<Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
  <IconButton onClick={() => navigate('/')} sx={{ color: '#F1F5F9' }}>
    <HomeIcon />
  </IconButton>
  <Button
    onClick={() => { setIsAIMode(prev => !prev); setIsReady(false); }}
    variant={isAIMode ? 'contained' : 'outlined'}
    size="small"
    sx={{
      color: isAIMode ? '#ffffff' : '#e74c3c',
      borderColor: '#e74c3c',
      backgroundColor: isAIMode ? '#e74c3c' : 'transparent',
      '&:hover': { backgroundColor: '#c0392b', color: '#ffffff', borderColor: '#c0392b' },
    }}
  >
    {isAIMode ? 'AI 대전 ON' : 'AI 대전'}
  </Button>
</Box>
```

**게임 컴포넌트 조건부 렌더링:**
```jsx
// 변경 전
<Pinball onReady={() => setIsReady(true)} />

// 변경 후
{isAIMode
  ? <AIPinball key="ai"     onReady={() => setIsReady(true)} />
  : <Pinball   key="normal" onReady={() => setIsReady(true)} />
}
```

`key` prop을 다르게 설정하여 모드 전환 시 React가 컴포넌트를 완전히 언마운트·재마운트하도록 강제한다. 이렇게 해야 Matter.js 엔진이 초기화된다.

**아키텍처 구조 — 페이지 컴포넌트 관계:**
```
PinballPage
├── AppBar
│   ├── HomeIcon 버튼
│   ├── "AI 대전" 토글 버튼  ← 신규
│   └── HeaderUserInfo
└── 게임 영역
    ├── isAIMode === false  →  <Pinball key="normal" />   (기존)
    └── isAIMode === true   →  <AIPinball key="ai" />     ← 신규
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업


---

# 업무일지 (추가)

## 기본 정보
- 날짜: 2026-02-21 (토) 19:00~19:40
- 작성자: hexsera

## 진행 목표
AI 플립퍼의 작동 방향·각도를 player 플립퍼의 x축 반전으로 수정하고, AI 영역에 경사로를 추가하여 구조를 player 영역과 대칭으로 만들기. 디버깅을 위해 중력 반전 및 공 시작 위치 조정. aiStageConfigs 분리.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| PRD 작성 (AI 플립퍼 수정) | `PRD/AI플립퍼수정-실행계획.md` | 생성 |
| 엔진 중력 y=1 → -1 변경 | `AIPinball/AIPinball.jsx` | 디버깅용 임시 설정 |
| AI 플립퍼 각도 상수 반전 | `AIPinball/AIPinball.jsx` | player 플립퍼 x축 반전 |
| AI 플립퍼 제어 로직 회전 방향 반전 | `AIPinball/AIPinball.jsx` | setAngularVelocity 부호 반전 |
| AI 깔대기 경사로 Bodies 추가 | `AIPinball/AIPinball.jsx` | player 깔대기의 y축 대칭 위치 |
| 공 시작 위치 변경 | `AIPinball/AIPinball.jsx` | x=662 → x=60, y -200 조정 |
| aiStageConfigs.js 분리 생성 | `AIPinball/aiStageConfigs.js` | stageConfigs.js 복사 |
| AIPinball import 경로 변경 | `AIPinball/AIPinball.jsx` | `../Pinball/stageConfigs` → `./aiStageConfigs` |

## 주요 변경 사항

### 1. AIPinball.jsx 수정 — 엔진 중력

**변경 전:**
```javascript
const engine = Engine.create({
  gravity: { x: 0, y: 1 }
});
```

**변경 후:**
```javascript
const engine = Engine.create({
  gravity: { x: 0, y: -1 }  // 임시: AI 플립퍼 디버깅용
});
```

---

### 2. AIPinball.jsx 수정 — AI 플립퍼 각도 상수

player 플립퍼 각도를 x축 반전하여 AI 플립퍼가 공을 위쪽으로 타격하도록 변경.

**변경 전:**
```javascript
const AI_LEFT_MIN_ANGLE  = -35 * Math.PI / 180;  // 올린 상태
const AI_LEFT_MAX_ANGLE  =  15 * Math.PI / 180;  // 내린 상태
const AI_RIGHT_MIN_ANGLE = -15 * Math.PI / 180;  // 내린 상태
const AI_RIGHT_MAX_ANGLE =  35 * Math.PI / 180;  // 올린 상태
```

**변경 후:**
```javascript
// player Left: -35°(올림)~+15°(내림) → AI Left: -15°(내림)~+35°(올림)
// player Right: -15°(올림)~+35°(내림) → AI Right: -35°(올림)~+15°(내림)
const AI_LEFT_MIN_ANGLE  = -15 * Math.PI / 180;  // 내린 상태
const AI_LEFT_MAX_ANGLE  =  35 * Math.PI / 180;  // 올린 상태
const AI_RIGHT_MIN_ANGLE = -35 * Math.PI / 180;  // 올린 상태
const AI_RIGHT_MAX_ANGLE =  15 * Math.PI / 180;  // 내린 상태
```

---

### 3. AIPinball.jsx 수정 — AI 플립퍼 제어 로직

각도 상수 반전에 맞춰 `setAngularVelocity` 부호도 반전. 각도 제한 clamp는 속도 설정 직후 수행.

**변경 전:**
```javascript
if (isAILeftPressed.current) {
  Body.setAngularVelocity(aiLeftFlipper, FLIPPER_SPEED);   // 올리기 (시계)
} else {
  Body.setAngularVelocity(aiLeftFlipper, -FLIPPER_SPEED);  // 내리기 (반시계)
}

if (isAIRightPressed.current) {
  Body.setAngularVelocity(aiRightFlipper, -FLIPPER_SPEED); // 올리기 (반시계)
} else {
  Body.setAngularVelocity(aiRightFlipper, FLIPPER_SPEED);  // 내리기 (시계)
}
```

**변경 후:**
```javascript
if (isAILeftPressed.current) {
  Body.setAngularVelocity(aiLeftFlipper, -FLIPPER_SPEED);  // 올리기 (반시계)
} else {
  Body.setAngularVelocity(aiLeftFlipper, FLIPPER_SPEED);   // 내리기 (시계)
}

if (isAIRightPressed.current) {
  Body.setAngularVelocity(aiRightFlipper, FLIPPER_SPEED);  // 올리기 (시계)
} else {
  Body.setAngularVelocity(aiRightFlipper, -FLIPPER_SPEED); // 내리기 (반시계)
}
```

**AI 플립퍼 제어 흐름:**
```
beforeUpdate (매 프레임)
│
├─ [판단부] ball.position, ball.velocity 읽기
│       ├─ y < 300 && vy < 0  →  isAILeftPressed / isAIRightPressed = (거리 < 160)
│       └─ 그 외              →  false
│
└─ [제어부] bool → setAngularVelocity(±FLIPPER_SPEED) + setAngle clamp
         AI Left  : true → -FLIPPER_SPEED (반시계/올림), false → +FLIPPER_SPEED (시계/내림)
         AI Right : true → +FLIPPER_SPEED (시계/올림),  false → -FLIPPER_SPEED (반시계/내림)
```

---

### 4. AIPinball.jsx 수정 — AI 깔대기 경사로 추가

player 영역 하단 깔대기(y≈915~925)를 y축 대칭으로 뒤집어 AI 플립퍼(y=105) 양옆에 배치.

**추가:**
```javascript
const AI_FUNNEL_ANGLE = 35 * Math.PI / 180;
const AI_FUNNEL_THICKNESS = 20;

const aiLeftFunnelWall = Bodies.rectangle(105, 185, 260, AI_FUNNEL_THICKNESS, {
  isStatic: true,
  render: { fillStyle: '#16213e' }
});
Body.setAngle(aiLeftFunnelWall, -AI_FUNNEL_ANGLE);  // player +35° → AI -35°

const aiRightFunnelWall = Bodies.rectangle(540, 175, 220, AI_FUNNEL_THICKNESS, {
  isStatic: true,
  render: { fillStyle: '#16213e' }
});
Body.setAngle(aiRightFunnelWall, AI_FUNNEL_ANGLE);  // player -35° → AI +35°

// World.add에 추가
World.add(engine.world, [..., aiLeftFunnelWall, aiRightFunnelWall, ...]);
```

**구조 — player/AI 경사로 대칭:**
```
천장 (y=0)
────────────────────────────────
  \  aiLeftFunnelWall(-35°) /     ← AI 깔대기 (y≈175~185)
   \                        /
    [aiLeft]    [aiRight]          ← AI 플립퍼 (y=105)
────────────────────────────────
          (게임 영역)
────────────────────────────────
    [Left]      [Right]            ← player 플립퍼 (y=995)
   /                        \
  /  leftFunnelWall(+35°)    \    ← player 깔대기 (y≈915~925)
────────────────────────────────
바닥 (y=1100)
```

---

### 5. AIPinball.jsx 수정 — 공 시작 위치 변경

**변경 전:**
```javascript
const ball = Bodies.circle(662, SHELF_Y - 20, 15, { ... });
```

**변경 후:**
```javascript
const ball = Bodies.circle(60, SHELF_Y - 220, 15, { ... });
```

- x: 662(오른쪽 플런저 레인) → 60(왼쪽 벽 근처, 내면 x=40 + 여유)
- y: SHELF_Y - 20 → SHELF_Y - 220 (200px 위에서 시작)

---

### 6. aiStageConfigs.js 생성 및 import 분리

**추가: `AIPinball/aiStageConfigs.js`**

`Pinball/stageConfigs.js` 를 복사하여 AIPinball 전용 스테이지 설정 파일로 분리.

**변경 전 (AIPinball.jsx import):**
```javascript
import { STAGE_CONFIGS, BUMPER_RADIUS } from '../Pinball/stageConfigs';
```

**변경 후:**
```javascript
import { STAGE_CONFIGS, BUMPER_RADIUS } from './aiStageConfigs';
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업


# 업무일지

## 기본 정보
- 날짜: 2026-02-21 (토) 20:30~21:06
- 작성자: hexsera

## 진행 목표
AI 채팅 기능 개선 — AI 대전 모드 연동, AI 선제 메시지, 게이머 말투 설정, 스페이스바 충돌 해결

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| AI 대전 모드일 때만 채팅창 표시 | `PinballPage.jsx` | 조건부 렌더링 |
| AI 선제 메시지 로직 추가 | `ChatPanel.jsx` | 마운트 후 5초, 50% 확률 |
| 유저 선제 메시지 시 타이머 취소 | `ChatPanel.jsx` | 유저가 먼저 말 걸면 AI 선제 취소 |
| 채팅 입력창 focus 처리 | `ChatInput.jsx` | 클릭 시 input focus 이동 |
| 스페이스바 게임 조작 충돌 방지 | `Pinball.jsx`, `AIPinball.jsx` | INPUT focus 시 keydown 무시 |
| 시스템 프롬프트 개선 | `chat.py` | 반말+게이머 말투+욕설 순화+한 문장 제한 |
| AI_INIT 선제 메시지 트리거 처리 | `chat.py` | `__AI_INIT__` 수신 시 인사말 생성 |
| Gemini API 키 교체 | `backend/.env` | 새 API 키로 변경 |



## 주요 변경 사항

### 1. PinballPage.jsx 수정

**변경 전:**
```jsx
<ChatPanel />
```

**변경 후:**
```jsx
{isAIMode && <ChatPanel isAIMode={isAIMode} />}
```

**특징:**
- AI 대전 버튼 OFF 상태에서 채팅창이 DOM에서 완전히 제거됨
- `isAIMode` prop을 ChatPanel에 전달하여 내부 로직 제어

---

### 2. ChatPanel.jsx 수정

**변경 전:**
```jsx
export default function ChatPanel() {
  const [chatId, setChatId] = useState(null);
  const bottomRef = useRef(null);
  // AI 선제 메시지 로직 없음
```

**변경 후:**
```jsx
export default function ChatPanel({ isAIMode }) {
  const [chatId, setChatId] = useState(null);
  const bottomRef = useRef(null);
  const initTimerRef = useRef(null);

  // AI 선제 메시지: 마운트 후 5초 뒤 50% 확률로 AI가 먼저 대화 시작
  useEffect(() => {
    if (!isAIMode) return;
    initTimerRef.current = setTimeout(async () => {
      if (Math.random() < 0.5) {
        try {
          const { data } = await axios.post('/api/v1/chat', {
            chat_id: null,
            message: '__AI_INIT__',
          });
          setChatId(data.chat_id);
          setMessages([{ role: 'ai', content: data.reply }]);
        } catch {
          // 선제 메시지 실패 시 조용히 무시
        }
      }
    }, 5000);
    return () => clearTimeout(initTimerRef.current);
  }, [isAIMode]);

  const handleSend = async () => {
    if (!inputValue.trim() || isLoading) return;

    // 유저가 먼저 말을 걸면 AI 선제 메시지 타이머 취소
    if (initTimerRef.current) {
      clearTimeout(initTimerRef.current);
      initTimerRef.current = null;
    }
    // ...
  };
```

**특징:**
- `initTimerRef`로 타이머 ID를 보관하여 유저 선제 메시지 시 취소 가능
- 컴포넌트 언마운트 시 타이머 자동 정리 (메모리 누수 방지)

---

### 3. ChatInput.jsx 수정

**변경 전:**
```jsx
export default function ChatInput({ value, onChange, onSend, disabled }) {
  const handleKeyDown = (e) => { ... };

  return (
    <TextField
      value={value}
      onChange={onChange}
      onKeyDown={handleKeyDown}
      ...
    />
  );
}
```

**변경 후:**
```jsx
import { useRef } from 'react';

export default function ChatInput({ value, onChange, onSend, disabled }) {
  const inputRef = useRef(null);
  const handleKeyDown = (e) => { ... };

  return (
    <TextField
      inputRef={inputRef}
      onClick={() => inputRef.current?.focus()}
      value={value}
      onChange={onChange}
      onKeyDown={handleKeyDown}
      ...
    />
  );
}
```

**특징:**
- 채팅창 클릭 시 브라우저 focus가 input으로 이동
- focus 이동 덕분에 이후 스페이스바 입력이 게임이 아닌 채팅으로 전달됨

---

### 4. Pinball.jsx / AIPinball.jsx 수정

**변경 전:**
```jsx
const handleKeyDown = (event) => {
  if (!gameStartedRef.current) {
    if (event.key === ' ' || event.code === 'Space') { ... }
    return;
  }
  // ...
};
```

**변경 후:**
```jsx
const handleKeyDown = (event) => {
  // 채팅 입력창에 focus가 있으면 게임 조작 무시
  if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;

  if (!gameStartedRef.current) {
    if (event.key === ' ' || event.code === 'Space') { ... }
    return;
  }
  // ...
};
```

**특징:**
- `event.target.tagName` 검사로 채팅 input focus 여부 판별
- 기존 게임 로직 무변경, guard 조건만 상단에 추가

---

### 5. backend/app/api/v1/chat.py 수정

**변경 전:**
```python
SYSTEM_PROMPT = (
    "너는 핀볼 게임에서 사용자와 대결 중인 AI 상대방이다. "
    "경쟁자 입장에서 짧고 도발적이거나 친근하게 대화한다. "
    "핀볼 점수, 게임 전략, 승부에 관한 이야기를 한다. "
    "한국어로 대화하며, 게임 외 주제는 핀볼 대결로 돌려서 답한다."
)

# ...
response = chat_session.send_message(request.message)
```

**변경 후:**
```python
SYSTEM_PROMPT = (
    "너는 핀볼 게임에서 사용자와 대결 중인 AI 상대방이다. "
    "반말을 사용하고 흔한 게이머 말투(ㅋㅋ, ㄷㄷ, 실화냐, ㄹㅇ, 개잘함 등)를 구사해. "
    "욕설과 과한 표현은 반드시 순화해서 표현해 (예: '미친' → '헐', '개' → '엄청', '씨발' → '아씨'). "
    "핀볼 점수, 게임 전략, 승부 이야기 위주로 대화해. "
    "한국어로만 대화하고, 게임 외 주제는 핀볼 대결로 돌려서 답해. "
    "반드시 한 문장 이내로만 답해. 절대 두 문장 이상 보내지 마."
)

AI_INIT_TRIGGER = "__AI_INIT__"

# AI 선제 메시지 트리거 처리
if request.message == AI_INIT_TRIGGER:
    prompt = "대결 시작 전 상대방에게 짧은 인사를 반말 게이머 말투로 건네."
else:
    prompt = request.message

response = chat_session.send_message(prompt)
```

**특징:**
- 반말 + 게이머 말투 고정, 욕설 순화 지시 추가
- 한 문장 이내 응답 강제
- `__AI_INIT__` 트리거 수신 시 선제 인사말 생성 프롬프트로 대체

## 데이터 흐름

```
AI 대전 버튼 ON
      │
      ▼
ChatPanel 마운트
      │
      ├── 5초 타이머 시작 (initTimerRef)
      │         │
      │    유저가 먼저 채팅 입력
      │         │
      │    clearTimeout → 타이머 취소
      │
      └── 5초 후 Math.random() < 0.5 ?
               │ YES
               ▼
        POST /api/v1/chat { message: '__AI_INIT__' }
               │
               ▼
        Gemini API → 선제 인사말 생성
               │
               ▼
        채팅창에 AI 메시지 표시
```

## 결과
- 상태: 완료

## 배운내용


## 다음 작업
- 백엔드 컨테이너 재시작 후 동작 확인 (`docker compose up -d fastapi`)
- AI 선제 메시지 50% 확률 및 말투 실제 확인 테스트
