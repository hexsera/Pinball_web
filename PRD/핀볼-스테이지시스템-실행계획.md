# 핀볼 스테이지 시스템 실행계획

## 요구사항 요약

**요구사항**: 핀볼 게임에 2단계 스테이지 시스템을 도입한다. 점수 기반으로 스테이지가 전환되며, 각 스테이지마다 장애물/범퍼 배치가 다른 맵 구성을 가진다.

**목적**: 게임에 진행감과 다양성을 부여하여 플레이어의 흥미를 유지한다.

## 현재상태 분석

- `Pinball.jsx`에 모든 게임 로직이 단일 useEffect 안에 존재한다
- 장애물(obstacle1, obstacle2), 범퍼(bumper), 목표물(target)이 하드코딩된 위치로 고정되어 있다
- 스테이지 개념 없이 생명이 모두 소진되면 게임 오버된다
- 점수(score), 생명(lives) 상태가 useState/useRef로 관리되고 있다
- Matter.js World에 모든 Bodies를 한 번에 추가하고 있다

## 구현 방법

스테이지 설정 데이터를 별도 객체로 분리하고, 스테이지 전환 시 현재 맵의 장애물을 제거한 뒤 새 맵의 장애물을 추가하는 방식으로 구현한다. Matter.js World의 `World.remove()`와 `World.add()`를 사용하여 동적으로 Bodies를 교체한다.

## 구현 단계

## PHASE 1: 스테이지 데이터 분리 및 상태 관리

### 1. 스테이지 설정 데이터 파일 생성

**파일**: `frontend/src/stageConfigs.js`

```javascript
// 스테이지 설정 데이터 정의
export const STAGE_CONFIGS = {
  1: {
    name: 'Stage 1',
    targetScore: 1000,  // 이 점수 달성 시 스테이지 2로 전환
    obstacles: [
      { type: 'circle', x: 300, y: 300, radius: 30, options: { isStatic: true, render: { fillStyle: '#0f3460' } } },
      { type: 'circle', x: 500, y: 300, radius: 30, options: { isStatic: true, render: { fillStyle: '#0f3460' } } }
    ],
    bumpers: [
      { x: 400, y: 600, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e74c3c' } } }
    ],
    targets: [
      { x: 500, y: 500, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#87CEEB' } } }
    ]
  },
  2: {
    name: 'Stage 2',
    targetScore: null,  // 마지막 스테이지 (전환 없음)
    obstacles: [
      { type: 'circle', x: 200, y: 250, radius: 25, options: { isStatic: true, render: { fillStyle: '#8e44ad' } } },
      { type: 'circle', x: 400, y: 200, radius: 25, options: { isStatic: true, render: { fillStyle: '#8e44ad' } } },
      { type: 'circle', x: 500, y: 400, radius: 25, options: { isStatic: true, render: { fillStyle: '#8e44ad' } } }
    ],
    bumpers: [
      { x: 300, y: 500, radius: 35, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e74c3c' } } },
      { x: 500, y: 700, radius: 35, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e74c3c' } } }
    ],
    targets: [
      { x: 350, y: 350, radius: 35, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#87CEEB' } } },
      { x: 200, y: 600, radius: 35, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#87CEEB' } } }
    ]
  }
};
```

**Pinball.jsx**: 파일 상단에 import 추가

```javascript
import { STAGE_CONFIGS } from './stageConfigs';
```

- **무엇을 하는가**: 각 스테이지의 맵 구성(장애물, 범퍼, 목표물 위치)을 별도 파일에 데이터로 정의하고, Pinball.jsx에서 import하여 사용한다
- `targetScore`: 해당 스테이지에서 이 점수에 도달하면 다음 스테이지로 전환된다
- 마지막 스테이지(2)의 `targetScore`는 `null`이다 (전환 없음, 게임 오버까지 진행)
- 스테이지 2는 장애물 3개, 범퍼 2개, 목표물 2개로 스테이지 1보다 복잡한 맵이다
- **관심사 분리**: 게임 데이터를 별도 파일로 분리하여 맵 수정/추가 시 Pinball.jsx를 건드리지 않아도 된다
- **확장성**: 향후 스테이지 3, 4 추가 시 `stageConfigs.js`만 수정하면 된다

### 2. 스테이지 상태 추가 및 ref 추가

```javascript
// Pinball 컴포넌트 내부, 기존 useState 선언 영역
const [stage, setStage] = useState(1);
const stageRef = useRef(1);
const stageBodiesRef = useRef([]);  // 현재 스테이지의 동적 Bodies 저장
```
- **무엇을 하는가**: 현재 스테이지 번호를 관리하는 상태와, 스테이지 전환 시 제거할 Bodies 목록을 저장하는 ref를 추가한다
- `stage`/`stageRef`: 현재 스테이지 번호 (UI 표시 + 이벤트 콜백 내부 참조)
- `stageBodiesRef`: 현재 스테이지에서 추가된 장애물/범퍼/목표물 Bodies 배열. 스테이지 전환 시 이 배열의 Bodies를 World에서 제거한다

## PHASE 2: 맵 로딩 시스템 구현

### 3. 맵 로딩 함수 생성

```javascript
// useEffect 내부, World.add() 호출 전에 정의
const loadStageMap = (stageNumber) => {
  // 기존 스테이지 Bodies 제거
  if (stageBodiesRef.current.length > 0) {
    World.remove(engine.world, stageBodiesRef.current);
    stageBodiesRef.current = [];
  }

  const config = STAGE_CONFIGS[stageNumber];
  const newBodies = [];

  // 장애물 생성
  config.obstacles.forEach((obs) => {
    const body = Bodies.circle(obs.x, obs.y, obs.radius, obs.options);
    newBodies.push(body);
  });

  // 범퍼 생성
  config.bumpers.forEach((b) => {
    const body = Bodies.circle(b.x, b.y, b.radius, b.options);
    newBodies.push(body);
  });

  // 목표물 생성
  config.targets.forEach((t) => {
    const body = Bodies.circle(t.x, t.y, t.radius, t.options);
    newBodies.push(body);
  });

  // World에 추가
  World.add(engine.world, newBodies);
  stageBodiesRef.current = newBodies;
};
```
- **무엇을 하는가**: 지정된 스테이지 번호의 맵 설정에 따라 Bodies를 생성하고 World에 추가하는 함수다
- 먼저 `stageBodiesRef.current`에 저장된 이전 스테이지의 Bodies를 `World.remove()`로 제거한다
- `STAGE_CONFIGS`에서 해당 스테이지 설정을 읽어 장애물, 범퍼, 목표물을 생성한다
- 생성된 Bodies를 `stageBodiesRef.current`에 저장하여 다음 스테이지 전환 시 제거할 수 있게 한다

### 4. 기존 하드코딩된 장애물/범퍼/목표물 제거 및 초기 맵 로딩

```javascript
// 기존 코드에서 obstacle1, obstacle2, bumper, target 변수 선언 삭제
// 기존 World.add()에서 obstacle1, obstacle2, bumper, target 제거

// 기존 World.add() 변경
World.add(engine.world, [
  leftWall,
  rightWall,
  rightWall2,
  upWall,
  leftFunnelWall,
  rightFunnelWall,
  deathZone,
  ball,
  // obstacle1, obstacle2, bumper, target 제거
  leftFlipper,
  rightFlipper,
  leftFlipperConstraint,
  rightFlipperConstraint
]);

// 스테이지 1 맵 로딩
loadStageMap(1);
```
- **무엇을 하는가**: 하드코딩된 장애물/범퍼/목표물을 제거하고, `loadStageMap(1)`으로 스테이지 1 맵을 동적으로 로딩한다
- 벽, 깔대기, 죽음구역, 공, 플리퍼는 모든 스테이지에서 공통이므로 `World.add()`에 유지한다
- `obstacle1`, `obstacle2`, `bumper`, `target` 변수 선언과 `World.add()` 참조를 모두 삭제한다

## PHASE 3: 스테이지 전환 기능

### 5. 'n' 키로 스테이지 전환 테스트 (임시)

```javascript
// useEffect 내부, 기존 keydown 이벤트 리스너에 'n' 키 처리 추가
const handleKeyDown = (e) => {
  if (e.key === 'ArrowLeft') {
    isLeftKeyPressed = true;
  }
  if (e.key === 'ArrowRight') {
    isRightKeyPressed = true;
  }
  // 'n' 키로 스테이지 전환 (테스트용)
  if (e.key === 'n' || e.key === 'N') {
    const currentStage = stageRef.current;
    const nextStage = currentStage + 1;
    if (STAGE_CONFIGS[nextStage]) {
      console.log(`Stage ${currentStage} → Stage ${nextStage} (테스트)`);

      // 스테이지 전환
      stageRef.current = nextStage;
      setStage(nextStage);

      // 생명 초기화
      livesRef.current = 2;  // lives 상태는 +1이므로 ref는 2
      setLives(3);

      // 공 초기 위치로 이동
      Body.setPosition(ball, { x: 250, y: 400 });
      Body.setVelocity(ball, { x: 0, y: 0 });
      Body.setAngularVelocity(ball, 0);

      // 맵 전환
      loadStageMap(nextStage);
    } else {
      console.log('마지막 스테이지입니다');
    }
  }
};

window.addEventListener('keydown', handleKeyDown);
```
- **무엇을 하는가**: 'n' 키를 누르면 다음 스테이지로 강제 전환되도록 임시 테스트 기능을 추가한다
- 스테이지 전환 시 생명을 3개로 초기화하고, 공을 초기 위치로 리셋한다
- `loadStageMap(nextStage)`로 새 맵을 로딩한다
- 마지막 스테이지에서는 콘솔에 메시지만 출력한다
- **주의**: 이 기능은 테스트용이며, 향후 점수 기반 자동 전환으로 교체될 예정이다

## 수정/생성할 파일 목록

| 파일 경로 | 작업 유형 | 변경 내용 |
|-----------|-----------|-----------|
| frontend/src/stageConfigs.js | 생성 | 스테이지 설정 데이터 정의 (STAGE_CONFIGS 객체, 각 스테이지의 장애물/범퍼/목표물 배치 정보) |
| frontend/src/Pinball.jsx | 수정 | STAGE_CONFIGS import, 스테이지 상태/ref 추가, 맵 로딩 함수, 스테이지 전환 로직, 오버레이 UI, 상단 스테이지 표시, 하드코딩된 장애물 제거 |

## 완료 체크리스트

### PHASE 1 완료 조건
- [ ] `stageConfigs.js` 파일이 생성되고 STAGE_CONFIGS가 export된다
- [ ] `Pinball.jsx`에 STAGE_CONFIGS가 정상적으로 import된다
- [ ] 스테이지 상태(`stage`, `stageRef`, `stageBodiesRef`)가 추가된다

### PHASE 2 완료 조건
- [ ] `loadStageMap()` 함수가 정상적으로 동작한다
- [ ] 게임 시작 시 스테이지 1의 장애물/범퍼/목표물이 표시된다
- [ ] 하드코딩된 `obstacle1`, `obstacle2`, `bumper`, `target`이 제거된다

### PHASE 3 완료 조건
- [ ] 'n' 키를 누르면 스테이지 2로 전환된다
- [ ] 스테이지 전환 시 생명이 3개로 초기화된다
- [ ] 스테이지 전환 시 공이 초기 위치로 리셋된다
- [ ] 스테이지 2의 맵 구성(장애물/범퍼/목표물)이 스테이지 1과 다르다
- [ ] 스테이지 2에서 'n' 키를 눌러도 다음 스테이지가 없으면 콘솔에 메시지만 출력된다

### 전체 통합 테스트
- [ ] 스테이지 2에서 생명이 모두 소진되면 게임 오버가 된다
- [ ] 공이 죽음구역에 떨어졌을 때 기존과 동일하게 생명 차감 및 리스폰이 작동한다
