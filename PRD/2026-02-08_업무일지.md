# 업무일지

## 기본 정보
- 날짜: 2026-02-08 (일)
- 작성자: hexsera

## 진행 목표
FastAPI 프로젝트에 TDD(Test-Driven Development) 구조를 구축하여, 향후 신규 API 개발 시 테스트 주도 개발 방식을 적용할 수 있는 기반을 마련한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 실행계획 작성 | PRD/TDD-구조-생성-실행계획.md | pytest 기반 TDD 구조 설계 |
| 테스트 패키지 추가 | backend/requirements.txt | pytest, httpx 추가 |
| pytest 설정 | backend/pytest.ini | 테스트 경로 및 파일 패턴 설정 |
| 테스트 디렉토리 생성 | backend/tests/ | __init__.py, conftest.py, test_example.py, README.md |
| conftest.py 작성 | backend/tests/conftest.py | PostgreSQL 테스트 DB 설정, fixture 정의 |
| main.py 수정 | backend/main.py | startup() 함수 분리, TESTING 환경변수 처리 |
| PostgreSQL 테스트 DB 생성 | hexdb_test | 테스트 전용 데이터베이스 생성 및 권한 설정 |
| 테스트 예시 작성 | backend/tests/test_example.py | TDD 개발 순서 예시 코드 |
| TDD 가이드 작성 | backend/tests/README.md | 테스트 실행 방법 및 개발 가이드 |
| pytest 실행 검증 | - | test_health_check 통과 확인 |
| FastAPI 서버 재시작 | - | 변경사항 적용 및 정상 작동 확인 |

**총 1시간 30분**

## 주요 변경 사항

### 1. backend/requirements.txt (수정)

**추가:**
```
pytest==8.0.0
httpx==0.27.0
```

**특징:**
- pytest: Python 테스트 프레임워크 (업계 표준)
- httpx: FastAPI TestClient가 사용하는 HTTP 클라이언트

### 2. backend/pytest.ini (생성)

**추가:**
```ini
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
```

**특징:**
- pytest가 tests/ 폴더에서 test_*.py 파일을 자동 탐색
- 테스트 함수는 test_*로 시작하는 함수만 인식

### 3. backend/tests/conftest.py (생성)

**추가:**
```python
# conftest.py 최상단에 추가 (다른 import보다 먼저)
import os
os.environ["TESTING"] = "1"

import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from database import Base, get_db
from main import app

# 테스트용 PostgreSQL 데이터베이스
TEST_DATABASE_URL = "postgresql+psycopg2://hexsera:hexpoint@postgres-server:5432/hexdb_test"

test_engine = create_engine(TEST_DATABASE_URL)
TestSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)


@pytest.fixture(scope="session", autouse=True)
def setup_test_database():
    """테스트 시작 전 테이블 생성, 종료 후 삭제"""
    Base.metadata.create_all(bind=test_engine)
    yield
    Base.metadata.drop_all(bind=test_engine)


@pytest.fixture(scope="function")
def db_session():
    """각 테스트마다 트랜잭션 생성 및 롤백"""
    connection = test_engine.connect()
    transaction = connection.begin()
    session = TestSessionLocal(bind=connection)

    yield session

    session.close()
    transaction.rollback()
    connection.close()


@pytest.fixture(scope="function")
def client(db_session):
    """테스트용 FastAPI 클라이언트 (테스트 DB 사용)"""
    def override_get_db():
        try:
            yield db_session
        finally:
            pass

    app.dependency_overrides[get_db] = override_get_db
    with TestClient(app) as c:
        yield c
    app.dependency_overrides.clear()
```

**특징:**
- TESTING=1 환경변수 설정으로 main.py의 startup() 함수 실행 방지
- PostgreSQL 테스트 DB(hexdb_test) 사용
- setup_test_database: 테스트 세션 시작 시 테이블 생성, 종료 시 삭제
- db_session: 각 테스트마다 트랜잭션 시작 → 테스트 실행 → 롤백 (테스트 격리)
- client: FastAPI TestClient로 HTTP 요청 테스트 가능

### 4. backend/main.py (수정)

**변경 전:**
```python
from fastapi import FastAPI, Depends, HTTPException, status, Request
from pydantic import BaseModel
from datetime import date, datetime
from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy import or_, and_
from database import wait_for_db, engine, Base, get_db, SessionLocal
from models import User, Score, Friendship, MonthlyScore, GameVisit
from auth import verify_api_key
from seed import seed_admin


# 애플리케이션 시작 시 DB 연결 확인
if not wait_for_db():
    raise Exception("Database connection failed after retries")

# 모든 테이블 생성 (존재하지 않는 경우에만)
print("Creating database tables...")
Base.metadata.create_all(bind=engine)
print("Database tables created successfully")



# Data Seeding
print("Starting data seeding...")
db = SessionLocal()
try:
    seed_admin(db)
finally:
    db.close()
print("Data seeding completed")

app = FastAPI(title="Hexsera API", version="1.0.0")
```

**변경 후:**
```python
from fastapi import FastAPI, Depends, HTTPException, status, Request
from pydantic import BaseModel
from datetime import date, datetime
from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy import or_, and_
from database import wait_for_db, engine, Base, get_db, SessionLocal
from models import User, Score, Friendship, MonthlyScore, GameVisit
from auth import verify_api_key
from seed import seed_admin


def startup():
    """애플리케이션 시작 시 DB 초기화 및 시딩"""
    # 애플리케이션 시작 시 DB 연결 확인
    if not wait_for_db():
        raise Exception("Database connection failed after retries")

    # 모든 테이블 생성 (존재하지 않는 경우에만)
    print("Creating database tables...")
    Base.metadata.create_all(bind=engine)
    print("Database tables created successfully")

    # Data Seeding
    print("Starting data seeding...")
    db = SessionLocal()
    try:
        seed_admin(db)
    finally:
        db.close()
    print("Data seeding completed")


import os
if os.getenv("TESTING") != "1":
    startup()

app = FastAPI(title="Hexsera API", version="1.0.0")
```

**특징:**
- DB 초기화 코드를 startup() 함수로 분리
- TESTING=1 환경변수가 설정되면 startup() 실행 건너뜀
- 테스트 환경에서 main.py import 시 PostgreSQL 연결 오류 방지
- 프로덕션 환경에서는 기존과 동일하게 작동

### 5. backend/tests/test_example.py (생성)

**추가:**
```python
"""
TDD 방식으로 신규 API 개발 시 참고할 수 있는 예시 테스트 파일

TDD 개발 순서:
1. 테스트 작성 (실패하는 테스트)
2. 최소한의 코드로 테스트 통과
3. 리팩토링

예시: 새로운 /api/items 엔드포인트를 TDD로 개발한다면
"""

def test_health_check(client):
    """GET /api/ 헬스 체크 테스트 (테스트 환경 검증용)"""
    response = client.get("/api/")
    assert response.status_code == 200


# 신규 API 개발 시 아래와 같은 방식으로 테스트 작성
# 1단계: 실패하는 테스트 작성
# def test_create_item(client):
#     """POST /api/items 아이템 생성 테스트"""
#     response = client.post("/api/items", json={
#         "name": "Test Item",
#         "price": 1000
#     })
#     assert response.status_code == 201
#     assert response.json()["name"] == "Test Item"
#
# 2단계: main.py에 최소한의 코드로 엔드포인트 구현
# 3단계: 테스트 통과 확인
# 4단계: 코드 리팩토링 (필요시)
```

**특징:**
- test_health_check: 테스트 환경 검증용 기본 테스트
- 주석 처리된 예시 코드로 TDD 개발 순서 설명
- client fixture를 사용하여 HTTP 요청 테스트

### 6. backend/tests/README.md (생성)

**추가:**
```markdown
# Tests 디렉토리

이 디렉토리는 TDD(Test-Driven Development) 방식으로 신규 API를 개발하기 위한 테스트 파일을 담는다.

## TDD 개발 순서

1. **테스트 작성**: 구현하려는 API의 동작을 테스트 코드로 먼저 작성한다 (실패하는 테스트)
2. **최소 구현**: 테스트를 통과할 수 있는 최소한의 코드만 작성한다
3. **리팩토링**: 테스트가 통과하면 코드를 개선한다
4. **반복**: 새로운 기능이 필요하면 1번부터 반복한다

## 테스트 실행 방법

```bash
cd backend
pytest                    # 모든 테스트 실행
pytest tests/test_example.py  # 특정 파일만 실행
pytest -v                 # 상세 출력
pytest -k "health"        # 특정 테스트만 실행 (이름 필터)
```

## 신규 API 개발 예시

예를 들어 `/api/items` 엔드포인트를 TDD로 개발한다면:

1. `tests/test_items.py` 파일 생성
2. 실패하는 테스트 작성:
   ```python
   def test_create_item(client):
       response = client.post("/api/items", json={"name": "Item1", "price": 100})
       assert response.status_code == 201
   ```
3. `pytest` 실행 → 실패 확인
4. `main.py`에 최소 코드 작성하여 테스트 통과
5. 리팩토링 → 재테스트

## 테스트 작성 팁

- fixture 활용: `client`, `db_session`은 conftest.py에 정의되어 있음
- 테스트 격리: 각 테스트는 독립적으로 실행되며, 트랜잭션 롤백으로 DB가 자동 초기화됨
- 테스트 DB: hexdb_test 사용 (프로덕션 hexdb와 분리)

## 테스트 DB 관리

테스트는 별도의 PostgreSQL 데이터베이스(hexdb_test)를 사용합니다.

- 각 테스트는 트랜잭션 내에서 실행되고, 완료 후 자동으로 롤백됩니다
- 테스트 간 데이터 격리가 보장됩니다
- 프로덕션 DB(hexdb)에는 영향을 주지 않습니다
```

**특징:**
- TDD 개발 순서 상세 설명
- 테스트 실행 방법 가이드
- 신규 API 개발 예시 제공
- 테스트 DB 관리 방법 설명

### 7. PostgreSQL 테스트 DB 생성

**실행 명령:**
```bash
docker exec postgres-server psql -U hexsera -d postgres -c "CREATE DATABASE hexdb_test;"
docker exec postgres-server psql -U hexsera -d postgres -c "GRANT ALL PRIVILEGES ON DATABASE hexdb_test TO hexsera;"
```

**결과:**
```
 hexdb      | hexsera | UTF8     | libc            | en_US.utf8 | en_US.utf8 |
 hexdb_test | hexsera | UTF8     | libc            | en_US.utf8 | en_US.utf8 |
```

**특징:**
- 프로덕션 DB(hexdb)와 분리된 테스트 전용 DB
- 테스트 실행 시 이 DB를 사용하여 프로덕션 데이터에 영향 없음

## 아키텍처 구조

### TDD 테스트 구조
```
┌───────────────────────────────────────────┐
│         pytest 실행                       │
│  $ docker exec fastapi-server pytest     │
└────────────────┬──────────────────────────┘
                 │
                 ▼
┌───────────────────────────────────────────┐
│    conftest.py (최초 로드)                │
│  - TESTING=1 환경변수 설정                │
│  - main.py import → startup() 건너뜀     │
└────────────────┬──────────────────────────┘
                 │
                 ▼
┌───────────────────────────────────────────┐
│    setup_test_database (session)          │
│  - hexdb_test 연결                        │
│  - Base.metadata.create_all()            │
└────────────────┬──────────────────────────┘
                 │
                 ▼
┌───────────────────────────────────────────┐
│    각 테스트 함수 실행                    │
│  ┌─────────────────────────────────────┐ │
│  │ db_session fixture (function)       │ │
│  │ - transaction.begin()               │ │
│  │ - 테스트 실행                        │ │
│  │ - transaction.rollback()            │ │
│  └─────────────────────────────────────┘ │
│  ┌─────────────────────────────────────┐ │
│  │ client fixture (function)           │ │
│  │ - TestClient(app)                   │ │
│  │ - dependency_overrides[get_db]      │ │
│  └─────────────────────────────────────┘ │
└───────────────────────────────────────────┘
```

### 테스트 vs 프로덕션 환경 분기
```
main.py import
      │
      ▼
┌─────────────────────┐
│ TESTING 환경변수?   │
└──────┬──────────────┘
       │
       ├─ Yes (TESTING=1) ─────► startup() 건너뜀 ───► 테스트 환경
       │                          (테스트 DB 사용)
       │
       └─ No (미설정) ───────────► startup() 실행 ───► 프로덕션 환경
                                   (프로덕션 DB 사용)
```

## 결과
- 상태: 완료
- pytest 테스트 통과: 1 passed (test_health_check)
- FastAPI 서버 정상 작동 확인
- TDD 개발 기반 구축 완료

## 배운내용


## 다음 작업
- 기존 API 엔드포인트에 대한 테스트 코드 작성 (선택사항)
- 신규 API 개발 시 TDD 방식 적용
- 테스트 커버리지 확인 도구 도입 (pytest-cov)

## 기본 정보
- 날짜: 2026-02-08 (일)
- 작성자: hexsera

## 진행 목표


## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| TDD 스킬 작성 | - | 변경사항 적용 및 정상 작동 확인 |




## 결과
- 상태: 완료


## 배운내용
opus 너무 많이써서 token 다 떨어졌다.

## 다음 작업
- TDD 스킬 개선

## 기본 정보
- 날짜: 2026-02-08 (일) 1:30 ~ 2:30
- 작성자: hexsera

## 진행 목표


## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| RED 테스트 생성 | test_high_scores.py | |
| 최고점수 api 생성 | main.py |  |


```python
class HighScoreCreate(BaseModel):
    pass

class HighScoreResponse(BaseModel):
    pass

from typing import Dict
fake_db: Dict[int, dict] = {}
@app.post("/api/v1/high-scores", status_code=201)
```
Red 및 GREEN 진행. 리펙토링 못함
DB 연결 안되어있음 GREEN 을 위한 최소만 되어있다.


## 결과
- 상태: 완료

## 배운내용
TDD 스킬을 다듬어서 계획 문서를 작성하게끔 바꿔야겠다.

## 다음 작업
- 최고점수 DB 연결

## 기본 정보
- 날짜: 2026-02-08 (일) 3:30 ~ 4:15
- 작성자: hexsera

## 진행 목표
개인 최고기록 조회 API를 TDD 방식으로 완성하여 GET `/api/v1/high-scores` 엔드포인트를 실제 DB와 연동한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| GET API RED 테스트 작성 | backend/tests/test_high_scores.py | 12개 테스트 케이스 작성 |
| RED 검증 | - | 모든 테스트 실패 확인 (405 Method Not Allowed) |
| HighScore 모델 생성 | backend/models.py | high_scores 테이블 정의 |
| HighScoreResponse 스키마 수정 | backend/main.py | id, updated_at 필드 추가 |
| POST API DB 연동 | backend/main.py | fake_db 제거, 실제 DB 쿼리로 변경 |
| GET API 엔드포인트 생성 | backend/main.py | user_id 조회, 404/422 에러 처리 |
| GREEN 검증 | - | 모든 16개 테스트 통과 확인 |

### RED 단계 (테스트 작성)

**12개 GET API 테스트 작성:**
- 기본 성공 케이스 (6개): 200 상태코드, score/user_id/created_at/updated_at/id 필드 검증
- 에러 케이스 (4개): 404 에러, 에러 메시지, 422 파라미터 검증
- 엣지 케이스 (2개): 0점 처리, 음수 user_id 검증

**RED 검증 결과:**
```bash
# 모든 테스트 실패 (예상대로)
- 405 Method Not Allowed (GET 엔드포인트 미구현)
- KeyError: 'score', 'user_id' (응답 필드 미포함)
```

### GREEN 단계 (최소 구현)

**1. HighScore 모델 추가 (models.py:68-75)**
```python
class HighScore(Base):
    __tablename__ = "high_scores"
    id = Column(Integer, primary_key=True, autoincrement=True, index=True)
    user_id = Column(Integer, nullable=False, unique=True, index=True)
    score = Column(Integer, nullable=False, index=True)
    created_at = Column(DateTime, default=func.now(), nullable=False, index=True)
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now(), nullable=False)
```

**특징:**
- user_id에 UNIQUE 제약: 한 사용자당 하나의 최고 기록만 저장
- created_at, updated_at: 기록 생성 및 갱신 시각 자동 관리

**2. HighScoreResponse 스키마 수정 (main.py:277-284)**
```python
class HighScoreResponse(BaseModel):
    id: int
    user_id: int
    score: int
    created_at: datetime
    updated_at: datetime  # 추가
```

**3. POST API 실제 DB 연동 (main.py:786-808)**
```python
@app.post("/api/v1/high-scores", response_model=HighScoreResponse, status_code=201)
def create_or_update_high_score(payload: HighScoreCreate, db: Session = Depends(get_db)):
    existing_score = db.query(HighScore).filter(HighScore.user_id == payload.user_id).first()

    if not existing_score:
        new_high_score = HighScore(user_id=payload.user_id, score=payload.score)
        db.add(new_high_score)
        db.commit()
        db.refresh(new_high_score)
        return new_high_score

    if payload.score > existing_score.score:
        existing_score.score = payload.score
        db.commit()
        db.refresh(existing_score)

    return existing_score
```

**변경사항:**
- fake_db 제거
- 실제 PostgreSQL DB 쿼리로 변경
- 최고 기록 갱신 로직 구현 (더 높은 점수만 업데이트)

**4. GET API 엔드포인트 추가 (main.py:811-825)**
```python
@app.get("/api/v1/high-scores", response_model=HighScoreResponse)
def get_high_score(user_id: int, db: Session = Depends(get_db)):
    """사용자의 개인 최고 기록 조회"""
    if user_id < 0:
        raise HTTPException(status_code=422, detail="user_id must be positive")

    high_score = db.query(HighScore).filter(HighScore.user_id == user_id).first()

    if not high_score:
        raise HTTPException(status_code=404, detail="High score not found")

    return high_score
```

**특징:**
- 쿼리 파라미터: user_id (필수, int)
- 음수 검증: user_id < 0 → 422
- 존재하지 않는 기록: 404 에러
- FastAPI 자동 검증: 파라미터 누락, 타입 오류 → 422

**GREEN 검증 결과:**
```bash
# 전체 테스트 통과 (16개)
- POST API 테스트: 4개 통과
- GET API 테스트: 12개 통과
======================= 16 passed, 21 warnings in 6.73s =======================
```

## 주요 변경 사항

### backend/models.py
**추가:**
- HighScore 모델 (high_scores 테이블)

### backend/main.py
**수정:**
- HighScore import 추가
- HighScoreResponse 스키마에 id, updated_at 필드 추가
- POST API fake_db → 실제 DB 연동

**추가:**
- GET `/api/v1/high-scores` 엔드포인트

### backend/tests/test_high_scores.py
**추가:**
- GET API 테스트 12개 (기본 성공 케이스 6개, 에러 케이스 4개, 엣지 케이스 2개)

## 아키텍처 구조

### 데이터베이스 스키마
```sql
CREATE TABLE high_scores (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL UNIQUE,  -- 한 사용자당 하나의 기록
    score INTEGER NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_high_scores_user_id ON high_scores(user_id);
CREATE INDEX idx_high_scores_score ON high_scores(score);
CREATE INDEX idx_high_scores_created_at ON high_scores(created_at);
```

### API 엔드포인트
| 메서드 | 경로 | 설명 | 상태 코드 |
|--------|------|------|----------|
| POST | /api/v1/high-scores | 최고 기록 생성/갱신 | 201 |
| GET | /api/v1/high-scores?user_id={id} | 개인 최고 기록 조회 | 200, 404, 422 |

## 결과
- 상태: 완료

## 배운내용
현재 스킬을 끊어서 사용하기 힘들다.
TDD 스킬로 계획 작성하고, TDD RED 실행할때 스킬로 참고하라고 실행해야 안헤맨다.
그리고 테스트 실행하는법을 헷갈려한다. 도커환경에서 테스트해야한다고 해야함 ("대처법 마련해야할듯")

## 다음 작업
- Testdb 작동 확인

## 기본 정보
- 날짜: 2026-02-08 (일) 17:00~17:45
- 작성자: hexsera

## 진행 목표
친구 요청 API (`POST /api/friend-requests`)의 검증 로직을 TDD 방식으로 테스트 코드 작성 및 FK 제약조건 검증 기능을 추가한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| TDD RED 계획 작성 | PRD/친구요청-API-TDD-RED-계획.md | 8단계 테스트 계획 수립 |
| sample_users fixture 추가 | backend/tests/conftest.py | 테스트용 사용자 2명 생성 fixture |
| 친구 요청 테스트 작성 | backend/tests/test_friend_requests.py | 8개 테스트 함수 작성 |
| RED 검증 | - | 6개 통과, 2개 실패 확인 (FK 검증 미구현) |
| FK 검증 로직 구현 | backend/main.py | requester_id, receiver_id 존재 여부 확인 추가 |
| GREEN 검증 | - | 모든 8개 테스트 통과 확인 |
| DB 쿼리 최적화 (REFACTOR) | backend/main.py | FK 검증 쿼리 2회 → 1회로 감소 |
| REFACTOR 후 GREEN 검증 | - | 최적화 후에도 8개 테스트 통과 유지 |

### 작업 상세

#### 1. RED 단계 - 테스트 작성

**8개 테스트 케이스 작성:**

**회귀 방지 테스트 (기존 기능, 5개):**
1. `test_cannot_send_friend_request_to_yourself` - 자기 자신에게 요청 불가
2. `test_cannot_send_duplicate_friend_request` - 중복 요청 방지
3. `test_cannot_send_reverse_friend_request_when_pending` - 양방향 중복 (pending)
4. `test_cannot_send_reverse_friend_request_when_accepted` - 양방향 중복 (accepted)
5. `test_cannot_send_reverse_friend_request_when_rejected` - 양방향 중복 (rejected)

**신규 기능 테스트 (FK 검증, 2개):**
6. `test_requester_id_must_exist` - 존재하지 않는 requester_id 검증
7. `test_receiver_id_must_exist` - 존재하지 않는 receiver_id 검증

**정상 케이스 (1개):**
8. `test_create_friend_request_successfully` - 정상 친구 요청 생성

**RED 검증 결과:**
```bash
# 8개 테스트 중 6개 통과, 2개 실패 (예상대로)
FAILED test_requester_id_must_exist - IntegrityError (FK 제약조건 위반)
FAILED test_receiver_id_must_exist - IntegrityError (FK 제약조건 위반)
```

**실패 원인:**
- API에서 FK 검증이 없어서 DB 레벨에서 IntegrityError 발생
- 예상: HTTP 404 "Requester/Receiver user not found"
- 실제: DB FK 제약조건 위반 에러

#### 2. GREEN 단계 - 최소 구현

**FK 제약조건 검증 로직 추가 (main.py:474-488):**
```python
# FK 제약조건 검증: requester_id 존재 여부 확인
requester = db.query(User).filter(User.id == request.requester_id).first()
if not requester:
    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail="Requester user not found"
    )

# FK 제약조건 검증: receiver_id 존재 여부 확인
receiver = db.query(User).filter(User.id == request.receiver_id).first()
if not receiver:
    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail="Receiver user not found"
    )
```

**GREEN 검증 결과:**
```bash
# 모든 테스트 통과 (8개)
======================== 8 passed, 13 warnings in 7.51s ========================
```

#### 3. REFACTOR 단계 - DB 쿼리 최적화

**Before (2회 쿼리):**
```python
requester = db.query(User).filter(User.id == request.requester_id).first()
receiver = db.query(User).filter(User.id == request.receiver_id).first()
```

**After (1회 쿼리, main.py:474-487):**
```python
# FK 제약조건 검증: 두 사용자가 모두 존재하는지 확인 (1회 쿼리)
users = db.query(User).filter(User.id.in_([request.requester_id, request.receiver_id])).all()
user_ids = {user.id for user in users}

if request.requester_id not in user_ids:
    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail="Requester user not found"
    )
if request.receiver_id not in user_ids:
    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail="Receiver user not found"
    )
```

**개선 효과:**
- DB 쿼리 횟수: 2회 → 1회 (50% 감소)
- 성능 향상 (특히 네트워크 레이턴시가 있는 환경)
- 코드 간결화

**REFACTOR 후 GREEN 검증:**
```bash
# 최적화 후에도 모든 테스트 통과 (8개)
======================== 8 passed, 13 warnings in 6.46s ========================
```

## 주요 변경 사항

### backend/tests/conftest.py
**추가:**
- `sample_users` fixture (테스트용 사용자 2명 자동 생성)

### backend/tests/test_friend_requests.py
**생성:**
- TestFriendRequestValidation 클래스 (8개 테스트 메서드)

### backend/main.py
**수정:**
- `create_friend_request` 함수에 FK 검증 로직 추가
- DB 쿼리 최적화 (2회 → 1회)

## 아키텍처 구조

### 친구 요청 검증 흐름
```
POST /api/friend-requests
    │
    ├─ 1. 자기 자신 검증 (requester_id == receiver_id)
    │    └─ 400 Bad Request
    │
    ├─ 2. FK 제약조건 검증 (1회 쿼리로 두 사용자 조회)
    │    ├─ requester_id 없음 → 404 Not Found
    │    └─ receiver_id 없음 → 404 Not Found
    │
    ├─ 3. 중복 검증 (A→B 요청 존재 여부)
    │    ├─ pending → 400 "Friend request already sent"
    │    ├─ accepted → 400 "Already friends"
    │    └─ rejected → 400 "Friend request was rejected"
    │
    ├─ 4. 역방향 검증 (B→A 요청 존재 여부)
    │    ├─ pending → 400 "This user already sent you a friend request..."
    │    ├─ accepted → 400 "Already friends"
    │    └─ rejected → 400 "Cannot send friend request. Previous request was rejected."
    │
    └─ 5. 모든 검증 통과 → 200 OK (Friendship 레코드 생성)
```

### DB 제약조건 vs API 검증

| 항목 | DB 제약조건 (models.py) | API 검증 (main.py) |
|------|------------------------|-------------------|
| 자기 자신 방지 | CheckConstraint | ✅ 구현 (line 468-472) |
| 중복 방지 | UniqueConstraint | ✅ 구현 (line 490-511) |
| FK 존재 여부 | ForeignKey | ✅ 구현 (line 474-487) |

**API 검증의 필요성:**
- DB 제약조건 위반 시 IntegrityError 발생 (500 에러)
- API 검증으로 명확한 에러 메시지 제공 (400/404)
- 사용자 친화적인 에러 응답

## 결과
- 상태: 완료 

## 배운내용
코드 정리, 함수화 이런게 리팩토링인가?


## 다음 작업

