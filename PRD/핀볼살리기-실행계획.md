# 핀볼 공 부활 기능 실행계획

## 요구사항 요약

**요구사항**: 핀볼 게임에서 공이 죽음구역에 떨어지면 다시 살릴 수 있는 기능 구현

**목적**: 사용자에게 재도전 기회를 제공하여 난이도를 조절하고 입문 장벽을 낮춤

## 현재상태 분석

**현재 동작**:
- 공이 죽음구역(deathZone)에 닿으면 `World.remove(engine.world, ball)`로 월드에서 제거됨 (Pinball.jsx:222)
- 제거된 공은 다시 추가할 방법이 없어 게임이 사실상 종료됨
- 죽음구역은 `isSensor: true`로 설정되어 충돌 감지만 수행함 (Pinball.jsx:87-95)

**필요한 변경**:
- 공을 월드에서 제거하는 대신 초기 위치로 이동시키는 방식으로 변경
- 부활 횟수를 관리하는 상태 변수 추가
- 부활 가능 횟수를 UI로 표시

## 구현 방법

**기술적 접근**:
- `World.remove()` 대신 `Body.setPosition()`과 `Body.setVelocity()`를 사용하여 공을 초기 상태로 리셋
- React `useState`로 부활 횟수(lives) 관리
- `useRef`로 ball 객체에 접근하여 죽음구역 충돌 시 위치와 속도 리셋
- Material-UI Typography로 남은 생명 표시

**부활 로직**:
1. 죽음구역 충돌 감지 시 lives 확인
2. lives > 0이면 공 위치/속도 리셋 후 lives - 1
3. lives === 0이면 게임 오버 처리

## 구현 단계

### 1. ball 객체를 useRef로 관리

```javascript
const ballRef = useRef(null);

// useEffect 내부에서 ball 생성 후
const ball = Bodies.circle(250, 400, 15, {
  restitution: 0.8,
  friction: 0,
  frictionAir: 0,
  render: { fillStyle: '#e94560' }
});

ballRef.current = ball;  // ref에 저장
```

- `ballRef`로 ball 객체를 컴포넌트 전역에서 접근 가능하게 만듦
- 충돌 이벤트 핸들러에서 ball의 위치/속도를 변경하기 위해 필요

### 2. lives 상태 및 livesRef 추가

```javascript
const [lives, setLives] = useState(3);  // 초기 생명 3개 (UI 표시용)
const livesRef = useRef(3);  // 이벤트 리스너에서 최신 lives 값 참조용
```

- `lives`: UI 표시 및 React 상태 관리용
- `livesRef`: 이벤트 리스너 내부에서 최신 lives 값을 읽기 위한 ref
- 초기값은 모두 3으로 설정 (조정 가능)

### 3. 죽음구역 충돌 이벤트 수정 (공 부활 로직)

```javascript
// 죽음구역 충돌 감지 (기존 코드 수정)
if ((bodyA.label === 'deathZone' && bodyB === ball) ||
    (bodyB.label === 'deathZone' && bodyA === ball)) {
  console.log('Ball entered death zone!');

  // livesRef로 최신 lives 값 확인
  if (livesRef.current > 0) {
    // 공을 초기 위치로 이동
    Body.setPosition(ball, { x: 250, y: 400 });

    // 속도 초기화
    Body.setVelocity(ball, { x: 0, y: 0 });

    // 각속도 초기화 (회전 방지)
    Body.setAngularVelocity(ball, 0);

    // lives 감소 (상태와 ref 모두 업데이트)
    const newLives = livesRef.current - 1;
    livesRef.current = newLives;
    setLives(newLives);

    console.log(`Ball revived! Lives remaining: ${newLives}`);
  } else {
    // 생명이 없으면 공 제거 (게임 오버)
    World.remove(engine.world, ball);
    console.log('Game Over!');
  }
}
```

- `World.remove()` 호출을 조건부로 변경 (livesRef.current === 0일 때만)
- 조건문에서 `lives` 대신 `livesRef.current` 사용 (클로저 문제 해결)
- `Body.setPosition()`으로 공을 초기 위치 (250, 400)로 이동
- `Body.setVelocity()`로 속도를 (0, 0)으로 초기화하여 정지 상태로 만듦
- `Body.setAngularVelocity(0)`으로 회전도 초기화
- lives 감소: `livesRef.current - 1`을 계산하여 `livesRef.current`와 `setLives()` 모두 업데이트
- livesRef 체크를 먼저 하고 부활 처리 수행

**`setLives(prev => prev - 1)` 설명**:
- React의 함수형 상태 업데이트 패턴
- `prev`는 이전(previous) 상태값을 나타내는 매개변수
- React가 가장 최신의 lives 값을 `prev`에 전달하여 정확한 상태 업데이트 보장
- `setLives(lives - 1)` 대신 사용하는 이유: 이벤트 리스너가 useEffect 내부에서 등록되어 `lives` 변수가 초기값(3)으로 고정되는 클로저 문제 발생
- 함수형 업데이트를 사용하면 의존성 배열에 `lives`를 추가하지 않아도 정확한 감소 동작 수행 (3 → 2 → 1 → 0)
- 직접 값 사용 시 문제: `setLives(lives - 1)`은 항상 `3 - 1 = 2`만 반복되어 lives가 제대로 감소하지 않음

**실제 발생한 문제와 해결 방법**:
- 문제: `setLives(prev => prev - 1)`로 내부 상태는 감소하지만, `if (lives > 0)` 조건문의 `lives`는 여전히 3으로 고정되어 계속 부활함
- 원인: 조건문에서 사용하는 `lives` 변수도 클로저에 의해 초기값(3)으로 고정됨
- 해결 방법 1: `livesRef`를 사용하여 최신 lives 값을 ref로 관리하고 조건문에서 `livesRef.current` 사용
- 해결 방법 2: `useEffect`의 의존성 배열에 `lives`를 추가하여 lives가 변경될 때마다 이벤트 리스너 재등록 (비효율적)
- 권장: 방법 1 (ref 사용)

## 다음 스텝 (별도 PRD)

### Lives UI 표시 기능
- 좌측 상단에 "LIVES: X" UI 추가
- 점수 UI와 동일한 스타일 적용
- 부활 시 실시간으로 lives 값 갱신 표시

### 게임 오버 UI 표시 기능
- lives가 0이 되면 화면 중앙에 "GAME OVER" 메시지 표시
- 최종 점수(Final Score) 표시
- 재시작 버튼 추가 (선택 사항)

## 수정/생성할 파일 목록

| 파일 경로 | 작업 유형 | 변경 내용 |
|-----------|-----------|-----------|
| react/main/src/Pinball.jsx | 수정 | ballRef useRef 추가, lives 상태 추가, livesRef useRef 추가, 죽음구역 충돌 로직 수정 (livesRef.current 사용) |

## 완료 체크리스트

- [o] 공이 죽음구역에 떨어지면 초기 위치(250, 400)로 돌아오는지 확인
- [o] 부활 시 속도가 0으로 초기화되어 정지 상태로 시작하는지 확인
- [o] 부활할 때마다 lives가 1씩 감소하는지 확인 (콘솔 로그로 확인)
- [o] lives가 0이 되면 공이 제거되고 더 이상 부활하지 않는지 확인
- [o] 게임 오버 시 콘솔에 "Game Over!" 로그가 출력되는지 확인
- [o] 에러 없이 게임이 정상 작동하는지 확인
