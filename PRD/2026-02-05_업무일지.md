# 업무일지

## 기본 정보
- 날짜: 2026-02-05 (수) 10:20~11:27 3:00~4:00
- 작성자: hexsera

## 진행 목표
MySQL에서 PostgreSQL로 데이터베이스 환경 마이그레이션 (MySQL 컨테이너 유지)

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| PostgreSQL 드라이버 추가 | backend/requirements.txt | psycopg2-binary==2.9.9 추가 |
| PostgreSQL Docker 서비스 추가 | docker-compose.yml | postgres 서비스, healthcheck, volume 추가 |
| DATABASE_URL 환경변수 추가 | backend/.env, backend/.env.example | PostgreSQL 연결 문자열 |
| 데이터베이스 설정 단순화 | backend/database.py | DATABASE_URL 환경변수로 변경 |
| Settings 클래스 단순화 | backend/app/core/config.py | DATABASE_URL 환경변수로 변경 |
| Alembic 설정 단순화 | backend/alembic/env.py | DATABASE_URL 환경변수로 변경 |
| FastAPI depends_on 변경 | docker-compose.yml | mysql → postgres |
| MySQL 마이그레이션 백업 | backend/alembic/versions/ → versions_mysql_backup/ | 기존 마이그레이션 보존 |
| PostgreSQL 초기 마이그레이션 | backend/alembic/versions/92671f4e4bf1_initial_postgresql_migration.py | autogenerate로 생성 |
| 마이그레이션 적용 | PostgreSQL hexdb | 6개 테이블 생성 |

## 주요 변경 사항

### 1. backend/requirements.txt 수정

**변경 후:**
```txt
fastapi==0.109.0
uvicorn[standard]==0.27.0
sqlalchemy==2.0.25
pymysql==1.1.0
psycopg2-binary==2.9.9
cryptography
python-dotenv
alembic==1.13.1
```

**특징:**
- psycopg2-binary 추가 (PostgreSQL 드라이버)
- MySQL 드라이버(pymysql) 유지 (백업용)

### 2. docker-compose.yml 수정

**추가: PostgreSQL 서비스**
```yaml
postgres:
  image: postgres:16
  container_name: postgres-server
  restart: always
  environment:
    POSTGRES_DB: hexdb
    POSTGRES_USER: hexsera
    POSTGRES_PASSWORD: hexpoint
  ports:
    - "5432:5432"
  volumes:
    - postgres-data:/var/lib/postgresql/data
  healthcheck:
    test: ["CMD-SHELL", "pg_isready -U hexsera -d hexdb"]
    interval: 5s
    timeout: 5s
    retries: 10
  networks:
    - web
```

**수정: FastAPI depends_on**
```yaml
fastapi:
  depends_on:
    - postgres  # mysql → postgres로 변경
```

**추가: volumes 섹션**
```yaml
volumes:
  postgres-data:
```

**특징:**
- PostgreSQL 16 이미지 사용
- MySQL과 동일한 DB명, 사용자명, 비밀번호
- healthcheck로 연결 가능 상태 확인 (pg_isready)
- FastAPI가 PostgreSQL 시작 대기

### 3. backend/.env 수정

**변경 후:**
```env
# Database Configuration (PostgreSQL)
DATABASE_URL=postgresql+psycopg2://hexsera:hexpoint@postgres-server:5432/hexdb

# Database Configuration (MySQL - Backup)
MYSQL_HOST=mysql-server
MYSQL_PORT=3306
MYSQL_DATABASE=hexdb
MYSQL_USER=hexsera
MYSQL_PASSWORD=hexpoint

# API Key
API_KEY=hexsera-secret-api-key-2026

# Admin Account Seed Data
ADMIN_EMAIL=admin@hexsera.com
ADMIN_NICKNAME=admin
ADMIN_PASSWORD=admin_secure_password_2026
ADMIN_BIRTH_DATE=2000-01-01
```

**특징:**
- DATABASE_URL 환경변수 추가 (PostgreSQL 연결 문자열)
- 형식: `postgresql+psycopg2://사용자:비밀번호@호스트:포트/데이터베이스명`
- MySQL 설정은 백업용으로 유지

### 4. backend/database.py 수정

**변경 전:**
```python
DATABASE_URL = f"mysql+pymysql://{os.getenv('MYSQL_USER')}:{os.getenv('MYSQL_PASSWORD')}@{os.getenv('MYSQL_HOST')}:{os.getenv('MYSQL_PORT')}/{os.getenv('MYSQL_DATABASE')}"
```

**변경 후:**
```python
DATABASE_URL = os.getenv("DATABASE_URL")
```

**특징:**
- f-string 조합 제거
- 단일 환경변수로 간소화
- .env 파일만 수정하면 DB 전환 가능

### 5. backend/app/core/config.py 수정

**변경 전:**
```python
class Settings:
    # Database
    DB_HOST: str = os.getenv("MYSQL_HOST")
    DB_PORT: int = int(os.getenv("MYSQL_PORT", 3306))
    DB_NAME: str = os.getenv("MYSQL_DATABASE")
    DB_USER: str = os.getenv("MYSQL_USER")
    DB_PASSWORD: str = os.getenv("MYSQL_PASSWORD")

    @property
    def database_url(self) -> str:
        return f"mysql+pymysql://{self.DB_USER}:{self.DB_PASSWORD}@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}"
```

**변경 후:**
```python
class Settings:
    """애플리케이션 설정"""
    # Database
    DATABASE_URL: str = os.getenv("DATABASE_URL")

    # API Key
    API_KEY: str = os.getenv("API_KEY")

    # Admin Seeding
    ADMIN_EMAIL: str = os.getenv("ADMIN_EMAIL")
    ADMIN_NICKNAME: str = os.getenv("ADMIN_NICKNAME")
    ADMIN_PASSWORD: str = os.getenv("ADMIN_PASSWORD")
    ADMIN_BIRTH_DATE: str = os.getenv("ADMIN_BIRTH_DATE")
```

**특징:**
- 개별 DB_* 변수 제거
- @property 메서드 제거
- 코드가 간결해지고 DATABASE_URL만 관리

### 6. backend/alembic/env.py 수정

**변경 전:**
```python
MYSQL_USER = os.getenv("MYSQL_USER")
MYSQL_PASSWORD = os.getenv("MYSQL_PASSWORD")
MYSQL_HOST = os.getenv("MYSQL_HOST")
MYSQL_PORT = os.getenv("MYSQL_PORT")
MYSQL_DATABASE = os.getenv("MYSQL_DATABASE")

DATABASE_URL = f"mysql+pymysql://{MYSQL_USER}:{MYSQL_PASSWORD}@{MYSQL_HOST}:{MYSQL_PORT}/{MYSQL_DATABASE}"
config.set_main_option('sqlalchemy.url', DATABASE_URL)
```

**변경 후:**
```python
DATABASE_URL = os.getenv("DATABASE_URL")
config.set_main_option('sqlalchemy.url', DATABASE_URL)
```

**특징:**
- 5개의 환경변수를 1개로 통합
- Alembic이 환경변수 DATABASE_URL 사용
- .env 파일만 수정하면 모든 파일에 자동 반영

### 7. backend/alembic/versions/92671f4e4bf1_initial_postgresql_migration.py 생성

**명령어:**
```bash
docker exec fastapi-server alembic revision --autogenerate -m "initial postgresql migration"
docker exec fastapi-server alembic upgrade head
```

**생성된 테이블:**
- users (id, email, nickname, password, birth_date, role)
- scores (id, user_id, score, created_at)
- friendships (id, user_id, friend_user_id, status, created_at)
- monthly_scores (id, user_id, year, month, score, updated_at)
- game_visits (id, user_id, visit_date, visit_count)
- alembic_version (version_num)

**특징:**
- autogenerate로 models.py 기반 자동 생성
- MySQL 마이그레이션은 versions_mysql_backup/에 백업
- PostgreSQL 전용 초기 마이그레이션

## 아키텍처 변경

### 마이그레이션 전 (MySQL)
```
┌─────────────────────────────────┐
│      FastAPI                    │
│  - depends_on: mysql            │
└────────────┬────────────────────┘
             │ DATABASE_URL (f-string 조합)
             ▼
┌─────────────────────────────────┐
│      MySQL 8.0                  │
│  - mysql-server:3306            │
│  - pymysql 드라이버             │
└─────────────────────────────────┘
```

### 마이그레이션 후 (PostgreSQL)
```
┌─────────────────────────────────┐
│      FastAPI                    │
│  - depends_on: postgres         │
└────────────┬────────────────────┘
             │ DATABASE_URL (환경변수)
             ▼
┌─────────────────────────────────┐
│      PostgreSQL 16              │
│  - postgres-server:5432         │
│  - psycopg2-binary 드라이버     │
└─────────────────────────────────┘

┌─────────────────────────────────┐
│      MySQL 8.0 (백업)           │
│  - mysql-server:3306            │
│  - 컨테이너 유지                │
└─────────────────────────────────┘
```

## 발생한 문제 및 해결

### 1. ModuleNotFoundError: No module named 'psycopg2'

**원인:**
- requirements.txt에 psycopg2-binary 추가했지만 Docker 이미지 미재빌드
- Docker는 Dockerfile 기반으로 이미지를 캐싱
- requirements.txt 변경만으로는 자동 재설치 안됨

**해결:**
```bash
docker compose stop fastapi
docker compose rm -f fastapi
docker compose up -d --build fastapi
```

**특징:**
- `--build` 플래그로 이미지 강제 재빌드
- `RUN pip install -r requirements.txt` 단계에서 psycopg2-binary 설치됨

### 2. DATABASE_URL 코드 중복

**원인:**
- database.py, config.py, alembic/env.py에서 각각 f-string으로 조합
- 3개 파일에 동일한 로직 반복

**해결:**
- DATABASE_URL을 환경변수로 통합
- .env 파일에서 한 번만 정의
- 모든 파일에서 `os.getenv("DATABASE_URL")` 사용

**특징:**
- 코드 중복 제거 (DRY 원칙)
- .env 파일만 수정하면 모든 곳에 자동 반영
- 유지보수 편의성 향상


## 결과
- 상태: 완료


## 배운내용


## 다음 작업

## 기본 정보
- 날짜: 2026-02-05 (수) 16:00~17:10
- 작성자: hexsera

## 진행 목표
MySQL 데이터베이스의 모든 테이블 데이터를 PostgreSQL로 마이그레이션하여 운영 환경을 통일하고 기존 사용자 데이터를 보존

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 실행계획 작성 | PRD/mysql-postgresql-데이터마이그레이션-실행계획.md | Model 기반 마이그레이션 방식으로 설계 |
| 마이그레이션 스크립트 생성 | backend/migrate_data.py | SQLAlchemy ORM 사용 |
| 데이터 마이그레이션 실행 | - | 447건 데이터 이동 완료 |
| PostgreSQL 시퀀스 초기화 | - | 5개 테이블 시퀀스 동기화 |
| 데이터 검증 | - | MySQL vs PostgreSQL 일치 확인 |
| FastAPI 테스트 | - | PostgreSQL 연결 정상 작동 확인 |


## 주요 변경 사항

### 1. PRD/mysql-postgresql-데이터마이그레이션-실행계획.md 생성

**추가:**
```markdown
# MySQL → PostgreSQL 데이터 마이그레이션 실행계획

## 구현 방법

**마이그레이션 전략**:
1. **SQLAlchemy ORM 방식**: models.py의 Model 클래스를 사용하여 MySQL → PostgreSQL 데이터 복사
2. **장점**: 타입 자동 변환, 컬럼 정보 자동 추출, 테이블 구조 변경 시 스크립트 수정 불필요
3. **단계**: 양쪽 DB 세션 생성 → Model 기반 데이터 조회 → 데이터 복사 → 검증
```

**특징:**
- Model 기반 방식 채택 (컬럼 자동 추출, 유지보수 용이)
- 딕셔너리 변환 방식으로 세션 간 데이터 전달 (DetachedInstanceError 방지)
- 시퀀스 초기화 단계 포함 (AUTO_INCREMENT 동기화)
- 5단계 구현 절차 (스크립트 생성 → 실행 → 시퀀스 초기화 → alembic 동기화 → MySQL 중단)

### 2. backend/migrate_data.py 생성

**추가:**
```python
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv
from models import User, Score, Friendship, MonthlyScore, GameVisit

load_dotenv()

# MySQL 연결
MYSQL_URL = f"mysql+pymysql://{os.getenv('MYSQL_USER')}:{os.getenv('MYSQL_PASSWORD')}@{os.getenv('MYSQL_HOST')}:{os.getenv('MYSQL_PORT')}/{os.getenv('MYSQL_DATABASE')}"
mysql_engine = create_engine(MYSQL_URL)
MySQLSession = sessionmaker(bind=mysql_engine)

# PostgreSQL 연결
POSTGRES_URL = os.getenv("DATABASE_URL")
postgres_engine = create_engine(POSTGRES_URL)
PostgresSession = sessionmaker(bind=postgres_engine)

def migrate_model(model_class):
    """Model 기반으로 데이터를 MySQL에서 PostgreSQL로 복사"""
    table_name = model_class.__tablename__
    print(f"\n[{table_name}] 마이그레이션 시작...")

    # MySQL에서 데이터 읽기
    mysql_session = MySQLSession()
    try:
        rows = mysql_session.query(model_class).all()
        print(f"  - MySQL에서 {len(rows)}건 읽기 완료")

        if len(rows) == 0:
            print(f"  - {table_name} 테이블에 데이터가 없습니다.")
            return

        # 객체를 딕셔너리로 변환 (새 세션에서 사용하기 위해)
        row_dicts = []
        for row in rows:
            row_dict = {col.name: getattr(row, col.name) for col in model_class.__table__.columns}
            row_dicts.append(row_dict)
    finally:
        mysql_session.close()

    # PostgreSQL에 데이터 삽입
    postgres_session = PostgresSession()
    try:
        # 기존 데이터 삭제
        postgres_session.query(model_class).delete()
        print(f"  - PostgreSQL 기존 데이터 삭제 완료")

        # 새 데이터 삽입
        for row_dict in row_dicts:
            new_obj = model_class(**row_dict)
            postgres_session.add(new_obj)

        postgres_session.commit()
        print(f"  - PostgreSQL에 {len(row_dicts)}건 삽입 완료")
    except Exception as e:
        postgres_session.rollback()
        raise e
    finally:
        postgres_session.close()

def main():
    print("=== MySQL → PostgreSQL 데이터 마이그레이션 시작 ===")

    # 마이그레이션할 Model 목록
    models_to_migrate = [
        User,
        Score,
        Friendship,
        MonthlyScore,
        GameVisit,
    ]

    # 각 Model 마이그레이션 실행
    for model in models_to_migrate:
        try:
            migrate_model(model)
        except Exception as e:
            print(f"  - 오류 발생: {e}")

    print("\n=== 마이그레이션 완료 ===")

if __name__ == "__main__":
    main()
```

**특징:**
- SQLAlchemy ORM 기반 마이그레이션 (models.py의 User, Score 등 사용)
- 컬럼 정보 자동 추출: `model_class.__table__.columns`
- 객체 → 딕셔너리 변환으로 세션 분리 (DetachedInstanceError 방지)
- 트랜잭션 단위 커밋, 오류 시 자동 롤백
- 각 테이블별 진행 상황 로깅

## 마이그레이션 아키텍처

```
┌─────────────────────────────────┐
│      MySQL Database             │
│  - users (31건)                 │
│  - scores (4건)                 │
│  - friendships (6건)            │
│  - monthly_scores (31건)        │
│  - game_visits (375건)          │
└────────────┬────────────────────┘
             │
             │ migrate_data.py
             │ (SQLAlchemy ORM)
             │
             ▼
┌─────────────────────────────────┐
│   1. MySQL 세션에서 데이터 조회  │
│      mysql_session.query()      │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│   2. 객체 → 딕셔너리 변환        │
│      (세션 독립적 데이터)        │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│   3. PostgreSQL 세션에 삽입      │
│      postgres_session.add()     │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│    PostgreSQL Database          │
│  - users (31건)                 │
│  - scores (4건)                 │
│  - friendships (6건)            │
│  - monthly_scores (31건)        │
│  - game_visits (375건)          │
└─────────────────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│   4. 시퀀스 초기화               │
│      setval('table_id_seq')     │
└─────────────────────────────────┘
```

## 마이그레이션 실행 결과

### 데이터 이동 현황
| 테이블 | MySQL | PostgreSQL | 상태 |
|--------|-------|------------|------|
| users | 31건 | 31건 | ✅ 완료 |
| scores | 4건 | 4건 | ✅ 완료 |
| friendships | 6건 | 6건 | ✅ 완료 |
| monthly_scores | 31건 | 31건 | ✅ 완료 |
| game_visits | 375건 | 375건 | ✅ 완료 |
| **총계** | **447건** | **447건** | ✅ 완료 |

### 시퀀스 초기화 결과
| 테이블 | 시퀀스명 | 현재값 |
|--------|---------|--------|
| users | users_id_seq | 33 |
| scores | scores_id_seq | 4 |
| friendships | friendships_id_seq | 10 |
| monthly_scores | monthly_scores_id_seq | 45 |
| game_visits | game_visits_id_seq | 763 |



## 결과
- 상태: 완료


## 배운내용


## 다음 작업
- api 확인

---

## 기본 정보
- 날짜: 2026-02-05 (수) 18:00~19:00
- 작성자: hexsera

## 진행 목표
users 테이블에 UUID 타입의 user_id 컬럼을 추가하여 향후 PRIMARY KEY 전환을 위한 사전 작업 수행

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| SQLAlchemy 모델 수정 | backend/models.py | UUID 컬럼 추가, import 추가 |
| Alembic 버전 동기화 | - | alembic_version 테이블 수정 (e9059978e80e → eccd28617903) |
| 마이그레이션 파일 생성 | backend/alembic/versions/6fe36d8bc6a2_*.py | autogenerate로 생성 |
| 마이그레이션 파일 수정 | backend/alembic/versions/6fe36d8bc6a2_*.py | uuid-ossp 설치, UUID 채우기, NOT NULL 제약 추가 |
| 마이그레이션 적용 | - | upgrade head 실행 |



## 주요 변경 사항

### 1. PRD/user-테이블-UUID-추가-실행계획.md 생성

**추가:**
```markdown
# user 테이블 UUID 컬럼 추가 실행계획

## 구현 방법

**기술 스택**:
- PostgreSQL 네이티브 UUID 타입 사용 (16 bytes, 저장공간 효율적)
- SQLAlchemy의 `sqlalchemy.dialects.postgresql.UUID` 타입
- Python uuid 라이브러리로 자동 UUID 생성 (default=uuid.uuid4)
- PostgreSQL의 uuid-ossp 확장 모듈 (기존 레코드 UUID 채우기용)

**단계**:
1. SQLAlchemy 모델에 user_id 컬럼 추가 (UUID 타입, default=uuid.uuid4)
2. Alembic 마이그레이션 파일 생성 (autogenerate)
3. 마이그레이션 파일 수정 (uuid-ossp 설치, UUID 채우기, NOT NULL 제약)
4. 마이그레이션 적용 (upgrade head)
5. 검증 (테이블 구조, 데이터, 타입 확인)
```

**특징:**
- PostgreSQL 네이티브 UUID 타입 채택 (String(36) 대비 저장공간 효율적)
- Python 레벨 자동 UUID 생성 (default=uuid.uuid4)
- 데이터베이스 레벨 UUID 생성 (uuid_generate_v4() for 기존 레코드)
- 마이그레이션 단계에서 NOT NULL 제약 추가

### 2. backend/models.py 수정

**변경 전:**
```python
from sqlalchemy import Column, Integer, String, Date, DateTime, Boolean, UniqueConstraint, CheckConstraint
from sqlalchemy.sql import func
from database import Base


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    nickname = Column(String(100), nullable=False)
    password = Column(String(255), nullable=False)
    birth_date = Column(Date, nullable=False)
    role = Column(String(20), nullable=False, default='user')
```

**변경 후:**
```python
from sqlalchemy import Column, Integer, String, Date, DateTime, Boolean, UniqueConstraint, CheckConstraint
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
import uuid
from database import Base


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(UUID(as_uuid=True), unique=True, nullable=True,
                    default=uuid.uuid4, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    nickname = Column(String(100), nullable=False)
    password = Column(String(255), nullable=False)
    birth_date = Column(Date, nullable=False)
    role = Column(String(20), nullable=False, default='user')
```

**특징:**
- `UUID(as_uuid=True)`: PostgreSQL 네이티브 UUID 타입 (16 bytes)
- `as_uuid=True`: Python uuid 객체로 자동 변환 (타입 안정성)
- `default=uuid.uuid4`: 새 레코드 생성 시 자동 UUID 생성
- nullable=True: 기존 레코드 호환성 (마이그레이션 후 NOT NULL 변경)
- unique=True, index=True: 고유성 제약 및 인덱스

### 3. backend/alembic/versions/6fe36d8bc6a2_add_user_id_column_to_users_table.py 생성

**autogenerate 생성 결과:**
```python
def upgrade() -> None:
    op.add_column('users', sa.Column('user_id', sa.UUID(), nullable=True))
    op.create_index(op.f('ix_users_user_id'), 'users', ['user_id'], unique=True)
```

**수동 수정 후:**
```python
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql


def upgrade() -> None:
    # 1. uuid-ossp 확장 설치 (PostgreSQL에서 UUID 생성 함수 사용)
    op.execute('CREATE EXTENSION IF NOT EXISTS "uuid-ossp"')

    # 2. user_id 컬럼 추가 (UUID 타입, NULL 허용)
    op.add_column('users', sa.Column('user_id', postgresql.UUID(as_uuid=True), nullable=True))

    # 3. 기존 레코드에 UUID 채우기
    op.execute('''
        UPDATE users
        SET user_id = uuid_generate_v4()
        WHERE user_id IS NULL
    ''')

    # 4. user_id 컬럼에 NOT NULL 제약 추가
    op.alter_column('users', 'user_id', nullable=False)

    # 5. user_id 컬럼에 UNIQUE 제약 추가
    op.create_index(op.f('ix_users_user_id'), 'users', ['user_id'], unique=True)


def downgrade() -> None:
    op.drop_index(op.f('ix_users_user_id'), table_name='users')
    op.drop_column('users', 'user_id')
```

**특징:**
- uuid-ossp 확장 설치 (uuid_generate_v4() 함수 사용)
- `postgresql.UUID(as_uuid=True)` 명시 (sa.UUID()는 일반형)
- 기존 레코드 자동 UUID 채우기 (멱등성 보장: WHERE user_id IS NULL)
- NOT NULL 제약은 데이터 채운 후 추가 (오류 방지)
- downgrade 시 uuid-ossp 확장 삭제 주석 처리 (다른 테이블 사용 가능성)

## 발생한 문제 및 해결

### 1. Can't locate revision identified by 'e9059978e80e'

**원인:**
- MySQL에서 PostgreSQL로 마이그레이션하면서 alembic_version 불일치
- DB에는 `e9059978e80e` (MySQL 마이그레이션 버전) 기록
- 파일 시스템에는 `eccd28617903` (PostgreSQL 초기 마이그레이션)만 존재

**해결:**
```bash
docker exec postgres-server psql -U hexsera -d hexdb -c "UPDATE alembic_version SET version_num = 'eccd28617903';"
```

**특징:**
- alembic_version 테이블의 version_num을 현재 파일 시스템과 동기화
- MySQL 마이그레이션 파일은 versions_mysql_backup/에 백업되어 있음
- PostgreSQL 환경에서는 eccd28617903부터 시작

### 2. autogenerate의 한계

**문제:**
- autogenerate는 컬럼 추가/삭제, 인덱스 생성은 감지
- 데이터 마이그레이션 (UPDATE 문)은 감지 불가
- PostgreSQL 확장 설치는 감지 불가
- nullable 변경 (True → False)은 감지 불가

**해결:**
- 마이그레이션 파일 생성 후 수동 수정 필수
- uuid-ossp 설치 코드 추가
- 기존 레코드 UUID 채우기 코드 추가
- NOT NULL 제약 추가 코드 추가

**특징:**
- autogenerate는 스키마 변경만 감지 (구조적 변경)
- 데이터 마이그레이션은 항상 수동 작성 필요
- 복잡한 제약사항 변경은 단계별 수동 처리

## 테이블 구조 변경

### 변경 전
```
Table "public.users"
   Column   |          Type          | Nullable |
------------+------------------------+----------+
 id         | integer                | not null |
 email      | character varying(255) | not null |
 nickname   | character varying(100) | not null |
 password   | character varying(255) | not null |
 birth_date | date                   | not null |
 role       | character varying(20)  | not null |
Indexes:
    "users_pkey" PRIMARY KEY, btree (id)
    "ix_users_email" UNIQUE, btree (email)
    "ix_users_id" btree (id)
```

### 변경 후
```
Table "public.users"
   Column   |          Type          | Nullable |
------------+------------------------+----------+
 id         | integer                | not null |
 user_id    | uuid                   | not null |
 email      | character varying(255) | not null |
 nickname   | character varying(100) | not null |
 password   | character varying(255) | not null |
 birth_date | date                   | not null |
 role       | character varying(20)  | not null |
Indexes:
    "users_pkey" PRIMARY KEY, btree (id)
    "ix_users_email" UNIQUE, btree (email)
    "ix_users_id" btree (id)
    "ix_users_user_id" UNIQUE, btree (user_id)
```

**특징:**
- user_id 컬럼 추가: uuid 타입, NOT NULL, UNIQUE
- 저장공간: 16 bytes (String(36) 대비 55% 감소)
- 인덱스: ix_users_user_id (UNIQUE, btree)


## 결과
- 상태: 완료

## 배운내용
- 익스텐션

## 다음 작업
- API를 user_id 기반으로 변경
- friendships 테이블 user_id uuid 로 변경
- game_visits 테이블 user_id uuid 로 변경
- monthly_scores 테이블 user_id uuid 로 변경

---

## 기본 정보
- 날짜: 2026-02-05 (수) 19:00~19:30
- 작성자: hexsera

## 진행 목표
friendships 테이블의 requester_id와 receiver_id가 users 테이블의 id를 참조하도록 외래키 제약 조건 추가하여 데이터 무결성 보장

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| Friendship 모델 수정 | backend/models.py | ForeignKey 제약 조건 추가 |
| Alembic 마이그레이션 파일 생성 | backend/alembic/versions/f38f15d3477d_*.py | autogenerate로 생성 |
| 데이터 무결성 문제 해결 | - | 존재하지 않는 user_id 참조 데이터 1건 삭제 |
| 마이그레이션 적용 | - | upgrade head 실행 |
| 외래키 제약 조건 테스트 | - | 무효한 user_id 삽입 시도 및 JOIN 쿼리 검증 |

## 주요 변경 사항

### 1. PRD/friendships변경-실행계획.md 생성

**추가:**
```markdown
# Friendships 테이블 외래키 관계 설정 실행계획

## 구현 방법

SQLAlchemy의 ForeignKey 제약 조건을 사용하여 외래키 관계를 설정:
- models.py에서 Friendship 모델에 ForeignKey 추가
- Alembic을 사용하여 마이그레이션 파일 자동 생성
- 생성된 마이그레이션 파일을 데이터베이스에 적용
- PostgreSQL 수준에서 외래키 제약 조건이 추가됨

## 구현 단계
1. Friendship 모델에 ForeignKey 추가
2. Alembic 마이그레이션 파일 생성
3. 생성된 마이그레이션 파일 확인
4. 마이그레이션 적용
5. 데이터베이스 제약 조건 확인
```

**특징:**
- SQLAlchemy ForeignKey 사용 (ORM 레벨 제약)
- Alembic autogenerate로 자동 감지
- PostgreSQL의 RESTRICT 정책 기본 적용 (참조된 레코드 삭제 방지)

### 2. backend/models.py 수정

**변경 전:**
```python
from sqlalchemy import Column, Integer, String, Date, DateTime, Boolean, UniqueConstraint, CheckConstraint

class Friendship(Base):
    __tablename__ = "friendships"

    id = Column(Integer, primary_key=True, index=True)
    requester_id = Column(Integer, nullable=False, index=True)
    receiver_id = Column(Integer, nullable=False, index=True)
    status = Column(String(20), nullable=False, default='pending')
    created_at = Column(DateTime, nullable=False, server_default=func.now(), index=True)
```

**변경 후:**
```python
from sqlalchemy import Column, Integer, String, Date, DateTime, Boolean, UniqueConstraint, CheckConstraint, ForeignKey

class Friendship(Base):
    __tablename__ = "friendships"

    id = Column(Integer, primary_key=True, index=True)
    requester_id = Column(Integer, ForeignKey('users.id'), nullable=False, index=True)
    receiver_id = Column(Integer, ForeignKey('users.id'), nullable=False, index=True)
    status = Column(String(20), nullable=False, default='pending')
    created_at = Column(DateTime, nullable=False, server_default=func.now(), index=True)
```

**특징:**
- `ForeignKey('users.id')` 추가: requester_id와 receiver_id가 users.id 참조
- 데이터 삽입 시 참조된 user_id가 users 테이블에 존재하는지 자동 검증
- 삭제 시 RESTRICT 정책으로 참조된 레코드 삭제 방지

### 3. backend/alembic/versions/f38f15d3477d_add_foreign_key_constraints_to_.py 생성

**autogenerate 생성 결과:**
```python
def upgrade() -> None:
    op.create_foreign_key(None, 'friendships', 'users', ['requester_id'], ['id'])
    op.create_foreign_key(None, 'friendships', 'users', ['receiver_id'], ['id'])
    op.alter_column('users', 'user_id',
               existing_type=sa.UUID(),
               nullable=True)

def downgrade() -> None:
    op.alter_column('users', 'user_id',
               existing_type=sa.UUID(),
               nullable=False)
    op.drop_constraint(None, 'friendships', type_='foreignkey')
    op.drop_constraint(None, 'friendships', type_='foreignkey')
```

**특징:**
- 2개의 외래키 제약 조건 생성 (requester_id, receiver_id)
- PostgreSQL에서 ALTER TABLE로 제약 조건 추가
- downgrade 시 외래키 제약 조건 삭제

## 발생한 문제 및 해결

### 1. ForeignKeyViolation: Key (requester_id)=(4) is not present in table "users"

**원인:**
- friendships 테이블에 존재하지 않는 user_id 참조 데이터 존재
- requester_id=4, receiver_id=3이 users 테이블에 없음
- 외래키 제약 조건 추가 시 기존 데이터 검증 실패

**해결:**
```sql
DELETE FROM friendships
WHERE requester_id NOT IN (SELECT id FROM users)
   OR receiver_id NOT IN (SELECT id FROM users);
```

**결과:**
- 1건의 무효한 친구 관계 데이터 삭제
- 마이그레이션 재실행 성공

**특징:**
- 외래키 제약 조건은 기존 데이터도 검증
- 데이터 무결성 문제를 사전에 발견하고 정리
- 이후 무효한 데이터 삽입 원천 차단

## 외래키 제약 조건 검증

### 1. 테이블 구조 확인

**변경 후:**
```
Table "public.friendships"
    Column    |            Type             | Nullable |
--------------+-----------------------------+----------+
 id           | integer                     | not null |
 requester_id | integer                     | not null |
 receiver_id  | integer                     | not null |
 status       | character varying(20)       | not null |
 created_at   | timestamp without time zone | not null |
Indexes:
    "friendships_pkey" PRIMARY KEY, btree (id)
    "ix_friendships_created_at" btree (created_at)
    "ix_friendships_id" btree (id)
    "ix_friendships_receiver_id" btree (receiver_id)
    "ix_friendships_requester_id" btree (requester_id)
    "uq_friendship_pair" UNIQUE CONSTRAINT, btree (requester_id, receiver_id)
Check constraints:
    "ck_no_self_friend" CHECK (requester_id <> receiver_id)
Foreign-key constraints:
    "friendships_receiver_id_fkey" FOREIGN KEY (receiver_id) REFERENCES users(id)
    "friendships_requester_id_fkey" FOREIGN KEY (requester_id) REFERENCES users(id)
```

**특징:**
- 2개의 외래키 제약 조건 추가 완료
- 기존 인덱스, UNIQUE, CHECK 제약 조건 유지

### 2. 무효한 데이터 삽입 테스트

**테스트:**
```sql
INSERT INTO friendships (requester_id, receiver_id, status)
VALUES (999, 1, 'pending');
```

**결과:**
```
ERROR:  insert or update on table "friendships" violates foreign key constraint "friendships_requester_id_fkey"
DETAIL:  Key (requester_id)=(999) is not present in table "users".
```

**특징:**
- 존재하지 않는 user_id로 삽입 시도 시 자동 차단
- 데이터 무결성 보장

### 3. JOIN 쿼리 테스트

**테스트:**
```sql
SELECT f.id, f.requester_id, u1.nickname as requester_name,
       f.receiver_id, u2.nickname as receiver_name, f.status
FROM friendships f
JOIN users u1 ON f.requester_id = u1.id
JOIN users u2 ON f.receiver_id = u2.id;
```

**결과:**
```
 id | requester_id | requester_name | receiver_id | receiver_name |  status
----+--------------+----------------+-------------+---------------+----------
  1 |            2 | oname          |           1 | admin         | accepted
  7 |            8 | 김하진         |           9 | 정우윤        | rejected
  8 |            6 | 정서서         |           7 | 박민서        | pending
  9 |            2 | oname          |           8 | 김하진        | pending
 10 |            2 | oname          |           7 | 박민서        | pending
 11 |            7 | 박민서         |           8 | 김하진        | pending
(6 rows)
```

**특징:**
- 외래키 제약으로 JOIN 쿼리 안정성 보장
- 고아 레코드(orphan record) 발생 불가
- 6건의 기존 친구 관계 정상 조회

## 데이터 무결성 아키텍처

### 변경 전 (외래키 제약 없음)
```
┌─────────────────────────────────┐
│      friendships 테이블         │
│  - requester_id: Integer        │
│  - receiver_id: Integer         │
└─────────────────────────────────┘
         │ (논리적 연결만)
         ▼
┌─────────────────────────────────┐
│      users 테이블               │
│  - id: Integer (PK)             │
└─────────────────────────────────┘

문제점:
- 존재하지 않는 user_id 삽입 가능
- 데이터 무결성 보장 안됨
- 고아 레코드 발생 가능
```

### 변경 후 (외래키 제약 추가)
```
┌─────────────────────────────────┐
│      friendships 테이블         │
│  - requester_id: Integer        │
│    └─> FK: users(id) ──────┐   │
│  - receiver_id: Integer     │   │
│    └─> FK: users(id) ──────┤   │
└────────────────────────────┼───┘
                             │
                             ▼
┌─────────────────────────────────┐
│      users 테이블               │
│  - id: Integer (PK)             │
└─────────────────────────────────┘

장점:
✅ 데이터베이스 레벨에서 무결성 보장
✅ 존재하지 않는 user_id 삽입 자동 차단
✅ 고아 레코드 발생 불가
✅ JOIN 쿼리 안정성 보장
```

## 결과
- 상태: 완료


## 배운내용


## 다음 작업
- friendship POST api 에 user_id 없으면 오류 처리