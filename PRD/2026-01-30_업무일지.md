# 업무일지

## 기본 정보
- 날짜: 2026-01-30 (목요일) 11:00~12:00 1:00~2:00
- 작성자: hexsera

## 진행 목표
FastAPI에 월간 점수 랭킹 시스템 구축을 위한 3단계 작업 수행:
1. MonthlyScore SQLAlchemy 모델 생성
2. 월간 랭킹용 Pydantic 스키마 설계
3. CRUD API 엔드포인트 구현 (메모리 저장소 기반, Upsert 방식)

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| MonthlyScore 모델 생성 | fastapi/models.py | SQLAlchemy ORM 모델 추가 |
| Alembic 마이그레이션 생성 | fastapi/alembic/versions/7974a0858fbe_add_monthly_scores_table.py | 테이블 스키마 버전 관리 |
| 메모리 저장소 추가 | fastapi/main.py | monthly_scores, monthly_score_id_counter 변수 |
| Pydantic 스키마 5개 정의 | fastapi/main.py | 요청/응답 스키마 |
| CRUD 엔드포인트 5개 구현 | fastapi/main.py | POST, GET(2개), PUT, DELETE |

## 주요 변경 사항

### 1. fastapi/models.py 수정

**추가:**
```python
class MonthlyScore(Base):
    __tablename__ = "monthly_scores"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)
    score = Column(Integer, nullable=False, index=True)
    created_at = Column(DateTime, nullable=False, server_default=func.now(), index=True)
```

**특징:**
- 월간 점수 집계 데이터를 저장하는 전용 테이블
- 모든 필드에 인덱스 설정 (조회 성능 최적화)
- created_at으로 월별 필터링 가능 (DATE_FORMAT 활용)
- Score 테이블과 독립적으로 운영

### 2. fastapi/main.py 수정 - 메모리 저장소

**추가:**
```python
# 월간 점수 메모리 저장소 (임시)
monthly_scores: List[dict] = []
monthly_score_id_counter: int = 0
```

**특징:**
- DB 없이 빠른 프로토타입 테스트
- AUTO_INCREMENT 동작 모방 (id_counter)
- 각 dict 구조: {"id": int, "user_id": int, "score": int, "created_at": datetime}

### 3. fastapi/main.py 수정 - Pydantic 스키마

**추가:**
```python
class MonthlyScoreCreateRequest(BaseModel):
    """월간 점수 생성/수정 요청 (Upsert)"""
    user_id: int
    score: int


class MonthlyScoreUpdateRequest(BaseModel):
    """월간 점수 수정 요청"""
    score: int


class MonthlyScoreResponse(BaseModel):
    """월간 점수 응답"""
    id: int
    user_id: int
    score: int
    created_at: datetime

    class Config:
        from_attributes = True


class MonthlyScoreListResponse(BaseModel):
    """월간 점수 목록 응답"""
    scores: List[MonthlyScoreResponse]
    total: int


class MonthlyScoreDeleteResponse(BaseModel):
    """월간 점수 삭제 응답"""
    message: str
    deleted_user_id: int
```

**특징:**
- Create와 Update 스키마 분리 (각 엔드포인트 의도 명확화)
- Response에 from_attributes = True (dict → Pydantic 자동 변환)
- List 응답에 total 필드 포함 (페이지네이션 준비)

### 4. fastapi/main.py 수정 - CRUD 엔드포인트

**추가 1: POST (Upsert)**
```python
@app.post("/api/v1/monthly-scores", response_model=MonthlyScoreResponse)
def create_or_update_monthly_score(score_data: MonthlyScoreCreateRequest):
    """월간 점수 생성 또는 수정 (Upsert)"""
    global monthly_score_id_counter

    # 기존 레코드 검색
    existing_score = next(
        (s for s in monthly_scores if s["user_id"] == score_data.user_id),
        None
    )

    if existing_score:
        # 업데이트: score만 수정, created_at 유지
        existing_score["score"] = score_data.score
        return existing_score
    else:
        # 생성: 새 레코드 추가
        monthly_score_id_counter += 1
        new_score = {
            "id": monthly_score_id_counter,
            "user_id": score_data.user_id,
            "score": score_data.score,
            "created_at": datetime.now()
        }
        monthly_scores.append(new_score)
        return new_score
```

**추가 2: GET (전체 조회)**
```python
@app.get("/api/v1/monthly-scores", response_model=MonthlyScoreListResponse)
def get_monthly_scores(
    order_by: str = "score",
    order: str = "desc"
):
    """전체 월간 점수 조회 (정렬)"""
    sorted_scores = monthly_scores.copy()

    # 정렬
    reverse = (order == "desc")
    if order_by == "score":
        sorted_scores.sort(key=lambda x: x["score"], reverse=reverse)
    elif order_by == "created_at":
        sorted_scores.sort(key=lambda x: x["created_at"], reverse=reverse)
    elif order_by == "user_id":
        sorted_scores.sort(key=lambda x: x["user_id"], reverse=reverse)

    return MonthlyScoreListResponse(
        scores=sorted_scores,
        total=len(sorted_scores)
    )
```

**추가 3: GET (단일 조회)**
```python
@app.get("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreResponse)
def get_monthly_score(user_id: int):
    """특정 사용자 월간 점수 조회"""
    score = next(
        (s for s in monthly_scores if s["user_id"] == user_id),
        None
    )

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    return score
```

**추가 4: PUT (수정)**
```python
@app.put("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreResponse)
def update_monthly_score(user_id: int, score_data: MonthlyScoreUpdateRequest):
    """특정 사용자 월간 점수 수정"""
    score = next(
        (s for s in monthly_scores if s["user_id"] == user_id),
        None
    )

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    score["score"] = score_data.score
    return score
```

**추가 5: DELETE (삭제)**
```python
@app.delete("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreDeleteResponse)
def delete_monthly_score(user_id: int):
    """특정 사용자 월간 점수 삭제"""
    global monthly_scores

    score = next(
        (s for s in monthly_scores if s["user_id"] == user_id),
        None
    )

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    monthly_scores = [s for s in monthly_scores if s["user_id"] != user_id]

    return MonthlyScoreDeleteResponse(
        message="Monthly score deleted successfully",
        deleted_user_id=user_id
    )
```

**특징:**
- Upsert 로직: 같은 user_id 존재 시 점수만 업데이트, created_at 유지
- 정렬 옵션: order_by (score/created_at/user_id), order (desc/asc)
- 에러 처리: 404 Not Found (레코드 없을 때)
- global 키워드: 메모리 저장소 재할당 시 필요
- next() 함수: 리스트에서 조건 검색 (제너레이터 표현식)

## 아키텍처

### API 엔드포인트 구조
```
/api/v1/monthly-scores
├── POST              → Upsert (생성 또는 수정)
├── GET               → 전체 조회 (정렬)
├── GET /{user_id}    → 단일 조회
├── PUT /{user_id}    → 수정
└── DELETE /{user_id} → 삭제
```

### Upsert 동작 흐름
```
POST /api/v1/monthly-scores
       │
       ▼
user_id로 기존 레코드 검색
       │
       ├─ 존재함 ──→ score 업데이트, created_at 유지 → 200 OK
       │
       └─ 없음 ────→ 새 레코드 생성, id 자동 증가 → 200 OK
```



## 결과
- 상태: 완료

## 배운내용
너무 많이 했다. 학습을 전혀 못함.

## 다음 작업

- DB 연동으로 전환 (메모리 저장소 → SQLAlchemy 쿼리)
- 점수테이블 로직 수정.