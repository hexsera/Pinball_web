# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 10:30~11:00
- 작성자: hexsera

## 진행 목표
`game_visits.user_id`에 `users.id`를 참조하는 FK 제약을 추가하고, User 삭제 시 `game_visits` 레코드를 삭제하지 않고 `user_id`를 NULL로 변환하여 방문 기록을 보존한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| GameVisit 모델에 FK 추가 | `backend/models.py` | `ForeignKey('users.id')` 추가 |
| Alembic 마이그레이션 생성 및 적용 | `backend/alembic/versions/7c93967e31b7_...py` | 고아 데이터 정리 후 FK 제약 적용 |
| User 삭제 로직에 NULL 처리 추가 | `backend/app/api/v1/users.py` | GameVisit import 추가 및 NULL 업데이트 쿼리 추가 |


## 주요 변경 사항

### 1. backend/models.py 수정

**변경 전:**
```python
class GameVisit(Base):
    __tablename__ = "game_visits"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=True, index=True)
```

**변경 후:**
```python
class GameVisit(Base):
    __tablename__ = "game_visits"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=True, index=True)
```

**특징:**
- `ForeignKey('users.id')` 추가로 ORM 레벨에서 `game_visits.user_id → users.id` 참조 관계 선언
- `nullable=True` 유지 — 익명 방문자(비로그인)는 user_id가 NULL로 저장되므로 제거 불가

---

### 2. backend/alembic/versions/7c93967e31b7_add_foreign_key_to_game_visits_user_id.py 생성

**추가:**
```python
def upgrade() -> None:
    # users 테이블에 존재하지 않는 고아 user_id를 NULL로 정리
    op.execute(
        "UPDATE game_visits SET user_id = NULL "
        "WHERE user_id IS NOT NULL "
        "AND user_id NOT IN (SELECT id FROM users)"
    )
    op.create_foreign_key(None, 'game_visits', 'users', ['user_id'], ['id'])

def downgrade() -> None:
    op.drop_constraint(None, 'game_visits', type_='foreignkey')
```

**특징:**
- FK 제약 추가 전 고아 데이터(users에 없는 user_id=3) 를 NULL로 정리하는 SQL을 먼저 실행
- 고아 데이터가 존재할 경우 `op.create_foreign_key()` 단독 실행 시 FK 위반 오류가 발생하므로 사전 정리 필수
- `down_revision = '0ceb423c2879'` 으로 기존 마이그레이션 체인에 연결

---

### 3. backend/app/api/v1/users.py 수정

**변경 전:**
```python
from models import User, MonthlyScore, Friendship, HighScore

# FK 참조 테이블 데이터 먼저 삭제
db.query(Friendship).filter(
    (Friendship.requester_id == user_id) | (Friendship.receiver_id == user_id)
).delete(synchronize_session=False)
```

**변경 후:**
```python
from models import User, MonthlyScore, Friendship, HighScore, GameVisit

# FK 참조 테이블 데이터 먼저 삭제
# GameVisit의 user_id를 NULL로 설정 (방문 기록 보존, FK 위반 방지)
db.query(GameVisit).filter(GameVisit.user_id == user_id)\
    .update({"user_id": None}, synchronize_session=False)

db.query(Friendship).filter(
    (Friendship.requester_id == user_id) | (Friendship.receiver_id == user_id)
).delete(synchronize_session=False)
```

**특징:**
- FK 제약 추가 후 User 삭제 시 발생하는 FK 위반 오류를 방지
- 레코드를 삭제하지 않고 `user_id`만 NULL로 변환하여 방문 통계 데이터 보존
- User 삭제(`db.delete(user)`) 이전에 실행하여 FK 제약 위반 방지

---

### 데이터 흐름 변경

**User 삭제 순서 (변경 후):**
```
DELETE /api/v1/users/{user_id}
        │
        ▼
GameVisit.user_id → NULL  (방문 기록 보존)
        │
        ▼
Friendship 삭제  (requester_id / receiver_id)
        │
        ▼
MonthlyScore 삭제
        │
        ▼
HighScore 삭제
        │
        ▼
User 삭제
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
- gamevits post 할 때 user_id PK 없으면 오류 메시지 뜨도록 해야함

# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 11:40~12:20
- 작성자: hexsera

## 진행 목표
데이터베이스의 모든 테이블과 데이터를 완전히 제거한 후 재생성한다. Alembic 마이그레이션 이력도 단일 초기 revision으로 초기화한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| DB constraints 사전 조회 | - | 초기화 전 기준값 기록 |
| 모든 테이블 DROP | - | CASCADE로 6개 테이블 + alembic_version 제거 |
| 기존 마이그레이션 파일 삭제 | `backend/alembic/versions/*.py` | 6개 파일 + __pycache__ 삭제 |
| 새 초기 마이그레이션 파일 생성 | `backend/alembic/versions/60a77f2baf38_initial_schema.py` | autogenerate로 생성 |
| FastAPI 재기동으로 테이블 재생성 | - | 부트스트래핑으로 6개 테이블 자동 생성 |
| alembic stamp head | - | 현재 DB 상태를 HEAD로 등록 |
| constraints 재확인 | - | 초기화 전 기준값과 동일함 확인 |

## 주요 변경 사항

### 1. backend/alembic/versions/ 수정

**변경 전 (6개 파일):**
```
eccd28617903_initial_postgresql_migration.py
6fe36d8bc6a2_add_user_id_column_to_users_table.py
f38f15d3477d_add_foreign_key_constraints_to_.py
45f71363a042_add_foreign_key_to_high_scores_user_id.py
0ceb423c2879_add_foreign_key_to_monthly_scores_user_.py
7c93967e31b7_add_foreign_key_to_game_visits_user_id.py
```

**변경 후 (1개 파일):**
```
60a77f2baf38_initial_schema.py  (upgrade: pass, alembic stamp head로 등록)
```

**특징:**
- 기존 6단계 마이그레이션 체인을 단일 revision으로 통합
- 테이블 생성은 마이그레이션이 아닌 FastAPI 부트스트래핑이 담당
- `alembic stamp head`로 현재 DB 상태를 alembic_version에 등록

---

### 데이터베이스 초기화 흐름

```
DROP TABLE 6개 + alembic_version (CASCADE)
        │
        ▼
versions/*.py 삭제 (마이그레이션 이력 초기화)
        │
        ▼
alembic revision --autogenerate (빈 upgrade 파일 생성)
        │
        ▼
docker compose restart fastapi (부트스트래핑으로 테이블 재생성)
        │
        ▼
alembic stamp head (현재 상태를 HEAD로 등록)
```

---

### constraints 비교 (초기화 전 → 후)

```
friendships_requester_id_fkey  (FK)  : 유지
friendships_receiver_id_fkey   (FK)  : 유지
uq_friendship_pair             (UNIQUE + CHECK): 유지
game_visits_user_id_fkey       (FK)  : 유지
high_scores_user_id_fkey       (FK)  : 유지
monthly_scores_user_id_fkey    (FK)  : 유지
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업


---

# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 12:20:13:00
- 작성자: hexsera

## 진행 목표
`users` 테이블과 `monthly_scores` 테이블에 mock 데이터를 삽입하여 실제 서비스 환경과 유사한 데이터 상태를 구성한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| Faker 의존성 추가 | `backend/requirements.txt` | `Faker==24.0.0` 추가 |
| mock 디렉토리 구조 생성 | `backend/scripts/__init__.py`, `backend/scripts/mock/__init__.py` | 업계 표준 scripts/mock/ 구조 |
| mock 데이터 스크립트 작성 | `backend/scripts/mock/seed_mock_data.py` | User 50명 + MonthlyScore 50개 생성 |
| Docker 컨테이너 재빌드 및 실행 | - | Faker 설치 반영 후 스크립트 실행 |
| 한글 닉네임으로 수정 | `backend/scripts/mock/seed_mock_data.py` | `user_name()` → `last_name()+first_name()` 조합으로 변경 |

## 주요 변경 사항

### 1. backend/requirements.txt 수정

**변경 전:**
```text
httpx==0.27.0
```

**변경 후:**
```text
httpx==0.27.0
Faker==24.0.0
```

**특징:**
- Faker: 이름, 이메일, 날짜 등 현실적인 가짜 데이터를 생성하는 Python 표준 라이브러리

---

### 2. backend/scripts/mock/seed_mock_data.py 생성

**추가:**
```python
import sys, os, random
from datetime import datetime, timedelta

sys.path.insert(0, '/code')

from faker import Faker
from app.db.session import SessionLocal
from models import User, MonthlyScore

fake = Faker('ko_KR')

def _unique_korean_nickname(used: set) -> str:
    for _ in range(100):
        nickname = fake.last_name() + fake.first_name()
        if nickname not in used:
            used.add(nickname)
            return nickname
    raise ValueError("중복되지 않는 닉네임 생성 실패")

def create_mock_users(db, count=50):
    used_nicknames = set()
    for _ in range(count):
        user = User(
            email=fake.unique.email(),
            nickname=_unique_korean_nickname(used_nicknames),
            password="password123!",
            birth_date=fake.date_of_birth(minimum_age=15, maximum_age=60),
            role='user'
        )
        db.add(user)
    db.commit()
    db.expire_all()
    return db.query(User).filter(User.role == 'user').order_by(User.id.desc()).limit(count).all()

def create_mock_monthly_scores(db, users):
    for user in users:
        score = MonthlyScore(
            user_id=user.id,
            nickname=user.nickname,
            score=random.randint(1000, 59999),
            created_at=datetime.utcnow() - timedelta(days=random.randint(0, 30))
        )
        db.add(score)
    db.commit()
```

**특징:**
- `password="password123!"`: mock 데이터 전용, 평문 저장
- `user_id`당 MonthlyScore 1개만 삽입 (API의 upsert 설계 원칙 준수)
- `score`: 1,000~59,999 범위, `created_at`: 최근 30일 이내 랜덤
- `nickname`: `fake.last_name() + fake.first_name()` 조합으로 한글 닉네임 생성 (`user_name()`은 로케일 무관 영문 반환)
- `_unique_korean_nickname()`: 세션 내 중복 방지를 위한 set 기반 중복 검사

---

### 스크립트 실행 흐름

```
docker compose build fastapi  (Faker 패키지 설치)
        │
        ▼
docker compose up -d fastapi
        │
        ▼
docker compose exec fastapi python scripts/mock/seed_mock_data.py
        │
        ▼
users 50명 생성 (한글 닉네임, 평문 비밀번호)
        │
        ▼
monthly_scores 50개 생성 (user_id당 1개)
```

---

### 트러블슈팅

| 문제 | 원인 | 해결 |
|------|------|------|
| `ModuleNotFoundError: No module named 'app'` | 컨테이너 WORKDIR가 `/app`이 아닌 `/code` | `sys.path.insert(0, '/code')`로 수정 |
| 닉네임이 영문으로 생성됨 | `fake.user_name()`은 로케일 무관 영문 반환 | `fake.last_name() + fake.first_name()` 조합으로 변경 |

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
- 이메일 중복 제약사항 생성 고민
- 월간 테이블 post 시 이번달 범위에서만 중복 확인

---

# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 13:20~13:50
- 작성자: hexsera

## 진행 목표
`friendships` 테이블과 `game_visits` 테이블에 mock 데이터를 삽입하여 개발·테스트 환경에서 친구 관계 및 게임 방문 기록 데이터를 시뮬레이션한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| mock 스크립트 작성 | `backend/scripts/mock/seed_friendships_gamevisits.py` | 생성 |
| 컨테이너에서 스크립트 실행 | - | friendships 80건, game_visits 200건 삽입 완료 |

## 주요 변경 사항

### 1. backend/scripts/mock/seed_friendships_gamevisits.py 생성

**추가:**
```python
import sys, random
from datetime import datetime, timedelta

sys.path.insert(0, '/code')

from faker import Faker
from app.db.session import SessionLocal
from models import User, Friendship, GameVisit

fake = Faker('ko_KR')

def create_mock_friendships(db, count=80):
    users = db.query(User).all()
    user_ids = [u.id for u in users]
    existing_pairs = set()
    created = 0
    while created < count:
        a, b = random.sample(user_ids, 2)
        pair = (min(a, b), max(a, b))
        if pair in existing_pairs:
            continue
        existing_pairs.add(pair)
        friendship = Friendship(
            requester_id=a,
            receiver_id=b,
            status=random.choice(['pending', 'accepted', 'rejected']),
            created_at=datetime.utcnow() - timedelta(days=random.randint(0, 90))
        )
        db.add(friendship)
        created += 1
    db.commit()

def create_mock_game_visits(db, count=200):
    users = db.query(User).all()
    user_ids = [u.id for u in users]
    for _ in range(count):
        uid = None if random.random() < 0.3 else random.choice(user_ids)
        created = datetime.utcnow() - timedelta(days=random.randint(0, 60))
        visit = GameVisit(
            user_id=uid,
            ip_address=fake.ipv4(),
            is_visits=True,
            created_at=created,
            updated_at=created
        )
        db.add(visit)
    db.commit()
```

**특징:**
- `random.sample(user_ids, 2)`로 자기 자신과의 친구 요청(CHECK 제약 위반)을 원천 차단
- `(min, max)` 정규화로 (A→B), (B→A) 중복 쌍을 메모리에서 필터링해 UNIQUE 제약 위반 방지
- game_visits는 익명 방문(30%, user_id=None)과 로그인 방문(70%)을 혼합
- `is_visits=True` 고정으로 모든 방문을 실제 게임 플레이로 기록
- `created_at`과 `updated_at`을 명시적으로 동일 값 설정

### 스크립트 실행 흐름

```
docker compose exec fastapi python scripts/mock/seed_friendships_gamevisits.py
        │
        ▼
friendships 80건 생성
(users에서 2명 랜덤 샘플, UNIQUE 보장, status 랜덤)
        │
        ▼
game_visits 200건 생성
(익명 30% / 로그인 70%, ipv4 랜덤, is_visits=True)
        │
        ▼
완료!
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업

---

# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 15:20~16:00
- 작성자: hexsera

## 진행 목표
핀볼 게임에 모바일 터치 환경을 감지하고, 터치 디바이스에서만 흰색 반투명(20%) 원형 버튼 3개(좌 플리퍼, 플런저, 우 플리퍼)를 게임 하단에 표시하여 모바일에서도 핀볼을 조작할 수 있도록 한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| isTouchDevice state 추가 및 감지 로직 구현 | `frontend/src/pages/Pinball/Pinball.jsx` | `navigator.maxTouchPoints > 0` 기반 감지 |
| 플리퍼/플런저 제어 변수를 let → useRef로 승격 | `frontend/src/pages/Pinball/Pinball.jsx` | JSX에서 클로저 외부 접근 가능하도록 변환 |
| 플런저 충전/발사 함수를 ref로 노출 | `frontend/src/pages/Pinball/Pinball.jsx` | `plungerStartRef`, `plungerReleaseRef` 추가 |
| 캔버스 touchstart 등록 조건 분기 | `frontend/src/pages/Pinball/Pinball.jsx` | 터치 디바이스에서는 버튼 UI가 대체 |
| 모바일 조작 버튼 3개 JSX 추가 | `frontend/src/pages/Pinball/Pinball.jsx` | 게임 영역 하단 절대 위치 오버레이 |



## 주요 변경 사항

### 1. frontend/src/pages/Pinball/Pinball.jsx 수정

#### (1) isTouchDevice state 및 감지 useEffect 추가

**변경 전:**
```jsx
const [gameScale, setGameScale] = useState(1);
```

**변경 후:**
```jsx
const [gameScale, setGameScale] = useState(1);
const [isTouchDevice, setIsTouchDevice] = useState(false);

// 터치 디바이스 감지
useEffect(() => {
  setIsTouchDevice(navigator.maxTouchPoints > 0);
}, []);
```

**특징:**
- 화면 크기가 아닌 터치 포인트 지원 여부로 모바일 환경을 판단
- 마운트 시 1회만 실행

---

#### (2) 플리퍼/플런저 제어 변수를 useRef로 승격

**변경 전:**
```jsx
// useEffect 클로저 내부 let 변수
let isLeftKeyPressed = false;
let isRightKeyPressed = false;
let isSpacePressed = false;
let spaceHoldStartTime = 0;
```

**변경 후:**
```jsx
// 컴포넌트 최상단 ref 선언
const isLeftKeyPressedRef = useRef(false);
const isRightKeyPressedRef = useRef(false);
const isSpacePressedRef = useRef(false);
const spaceHoldStartTimeRef = useRef(0);

// useEffect 내부에서 별칭으로 사용
const isLeftKeyPressed = isLeftKeyPressedRef;
const isRightKeyPressed = isRightKeyPressedRef;
const isSpacePressed = isSpacePressedRef;
const spaceHoldStartTime = spaceHoldStartTimeRef;

// 값 읽기/쓰기는 .current로
isLeftKeyPressed.current = true;
if (isSpacePressed.current) { ... }
```

**특징:**
- `let` 변수는 useEffect 클로저 내부에 갇혀 JSX에서 접근 불가
- `useRef`로 선언하면 컴포넌트 전체에서 참조 가능
- 별칭 패턴으로 기존 내부 코드 변경 최소화

---

#### (3) 플런저 충전/발사 함수를 ref로 노출

**추가:**
```jsx
const plungerStartRef = useRef(null);
const plungerReleaseRef = useRef(null);

// useEffect 내부에서 함수 등록
plungerStartRef.current = () => {
  if (!isSpacePressed.current) {
    isSpacePressed.current = true;
    spaceHoldStartTime.current = Date.now();
  }
};

plungerReleaseRef.current = () => {
  if (isSpacePressed.current) {
    isSpacePressed.current = false;
    const holdDuration = Math.min(Date.now() - spaceHoldStartTime.current, 1500);
    const chargeRatio = Math.max(holdDuration / 1500, 0.1);
    const launchSpeed = PLUNGER_MAX_LAUNCH_SPEED * chargeRatio;
    const ballInLane = ball.position.x > 640 && ball.position.x < 685 &&
                       ball.position.y > 900 && ball.position.y < 1080;
    if (ballInLane) {
      Body.setVelocity(ball, { x: 0, y: -launchSpeed });
    }
    Body.setPosition(plunger, { x: PLUNGER_X, y: PLUNGER_REST_Y });
  }
};
```

**특징:**
- 기존 Space 키 로직과 동일한 충전/발사 로직을 JSX 버튼에서도 재사용 가능

---

#### (4) 캔버스 touchstart 등록 조건 분기

**변경 전:**
```jsx
if (sceneRef.current) {
  sceneRef.current.addEventListener('touchstart', handleTouchStart);
  sceneRef.current.addEventListener('touchend', handleTouchEnd);
}
```

**변경 후:**
```jsx
if (sceneRef.current && !(navigator.maxTouchPoints > 0)) {
  sceneRef.current.addEventListener('touchstart', handleTouchStart);
  sceneRef.current.addEventListener('touchend', handleTouchEnd);
}
```

**특징:**
- 터치 디바이스에서는 버튼 UI가 조작을 담당하므로 캔버스 전체 터치 이벤트와 충돌 방지
- 데스크탑에서는 기존 캔버스 터치 이벤트 유지

---

#### (5) 모바일 조작 버튼 3개 JSX 추가

**추가:**
```jsx
{isTouchDevice && (
  <Box sx={{
    position: 'absolute', bottom: '40px', left: 0,
    width: '100%', display: 'flex', justifyContent: 'space-between',
    alignItems: 'center', padding: '0 40px', zIndex: 20,
    pointerEvents: 'none', boxSizing: 'border-box',
  }}>
    {/* 왼쪽 플리퍼 버튼 */}
    <Box
      onPointerDown={() => { isLeftKeyPressedRef.current = true; playFlipperSound(fliperSoundRef.current); }}
      onPointerUp={() => { isLeftKeyPressedRef.current = false; }}
      onPointerLeave={() => { isLeftKeyPressedRef.current = false; }}
      sx={{ width: '100px', height: '100px', borderRadius: '50%',
            backgroundColor: 'rgba(255,255,255,0.2)', pointerEvents: 'auto',
            userSelect: 'none', touchAction: 'none' }}
    />
    {/* 플런저 버튼 */}
    <Box
      onPointerDown={() => { plungerStartRef.current && plungerStartRef.current(); }}
      onPointerUp={() => { plungerReleaseRef.current && plungerReleaseRef.current(); }}
      onPointerLeave={() => { plungerReleaseRef.current && plungerReleaseRef.current(); }}
      sx={{ width: '100px', height: '100px', borderRadius: '50%',
            backgroundColor: 'rgba(255,255,255,0.2)', pointerEvents: 'auto',
            userSelect: 'none', touchAction: 'none' }}
    />
    {/* 오른쪽 플리퍼 버튼 */}
    <Box
      onPointerDown={() => { isRightKeyPressedRef.current = true; playFlipperSound(fliperSoundRef.current); }}
      onPointerUp={() => { isRightKeyPressedRef.current = false; }}
      onPointerLeave={() => { isRightKeyPressedRef.current = false; }}
      sx={{ width: '100px', height: '100px', borderRadius: '50%',
            backgroundColor: 'rgba(255,255,255,0.2)', pointerEvents: 'auto',
            userSelect: 'none', touchAction: 'none' }}
    />
  </Box>
)}
```

**특징:**
- 부모 Box에 `pointerEvents: none`, 각 버튼에만 `pointerEvents: auto`로 버튼 외 영역의 게임 캔버스 터치를 막지 않음
- `onPointerLeave`로 손가락이 버튼 밖으로 벗어나도 플리퍼 자동 해제
- `touchAction: none`으로 버튼 위에서 브라우저 기본 스크롤 동작 차단

---

### 전체 데이터 흐름

```
터치 디바이스 접속
        │
        ▼
navigator.maxTouchPoints > 0 → true
        │
        ▼
isTouchDevice = true
        │
        ├── 캔버스 touchstart 이벤트 미등록
        │
        └── 버튼 3개 렌더링 (게임 영역 하단)
                │
                ├── 좌 버튼 PointerDown → isLeftKeyPressedRef.current = true
                ├── 가운데 버튼 PointerDown → plungerStartRef.current()
                └── 우 버튼 PointerDown → isRightKeyPressedRef.current = true
                        │
                        ▼
                Matter.js beforeUpdate 이벤트에서 ref.current 값 읽어 플리퍼/플런저 제어
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업

---

# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 16:00~17:00
- 작성자: hexsera

## 진행 목표
핀볼 게임을 Dashboard 내부 탭에서 분리하여 `/pinball` 독립 경로를 가진 전용 페이지로 만들고, 화면 크기에 따른 스케일 조정 책임을 Pinball 컴포넌트에서 PinballPage 레이아웃으로 이전한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| PRD 및 실행계획 작성 | `PRD/핀볼게임-전용페이지-실행계획.md` | 레이아웃 아스키아트 포함 |
| PinballPage 컴포넌트 생성 | `frontend/src/pages/PinballPage/PinballPage.jsx` | 홈 버튼 + 게임 캔버스 전용 레이아웃 |
| PinballPage index 생성 | `frontend/src/pages/PinballPage/index.js` | 단축 export |
| 라우트 변경 | `frontend/src/App.jsx` | `/Pinball_test` 삭제 → `/pinball` 추가 |
| Dashboard에서 핀볼 분리 | `frontend/src/pages/Dashboard/Dashboard.jsx` | Pinball import·state 제거, navigate('/pinball')로 전환 |
| HomePage 버튼 경로 변경 | `frontend/src/pages/HomePage/HomePage.jsx` | 2곳 `/dashboard` → `/pinball` |
| 스케일 로직 PinballPage로 위임 | `frontend/src/pages/Pinball/Pinball.jsx`, `PinballPage.jsx` | windowSize·gameScale·calculateScale·resize useEffect를 PinballPage로 이전 |

## 주요 변경 사항

### 1. frontend/src/pages/PinballPage/PinballPage.jsx 생성

**추가:**
```jsx
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { Box, AppBar, Toolbar, IconButton } from '@mui/material';
import HomeIcon from '@mui/icons-material/Home';
import Pinball from '../Pinball';
import HeaderUserInfo from '../../components/HeaderUserInfo';

function PinballPage() {
  const navigate = useNavigate();

  const [windowSize, setWindowSize] = useState({ width: window.innerWidth, height: window.innerHeight });
  const [gameScale, setGameScale] = useState(1);

  const calculateScale = useCallback(() => {
    const scaleByWidth = (windowSize.width - 120) / 700;
    const scaleByHeight = (windowSize.height - 120) / 1200;
    setGameScale(Math.min(scaleByWidth, scaleByHeight, 1));
  }, [windowSize]);

  useEffect(() => {
    const handleResize = () => setWindowSize({ width: window.innerWidth, height: window.innerHeight });
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  useEffect(() => { calculateScale(); }, [windowSize, calculateScale]);

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh', backgroundColor: '#0F172A' }}>
      <AppBar sx={{ backgroundColor: '#1E293B' }}>
        <Toolbar sx={{ justifyContent: 'space-between' }}>
          <IconButton onClick={() => navigate('/')}><HomeIcon /></IconButton>
          <HeaderUserInfo />
        </Toolbar>
      </AppBar>
      <Box sx={{ flexGrow: 1, display: 'flex', justifyContent: 'center', alignItems: 'flex-start', pt: 2 }}>
        <Box sx={{ transform: `scale(${gameScale})`, transformOrigin: 'top center' }}>
          <Pinball />
        </Box>
      </Box>
    </Box>
  );
}
```

**특징:**
- 홈 버튼(`HomeIcon`) 클릭 시 `/`로 이동. 타이틀 문구 없음
- 스케일 계산 로직(windowSize, gameScale, calculateScale, resize 이벤트)을 Pinball에서 이전받아 여기서 관리
- `<Pinball />`을 감싸는 Box에 `transform: scale(${gameScale})` 적용 — Pinball 컴포넌트 자체는 스케일 관여 안 함

---

### 2. frontend/src/pages/Pinball/Pinball.jsx 수정

**변경 전:**
```jsx
import { useEffect, useRef, useState, useCallback } from 'react';

function Pinball() {
  const [windowSize, setWindowSize] = useState({ ... });
  const [gameScale, setGameScale] = useState(1);
  const calculateScale = useCallback(() => { ... }, [windowSize]);

  useEffect(() => { /* resize 이벤트 리스너 */ }, []);
  useEffect(() => { calculateScale(); }, [windowSize, calculateScale]);

  // JSX
  <Box sx={{ transform: `scale(${gameScale})`, transformOrigin: 'top center', width: '700px', height: '1200px' }}>
```

**변경 후:**
```jsx
import { useEffect, useRef, useState } from 'react';

function Pinball() {
  // windowSize, gameScale, calculateScale, useEffect 2개 제거

  // JSX
  <Box sx={{ position: 'relative', width: '700px', height: '1200px' }}>
```

**특징:**
- `useCallback` import 제거
- 스케일 관련 state 2개, 함수 1개, useEffect 2개 총 5개 항목 제거
- Pinball은 700×1200px 고정 크기로만 렌더링. 스케일 책임 없음

---

### 3. frontend/src/App.jsx 수정

**변경 전:**
```jsx
import Pinball from './pages/Pinball';
<Route path="/Pinball_test" element={<Pinball/>} />
```

**변경 후:**
```jsx
import PinballPage from './pages/PinballPage';
<Route path="/pinball" element={<PinballPage />} />
```

**특징:**
- 임시 테스트 경로 `/Pinball_test` 제거, `/pinball` 정식 경로 등록

---

### 4. frontend/src/pages/Dashboard/Dashboard.jsx 수정

**변경 전:**
```jsx
import Pinball from '../Pinball';
const [showPinball, setShowPinball] = useState(true);

if (itemtext == '게임하기') {
  setShowPinball(true); setShowUserInfo(false); setShowFriend(false);
}
{showPinball ? <Pinball /> : showUserInfo ? <UserInfo /> : showFriend ? <FriendPage /> : null}
```

**변경 후:**
```jsx
// Pinball import 삭제, showPinball state 삭제

if (itemtext == '게임하기') { navigate('/pinball'); }

{showUserInfo ? <UserInfo /> : showFriend ? <FriendPage /> : null}
```

**특징:**
- Dashboard에서 Pinball 의존성 완전 제거
- "게임하기" 클릭 시 컴포넌트 전환이 아닌 페이지 이동

---

### 5. frontend/src/pages/HomePage/HomePage.jsx 수정

**변경 전:**
```jsx
onClick={() => navigate('/dashboard')}  // 2곳
```

**변경 후:**
```jsx
onClick={() => navigate('/pinball')}  // 2곳
```

**특징:**
- Dashboard를 거치지 않고 게임 전용 페이지로 직행

---

### 아키텍처 변화

```
[변경 전]
HomePage ──/dashboard──▶ Dashboard
                              │
                    showPinball === true
                              │
                              ▼
                           Pinball
                      (스케일 자체 계산)

[변경 후]
HomePage  ──┐
            ├─/pinball──▶ PinballPage
Dashboard ──┘          (스케일 계산 담당)
                              │
                  transform: scale(gameScale)
                              │
                              ▼
                           Pinball
                      (700×1200px 고정)
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
- Pinball 1300px 고정으로 스크롤 생기는 문제 해결
- 모바일 환경 화면 맟춤 해결
- 웹페이지 배경 이쁘게 꾸미기
- 헤더 유저 영역 벨, 메시지 아이콘 지우기
- 헤더 유저 영역 dialog 에 유저 수정, 친구 수정 페이지 갈 수 있게 하기

---

# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 17:00~17:30, 18:30~19:00
- 작성자: hexsera

## 진행 목표
핀볼 게임 진입 시 게임 시작 전 UI를 표시하고, 스페이스바 또는 화면 클릭으로 게임을 시작하면서 BGM을 재생하여 크롬 자동재생 정책을 우회한다. 게임 시작 UI가 표시된 상태에서는 물리 엔진 속도를 0으로 유지한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| gameStarted state·ref, runnerRef 추가 | `frontend/src/pages/Pinball/Pinball.jsx` | 게임 시작 여부 추적 |
| 엔진 초기 timeScale=0 설정 | `frontend/src/pages/Pinball/Pinball.jsx` | 시작 전 물리 정지 |
| startGame 함수 작성 | `frontend/src/pages/Pinball/Pinball.jsx` | timeScale 복원 + BGM 재생 |
| handleKeyDown에 게임 시작 로직 추가 | `frontend/src/pages/Pinball/Pinball.jsx` | 시작 전 Space만 허용 |
| 게임 시작 UI 오버레이 추가 | `frontend/src/pages/Pinball/Pinball.jsx` | 제목·키 설명·시작 안내 텍스트 |
| UI 폰트 크기 조정 | `frontend/src/pages/Pinball/Pinball.jsx` | 제목 80→92px, 설명 24→32px |
| 모바일 시작 안내 텍스트 분기 | `frontend/src/pages/Pinball/Pinball.jsx` | isTouchDevice 기반 조건부 텍스트 |
| 모바일 키 설명 텍스트 숨김 | `frontend/src/pages/Pinball/Pinball.jsx` | isTouchDevice=true 시 키 설명 미표시 |

## 주요 변경 사항

### 1. frontend/src/pages/Pinball/Pinball.jsx 수정

#### (1) gameStarted state·ref, runnerRef 추가

**변경 전:**
```jsx
const isSpacePressedRef = useRef(false);
const spaceHoldStartTimeRef = useRef(0);
```

**변경 후:**
```jsx
const isSpacePressedRef = useRef(false);
const spaceHoldStartTimeRef = useRef(0);
const [gameStarted, setGameStarted] = useState(false);
const gameStartedRef = useRef(false);
const runnerRef = useRef(null);
```

**특징:**
- `useState`: UI 렌더링 분기(오버레이 표시 여부)용
- `useRef`: `handleKeyDown` 클로저 내에서 최신 값을 읽기 위한 동기화용
- 두 값은 항상 함께 업데이트: `gameStartedRef.current = true; setGameStarted(true);`

---

#### (2) 엔진 초기 timeScale=0 설정 및 runnerRef 저장

**변경 전:**
```jsx
const engine = Engine.create({ gravity: { x: 0, y: 1 } });
engineRef.current = engine;
...
const runner = Runner.create();
Runner.run(runner, engine);
```

**변경 후:**
```jsx
const engine = Engine.create({ gravity: { x: 0, y: 1 } });
engine.timing.timeScale = 0; // 게임 시작 전 물리 정지
engineRef.current = engine;
...
const runner = Runner.create();
runnerRef.current = runner;
Runner.run(runner, engine);
```

**특징:**
- `Runner.run()`은 그대로 호출하되 `timeScale=0`으로 물리 연산만 정지
- `runnerRef`에 runner 저장으로 이후 외부 접근 가능

---

#### (3) startGame 함수 추가

**추가:**
```jsx
const startGame = () => {
  if (gameStartedRef.current) return;
  gameStartedRef.current = true;
  setGameStarted(true);
  engineRef.current.timing.timeScale = 1;
  bgmRef.current?.play().catch(() => {});
  setIsPlaying(true);
};
```

**특징:**
- guard(`if (gameStartedRef.current) return`)로 중복 실행 방지
- 사용자 인터랙션(keydown/click) 콜백 내 호출로 크롬 자동재생 정책 우회
- `.catch(() => {})`로 재생 실패 시 콘솔 에러 미출력

---

#### (4) handleKeyDown에 게임 시작 로직 추가

**변경 전:**
```jsx
const handleKeyDown = (event) => {
  if (event.key === 'ArrowLeft') { ... }
  ...
};
```

**변경 후:**
```jsx
const handleKeyDown = (event) => {
  if (!gameStartedRef.current) {
    if (event.key === ' ' || event.code === 'Space') {
      event.preventDefault();
      startGame();
    }
    return; // 시작 전 다른 키 무시
  }
  if (event.key === 'ArrowLeft') { ... }
  ...
};
```

**특징:**
- 게임 시작 전에는 Space 키만 인식, 플리퍼·플런저 키 차단
- `return`으로 기존 로직 전체를 건너뜀

---

#### (5) 게임 시작 UI 오버레이 추가

**추가:**
```jsx
{!gameStarted && (
  <Box onClick={startGame} sx={{
    position: 'absolute', top: 0, left: 0,
    width: '100%', height: '100%',
    backgroundColor: 'rgba(0,0,0,0.85)',
    display: 'flex', flexDirection: 'column',
    justifyContent: 'center', alignItems: 'center',
    zIndex: 10, cursor: 'pointer',
  }}>
    <Typography sx={{ fontSize: '92px', fontWeight: 'bold', color: '#e94560',
      textShadow: '0 0 20px #e94560, 0 0 40px #e94560', mb: 4 }}>
      PINBALL
    </Typography>
    {!isTouchDevice && (
      <>
        <Typography sx={{ color: '#ffffff', fontSize: '32px', mb: 1 }}>← → : 플립퍼 작동</Typography>
        <Typography sx={{ color: '#ffffff', fontSize: '32px', mb: 4 }}>SPACE : 플런저 발사</Typography>
      </>
    )}
    <Typography sx={{ color: '#f39c12', fontSize: '32px', fontWeight: 'bold' }}>
      {isTouchDevice ? '화면을 터치해서 시작' : 'PRESS SPACE TO START'}
    </Typography>
  </Box>
)}
```

**특징:**
- `onClick={startGame}`으로 화면 클릭으로도 게임 시작 가능
- 모바일(`isTouchDevice=true`)에서는 키 설명 2줄 미표시
- 시작 안내 텍스트를 환경에 따라 분기: 데스크탑 `PRESS SPACE TO START` / 모바일 `화면을 터치해서 시작`

---

### 전체 게임 시작 흐름

```
게임 페이지 진입
        │
        ▼
engine.timing.timeScale = 0 (물리 정지)
        │
        ▼
시작 UI 오버레이 표시
  ┌─────────────────────┐
  │  PINBALL            │
  │  ← → : 플립퍼 작동  │ (데스크탑만)
  │  SPACE : 플런저 발사│ (데스크탑만)
  │  PRESS SPACE TO... │
  └─────────────────────┘
        │
   Space 키 또는 클릭
        │
        ▼
startGame() 호출
  ├── timeScale = 1  (물리 재개)
  ├── bgm.play()     (BGM 시작)
  └── setGameStarted(true) (오버레이 제거)
        │
        ▼
게임 플레이 시작
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
- 게임 시작 UI 에서 핀볼 터치 UI 안보이게 하기
- 게임 시작시 음악 자동 재생 로직 수정 (유저가 이전에 의도적으로 음소거 해놨으면 기억해서 자동으로 음악 재생 안하게)
- 게임 오버레이 UI 구조 수정

---

# 업무일지

## 기본 정보
- 날짜: 2026-02-13 (금) 19:00~20:00
- 작성자: hexsera

## 진행 목표
핀볼 게임의 점수 UI를 개선하고, 점수 획득 시 시각적 피드백을 주는 애니메이션을 구현한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 점수 Box 위치·스타일 변경 | `frontend/src/pages/Pinball/Pinball.jsx` | top 10px→310px, 배경 제거 |
| 점수 표시 형식·크기 변경 | `frontend/src/pages/Pinball/Pinball.jsx` | "SCORE: {score}"→{score}, 28px→92px |
| keyframes 및 scorePopAnimation 정의 | `frontend/src/pages/Pinball/Pinball.jsx` | 컴포넌트 외부에 선언 |
| scoreAnimKey 상태 추가 | `frontend/src/pages/Pinball/Pinball.jsx` | key 기반 애니메이션 트리거 |
| addScore 헬퍼 함수 추가 | `frontend/src/pages/Pinball/Pinball.jsx` | setScore + 애니메이션 트리거 통합 |
| setScore → addScore 교체 | `frontend/src/pages/Pinball/Pinball.jsx` | target 충돌 점수 획득 위치 |
| Typography에 key·animation sx 적용 | `frontend/src/pages/Pinball/Pinball.jsx` | scoreAnimKey 변화 시 재마운트 |

## 주요 변경 사항

### 1. frontend/src/pages/Pinball/Pinball.jsx 수정

#### (1) 점수 Box 위치·스타일 변경

**변경 전:**
```jsx
<Box sx={{
  position: 'absolute',
  top: '10px',
  left: '50%',
  transform: 'translateX(-50%)',
  backgroundColor: 'rgba(255, 255, 255, 0.7)',
  borderRadius: '8px',
  padding: '6px 20px',
  zIndex: 5
}}>
  <Typography sx={{ fontSize: '28px', fontWeight: 'bold', color: '#000000' }}>
    SCORE: {score}
  </Typography>
</Box>
```

**변경 후:**
```jsx
<Box sx={{
  position: 'absolute',
  top: '310px',
  left: '50%',
  transform: 'translateX(-50%)',
  zIndex: 5
}}>
  <Typography ...>
    {score}
  </Typography>
</Box>
```

**특징:**
- `top: 10px` → `310px` 으로 300px 아래로 이동
- `backgroundColor`, `borderRadius`, `padding` 제거로 배경 투명화
- 점수 표시를 `SCORE: {score}` → `{score}` 숫자만 표시
- `fontSize: 28px` → `92px`, `color: #000000` → `#ffffffa1`

---

#### (2) 점수 획득 애니메이션 구현

**추가 (컴포넌트 외부):**
```javascript
import { keyframes } from '@mui/system';

const scorePopAnimation = keyframes`
  0% {
    font-size: 120px;
    color: #ffffffd8;
  }
  100% {
    font-size: 92px;
    color: #ffffffa1;
  }
`;
```

**추가 (컴포넌트 내부 상태·함수):**
```javascript
const [scoreAnimKey, setScoreAnimKey] = useState(0);

const addScore = (points) => {
  setScore(prev => prev + points);
  setScoreAnimKey(prev => prev + 1);
};
```

**변경 전 (점수 획득 코드):**
```javascript
setScore(prev => prev + 300);
```

**변경 후:**
```javascript
addScore(300);
```

**추가 (Typography JSX):**
```jsx
<Typography
  key={scoreAnimKey}
  sx={{
    fontSize: '92px',
    fontWeight: 'bold',
    color: '#ffffffa1',
    animation: scoreAnimKey > 0
      ? `${scorePopAnimation} 3s ease-out forwards`
      : 'none',
  }}
>
  {score}
</Typography>
```

**특징:**
- `key={scoreAnimKey}`: key가 바뀌면 React가 Typography를 새 DOM 엘리먼트로 교체, 애니메이션이 처음부터 재시작됨
- `setTimeout` 방식 대신 key 기반 트리거를 사용해 연속 점수 획득 시 setTimeout 누적 문제 원천 차단
- 0% → 120px·밝은색으로 즉시 시작, 3s 동안 92px·원래 색으로 복귀

---

### 애니메이션 흐름

```
target 충돌 감지
        │
        ▼
addScore(300) 호출
  ├── setScore(prev => prev + 300)  (점수 증가)
  └── setScoreAnimKey(prev => prev + 1)  (key 증가)
        │
        ▼
React: key 변경 → Typography 재마운트
        │
        ▼
애니메이션 시작: 120px·#ffffffd8 → (3s ease-out) → 92px·#ffffffa1
```

## 결과
- 상태: 완료

## 배운 내용

## 다음 작업
- 배수 시스템
- 범퍼 점수 획득