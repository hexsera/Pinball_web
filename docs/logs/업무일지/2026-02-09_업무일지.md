# 업무일지

## 기본 정보
- 날짜: 2026-02-09 (월요일) 20:20~21:00
- 작성자: hexsera

## 진행 목표
HighScore 테이블의 user_id를 Foreign Key로 변경하여 데이터 무결성 강화

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| RED: FK 제약조건 테스트 작성 | `backend/tests/test_high_scores.py` | 존재하지 않는 user_id 생성 실패 테스트 추가 |
| RED 검증: 테스트 실패 확인 | - | FK 제약조건 없어서 예상대로 실패 |
| GREEN: models.py에 ForeignKey 추가 | `backend/models.py` | HighScore.user_id에 FK 추가 |
| GREEN: Alembic 마이그레이션 생성 | `backend/alembic/versions/45f71363a042_*.py` | autogenerate로 FK 추가 마이그레이션 생성 |
| GREEN: 마이그레이션 적용 | - | 프로덕션 DB에 FK 제약조건 적용 |
| GREEN: API 예외 처리 추가 | `backend/main.py` | IntegrityError 처리 로직 추가 |
| GREEN 검증: 테스트 통과 확인 | - | FK 관련 테스트 2개 모두 통과 |

## 주요 변경 사항

### 1. backend/tests/test_high_scores.py 수정

**추가된 테스트:**
```python
# ===== Foreign Key 제약조건 테스트 =====

def test_create_high_score_with_valid_user_id_succeeds(client, db_session, sample_users):
    """존재하는 user_id로 HighScore 생성 시 성공"""
    # Given: sample_users fixture로 user1, user2가 DB에 존재 (id=1, id=2)
    user1 = sample_users[0]

    # When: 존재하는 user_id로 HighScore 생성
    response = client.post(
        "/api/v1/high-scores",
        json={"user_id": user1.id, "score": 5000}
    )

    # Then: 201 Created 응답
    assert response.status_code == 201
    data = response.json()
    assert data["user_id"] == user1.id
    assert data["score"] == 5000


def test_create_high_score_with_nonexistent_user_id_fails(client, db_session):
    """존재하지 않는 user_id로 HighScore 생성 시 실패 (FK 제약조건)"""
    # Given: user_id=99999가 users 테이블에 존재하지 않음
    nonexistent_user_id = 99999

    # When: 존재하지 않는 user_id로 HighScore 생성 시도
    response = client.post(
        "/api/v1/high-scores",
        json={"user_id": nonexistent_user_id, "score": 1000}
    )

    # Then: 400 Bad Request 또는 422 Unprocessable Entity 응답
    # (FK 제약조건 위반으로 인한 실패)
    assert response.status_code in [400, 422, 500]
    data = response.json()
    assert "detail" in data
```

**특징:**
- TDD RED 단계: 실패하는 테스트를 먼저 작성
- FK 제약조건이 작동하는지 검증
- sample_users fixture 활용하여 실제 User 레코드로 테스트

### 2. backend/models.py 수정

**변경 전:**
```python
class HighScore(Base):
    __tablename__ = "high_scores"

    id = Column(Integer, primary_key=True, autoincrement=True, index=True)
    user_id = Column(Integer, nullable=False, unique=True, index=True)
    score = Column(Integer, nullable=False, index=True)
    created_at = Column(DateTime, default=func.now(), nullable=False, index=True)
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now(), nullable=False)
```

**변경 후:**
```python
class HighScore(Base):
    __tablename__ = "high_scores"

    id = Column(Integer, primary_key=True, autoincrement=True, index=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False, unique=True, index=True)
    score = Column(Integer, nullable=False, index=True)
    created_at = Column(DateTime, default=func.now(), nullable=False, index=True)
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now(), nullable=False)
```

**특징:**
- `ForeignKey('users.id')` 추가
- users 테이블의 id 컬럼을 참조
- 데이터베이스 레벨에서 참조 무결성 보장

### 3. backend/alembic/versions/45f71363a042_add_foreign_key_to_high_scores_user_id.py 생성

**추가된 마이그레이션:**
```python
def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_foreign_key(None, 'high_scores', 'users', ['user_id'], ['id'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'high_scores', type_='foreignkey')
    # ### end Alembic commands ###
```

**특징:**
- Alembic autogenerate로 자동 생성
- upgrade: high_scores.user_id → users.id FK 생성
- downgrade: FK 제거하여 롤백 가능
- Revision ID: 45f71363a042

### 4. backend/main.py 수정

**변경 전:**
```python
@app.post("/api/v1/high-scores", response_model=HighScoreResponse, status_code=status.HTTP_201_CREATED)
def create_or_update_high_score(payload: HighScoreCreate, db: Session = Depends(get_db)):
    # 1. 기존 기록이 있는지 확인
    existing_score = db.query(HighScore).filter(HighScore.user_id == payload.user_id).first()

    if not existing_score:
        # 2. 기록이 없으면 새로 생성 (최초 최고 기록)
        new_high_score = HighScore(user_id=payload.user_id, score=payload.score)
        db.add(new_high_score)
        db.commit()
        db.refresh(new_high_score)
        return new_high_score

    # 3. 기존 기록이 있다면 점수 비교
    if payload.score > existing_score.score:
        # 새 점수가 더 높을 때만 업데이트
        existing_score.score = payload.score
        db.commit()
        db.refresh(existing_score)

    # 4. 새 점수가 낮더라도 201 상태코드와 함께 기존(혹은 업데이트된) 데이터를 반환
    return existing_score
```

**변경 후:**
```python
from sqlalchemy.exc import IntegrityError  # 추가

@app.post("/api/v1/high-scores", response_model=HighScoreResponse, status_code=status.HTTP_201_CREATED)
def create_or_update_high_score(payload: HighScoreCreate, db: Session = Depends(get_db)):
    try:
        # 1. 기존 기록이 있는지 확인
        existing_score = db.query(HighScore).filter(HighScore.user_id == payload.user_id).first()

        if not existing_score:
            # 2. 기록이 없으면 새로 생성 (최초 최고 기록)
            new_high_score = HighScore(user_id=payload.user_id, score=payload.score)
            db.add(new_high_score)
            db.commit()
            db.refresh(new_high_score)
            return new_high_score

        # 3. 기존 기록이 있다면 점수 비교
        if payload.score > existing_score.score:
            # 새 점수가 더 높을 때만 업데이트
            existing_score.score = payload.score
            db.commit()
            db.refresh(existing_score)

        # 4. 새 점수가 낮더라도 201 상태코드와 함께 기존(혹은 업데이트된) 데이터를 반환
        return existing_score
    except IntegrityError:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="존재하지 않는 사용자 ID입니다"
        )
```

**특징:**
- `IntegrityError` 예외 처리 추가
- FK 제약조건 위반 시 400 Bad Request 반환
- 트랜잭션 롤백으로 데이터 일관성 유지
- 사용자 친화적 에러 메시지 제공

## 아키텍처 변경

### FK 제약조건 추가 전

```
┌─────────────────────────┐
│   high_scores 테이블    │
│  - id (PK)              │
│  - user_id (Integer)    │  ← 단순 정수, 검증 없음
│  - score                │
└─────────────────────────┘

┌─────────────────────────┐
│   users 테이블          │
│  - id (PK)              │
│  - email                │
│  - nickname             │
└─────────────────────────┘
```

### FK 제약조건 추가 후

```
┌─────────────────────────┐
│   high_scores 테이블    │
│  - id (PK)              │
│  - user_id (FK) ────────┼──→ users.id
│  - score                │     (참조 무결성 보장)
└─────────────────────────┘

┌─────────────────────────┐
│   users 테이블          │
│  - id (PK)              │
│  - email                │
│  - nickname             │
└─────────────────────────┘
```

**효과:**
- 존재하지 않는 user_id로 HighScore 생성 불가
- 데이터베이스 레벨에서 참조 무결성 강제
- 잘못된 데이터 입력 원천 차단

## 결과
- 상태: 완료
- FK 관련 테스트 2개 모두 통과 (TDD GREEN)
- 프로덕션 DB에 마이그레이션 적용 완료
- 데이터 무결성 보장

## 배운내용
- TDD의 RED-GREEN-REFACTOR 사이클이 안전한 리팩토링을 가능하게 함
- Foreign Key 제약조건은 데이터베이스 레벨에서 참조 무결성을 강제함
- IntegrityError 예외 처리로 사용자 친화적인 에러 메시지 제공 가능
- Alembic autogenerate가 모델 변경을 자동으로 감지하여 마이그레이션 생성

## 다음 작업
- REFACTOR: FK 제약조건 이름 명시적 지정 (선택 사항)
- REFACTOR: User-HighScore 간 relationship 추가 (선택 사항)
- 전체 테스트 스위트 실행하여 회귀 테스트 확인

---

## 진행 목표 (2)
MonthlyScore 테이블의 user_id를 Foreign Key로 변경하여 데이터 무결성 강화

## 진행 시간
- 날짜: 2026-02-09 (월요일) 21:00~21:30
- 소요 시간: 약 20분

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| RED: FK 제약조건 테스트 작성 | `backend/tests/test_monthly_scores_fk.py` | monthly_scores.user_id FK 존재 여부 테스트 |
| RED 검증: 테스트 실패 확인 | - | FK 제약조건 없어서 예상대로 실패 |
| GREEN: models.py에 ForeignKey 추가 | `backend/models.py` | MonthlyScore.user_id에 FK 추가 |
| GREEN: Alembic 마이그레이션 생성 | `backend/alembic/versions/0ceb423c2879_*.py` | autogenerate로 FK 추가 마이그레이션 생성 |
| GREEN: 마이그레이션 적용 | - | PostgreSQL DB에 FK 제약조건 적용 |
| GREEN 검증: 테스트 통과 확인 | - | FK 관련 테스트 통과 |

## 주요 변경 사항 (2)

### 1. backend/tests/test_monthly_scores_fk.py 생성

**새로 추가된 테스트 파일:**
```python
"""
MonthlyScore와 User 간의 Foreign Key 관계를 테스트
"""
import pytest
from sqlalchemy import inspect
from sqlalchemy.orm import Session
from database import engine
from models import MonthlyScore, User


def test_monthly_scores_has_foreign_key_to_users():
    """monthly_scores 테이블의 user_id가 users 테이블의 id를 FK로 참조하는지 테스트"""
    inspector = inspect(engine)

    # monthly_scores 테이블의 Foreign Key 정보 가져오기
    foreign_keys = inspector.get_foreign_keys('monthly_scores')

    # Foreign Key가 최소 1개 이상 존재해야 함
    assert len(foreign_keys) > 0, "monthly_scores 테이블에 Foreign Key가 없습니다"

    # user_id 컬럼이 users.id를 참조하는 FK 찾기
    user_fk = None
    for fk in foreign_keys:
        if 'user_id' in fk['constrained_columns'] and fk['referred_table'] == 'users':
            user_fk = fk
            break

    # user_id가 users.id를 FK로 참조하는지 검증
    assert user_fk is not None, "monthly_scores.user_id가 users 테이블을 참조하는 FK가 없습니다"
    assert user_fk['referred_columns'] == ['id'], "FK가 users.id를 참조해야 합니다"
    assert 'user_id' in user_fk['constrained_columns'], "FK의 constrained_columns에 user_id가 있어야 합니다"
```

**특징:**
- TDD RED 단계: 실패하는 테스트를 먼저 작성
- SQLAlchemy Inspector를 사용하여 데이터베이스 스키마 검증
- Foreign Key의 존재 여부와 참조 관계를 명확히 검증
- 실제 데이터베이스 메타데이터를 검사하여 FK 제약조건 확인

### 2. backend/models.py 수정 (MonthlyScore)

**변경 전:**
```python
class MonthlyScore(Base):
    __tablename__ = "monthly_scores"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)
    nickname = Column(String(100), nullable=False)
    score = Column(Integer, nullable=False, index=True)
    created_at = Column(DateTime, nullable=False, server_default=func.now(), index=True)
```

**변경 후:**
```python
class MonthlyScore(Base):
    __tablename__ = "monthly_scores"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False, index=True)
    nickname = Column(String(100), nullable=False)
    score = Column(Integer, nullable=False, index=True)
    created_at = Column(DateTime, nullable=False, server_default=func.now(), index=True)
```

**특징:**
- `ForeignKey('users.id')` 추가
- users 테이블의 id 컬럼을 참조
- 데이터베이스 레벨에서 참조 무결성 보장
- HighScore 모델과 동일한 패턴 적용

### 3. backend/alembic/versions/0ceb423c2879_add_foreign_key_to_monthly_scores_user_.py 생성

**추가된 마이그레이션:**
```python
"""add foreign key to monthly_scores user_id

Revision ID: 0ceb423c2879
Revises: 45f71363a042
Create Date: 2026-02-09 12:15:43.123456

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '0ceb423c2879'
down_revision: Union[str, None] = '45f71363a042'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_foreign_key(None, 'monthly_scores', 'users', ['user_id'], ['id'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'monthly_scores', type_='foreignkey')
    # ### end Alembic commands ###
```

**특징:**
- Alembic autogenerate로 자동 생성
- upgrade: monthly_scores.user_id → users.id FK 생성
- downgrade: FK 제거하여 롤백 가능
- Revision ID: 0ceb423c2879
- 이전 마이그레이션: 45f71363a042 (high_scores FK 추가)

## 아키텍처 변경 (2)

### FK 제약조건 추가 전

```
┌─────────────────────────┐
│ monthly_scores 테이블   │
│  - id (PK)              │
│  - user_id (Integer)    │  ← 단순 정수, 검증 없음
│  - nickname             │
│  - score                │
└─────────────────────────┘

┌─────────────────────────┐
│   users 테이블          │
│  - id (PK)              │
│  - email                │
│  - nickname             │
└─────────────────────────┘
```

### FK 제약조건 추가 후

```
┌─────────────────────────┐
│ monthly_scores 테이블   │
│  - id (PK)              │
│  - user_id (FK) ────────┼──→ users.id
│  - nickname             │     (참조 무결성 보장)
│  - score                │
└─────────────────────────┘

┌─────────────────────────┐
│   users 테이블          │
│  - id (PK)              │
│  - email                │
│  - nickname             │
└─────────────────────────┘
```

**효과:**
- 존재하지 않는 user_id로 MonthlyScore 생성 불가
- 데이터베이스 레벨에서 참조 무결성 강제
- 잘못된 데이터 입력 원천 차단
- HighScore와 동일한 패턴으로 일관성 유지

## 결과 (2)
- 상태: GREEN 단계 완료
- FK 관련 테스트 통과 (test_monthly_scores_has_foreign_key_to_users)
- PostgreSQL DB에 마이그레이션 적용 완료
- 데이터 무결성 보장

## TDD 사이클

### RED Phase
1. 테스트 작성: `test_monthly_scores_has_foreign_key_to_users`
2. 테스트 실행: **실패** (AssertionError: monthly_scores 테이블에 Foreign Key가 없습니다)
3. 실패 원인: Foreign Key 개수 = 0

### GREEN Phase
1. models.py 수정: `ForeignKey('users.id')` 추가
2. 마이그레이션 생성: `alembic revision --autogenerate`
3. 마이그레이션 적용: `alembic upgrade head`
4. 테스트 실행: **통과** (PASSED [100%])

### REFACTOR Phase (예정)
- 코드 정리 및 개선 (필요시)

## 다음 작업 (2)
- highscore 테이블 post 에 FK 존재 여부 확인
- monthly_score 테이블 post 에 FK 존재 여부 확인