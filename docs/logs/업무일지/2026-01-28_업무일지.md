# 업무일지

## 기본 정보
- 날짜: 2026-01-28 (화) 11:04~12:07
- 작성자: hexsera

## 진행 목표
핀볼 게임에서 공이 죽음구역에 떨어지면 다시 살릴 수 있는 부활 기능 구현. 사용자에게 재도전 기회를 제공하여 난이도를 조절하고 입문 장벽을 낮춤.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 핀볼 부활 시스템 만듬 | react/main/src/Pinball.jsx | |
| 핀볼 생명갯수 오류 수정 | PRD/핀볼살리기-실행계획.md | |

**총 2시간 30분**

## 주요 변경 사항

### 1. react/main/src/Pinball.jsx 수정

#### 변경 1: ballRef 및 livesRef useRef 추가

**변경 전:**
```javascript
function Pinball() {
  const sceneRef = useRef(null);
  const bgmRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [score, setScore] = useState(30);
```

**변경 후:**
```javascript
function Pinball() {
  const sceneRef = useRef(null);
  const bgmRef = useRef(null);
  const ballRef = useRef(null);
  const livesRef = useRef(3);
  const [isPlaying, setIsPlaying] = useState(false);
  const [score, setScore] = useState(30);
  const [lives, setLives] = useState(3);
```

**특징:**
- `ballRef`: ball 객체를 컴포넌트 전역에서 접근 가능하게 만듦
- `livesRef`: 이벤트 리스너 내부에서 최신 lives 값을 읽기 위한 ref
- `lives`: UI 표시 및 React 상태 관리용

#### 변경 2: ball 객체를 ballRef에 저장

**추가:**
```javascript
const ball = Bodies.circle(250, 400, 15, {
  restitution: 0.8,
  friction: 0,
  frictionAir: 0,
  render: { fillStyle: '#e94560' }
});

ballRef.current = ball;  // ref에 저장
```

#### 변경 3: 죽음구역 충돌 로직 수정 (공 부활 기능)

**변경 전:**
```javascript
// 죽음구역 충돌 감지
if ((bodyA.label === 'deathZone' && bodyB === ball) ||
    (bodyB.label === 'deathZone' && bodyA === ball)) {
  console.log('Ball entered death zone!');
  World.remove(engine.world, ball);
}
```

**변경 후:**
```javascript
// 죽음구역 충돌 감지
if ((bodyA.label === 'deathZone' && bodyB === ball) ||
    (bodyB.label === 'deathZone' && bodyA === ball)) {
  console.log('Ball entered death zone!');

  // livesRef로 최신 lives 값 확인
  if (livesRef.current > 0) {
    // 공을 초기 위치로 이동
    Body.setPosition(ball, { x: 250, y: 400 });

    // 속도 초기화
    Body.setVelocity(ball, { x: 0, y: 0 });

    // 각속도 초기화 (회전 방지)
    Body.setAngularVelocity(ball, 0);

    // lives 감소 (상태와 ref 모두 업데이트)
    const newLives = livesRef.current - 1;
    livesRef.current = newLives;
    setLives(newLives);

    console.log(`Ball revived! Lives remaining: ${newLives}`);
  } else {
    // 생명이 없으면 공 제거 (게임 오버)
    World.remove(engine.world, ball);
    console.log('Game Over!');
  }
}
```

**특징:**
- `World.remove()` 호출을 조건부로 변경 (livesRef.current === 0일 때만)
- `Body.setPosition()`으로 공을 초기 위치 (250, 400)로 이동
- `Body.setVelocity()`로 속도를 (0, 0)으로 초기화하여 정지 상태로 만듦
- `Body.setAngularVelocity(0)`으로 회전도 초기화
- lives 감소: `livesRef.current - 1`을 계산하여 `livesRef.current`와 `setLives()` 모두 업데이트

### 문제 상황
```javascript
useEffect(() => {
  // lives = 3으로 고정된 시점에서 이벤트 리스너 등록
  Events.on(engine, 'collisionStart', (event) => {

    // setLives(prev => prev - 1)로 React 상태는 업데이트됨
    // 하지만 if (lives > 0)의 lives는 여전히 3

    if (lives > 0) {  // ❌ 항상 3 > 0이므로 계속 부활
      setLives(prev => prev - 1);
    }
  });
}, []);  // 의존성 배열이 비어있어 한 번만 실행
```

### 해결 방법

**방법 1: livesRef 사용 (채택)**
```javascript
useEffect(() => {
  Events.on(engine, 'collisionStart', (event) => {

    if (livesRef.current > 0) {  // ✅ ref는 항상 최신 값 참조
      const newLives = livesRef.current - 1;
      livesRef.current = newLives;
      setLives(newLives);
    }
  });
}, []);
```

### 데이터 흐름

```
공이 죽음구역 진입
        │
        ▼
충돌 이벤트 발생 (collisionStart)
        │
        ▼
livesRef.current 확인
        │
        ├─ > 0 ──────────┐
        │                │
        │                ▼
        │         공 위치 리셋
        │         속도 초기화
        │         livesRef.current - 1
        │         setLives(newLives)
        │                │
        │                ▼
        │         콘솔 로그 출력
        │
        └─ === 0 ────────┐
                         │
                         ▼
                  World.remove(ball)
                  게임 오버
```

## 결과
- 상태: 완료

## 배운내용
useState, useRef 에 대해(겉핥기)

## 다음 작업
- Lives UI 표시 기능 (좌측 상단에 "LIVES: X" 표시)
- 게임 오버 UI 표시 기능 (화면 중앙에 "GAME OVER" 메시지)
- 재시작 버튼 추가 (선택 사항)


## 기본 정보
- 날짜: 2026-01-28 (화) 1:05~1:13, 2:45~3:05 
- 작성자: hexsera

## 진행 목표
핀볼 게임에서 목표 오브젝트(target)를 구현하여 사용자에게 명확한 목표를 부여하고 도전 정신을 고취시킴.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| target Bodies 생성 | react/main/src/Pinball.jsx | 하늘색 원형 오브젝트 추가
| World에 target 추가 | react/main/src/Pinball.jsx | Matter.js 월드에 target 등록
| target 충돌 이벤트 추가 | react/main/src/Pinball.jsx | 충돌 감지 및 콘솔 메시지 출력



## 주요 변경 사항

### 1. react/main/src/Pinball.jsx 수정

#### 변경 1: target Bodies 생성

**추가:**
```javascript
// 목표 오브젝트 만들기 (충돌 시 강하게 튕겨냄)
const target = Bodies.circle(500, 500, 40, {
  isStatic: true,
  restitution: 1.5,
  label: 'target',
  render: { fillStyle: '#87CEEB' }
});
```

**특징:**
- 위치: (500, 500) - bumper와 다른 위치
- 반지름: 40 (bumper와 동일한 크기)
- `isStatic: true`: 고정된 위치
- `restitution: 1.5`: bumper와 동일한 반발력 (충돌 시 강하게 튕겨냄)
- `label: 'target'`: 충돌 감지를 위한 식별자
- `fillStyle: '#87CEEB'`: 하늘색 (Sky Blue)

#### 변경 2: World에 target 추가

**변경 전:**
```javascript
World.add(engine.world, [
  ground,
  leftWall,
  rightWall,
  upWall,
  deathZone,
  ball,
  obstacle1,
  obstacle2,
  bumper,
  leftFlipper,
  rightFlipper,
  leftFlipperConstraint,
  rightFlipperConstraint
]);
```

**변경 후:**
```javascript
World.add(engine.world, [
  ground,
  leftWall,
  rightWall,
  upWall,
  deathZone,
  ball,
  obstacle1,
  obstacle2,
  bumper,
  target,  // target 추가
  leftFlipper,
  rightFlipper,
  leftFlipperConstraint,
  rightFlipperConstraint
]);
```

**특징:**
- bumper 다음에 target 추가하여 가독성 향상
- Matter.js 엔진이 target을 물리 시뮬레이션에 포함

#### 변경 3: target 충돌 이벤트 추가

**추가:**
```javascript
// 공과 목표 오브젝트가 충돌했는지 확인
if ((bodyA.label === 'target' && bodyB === ball) ||
    (bodyB.label === 'target' && bodyA === ball)) {
  console.log('target 충돌했음');
}
```

**특징:**
- bumper 충돌 이벤트와 동일한 구조
- `bodyA.label === 'target'` 또는 `bodyB.label === 'target'`로 충돌 감지
- 콘솔에 "target 충돌했음" 메시지 출력
- bumper 충돌 이벤트 다음, 죽음구역 충돌 이벤트 이전에 배치

### 2. PRD/핀볼목표오브젝트-실행계획.md 생성

**추가:**
- 요구사항 요약: 목표 오브젝트의 목적과 필요성
- 현재상태 분석: 기존 bumper 구조 분석
- 구현 방법: bumper 코드 재사용 및 색상/label 변경
- 구현 단계: 3단계 (target 생성, World 추가, 충돌 이벤트)
- 완료 체크리스트: 화면 표시, 위치, 충돌 감지, 튕김 효과 확인

**특징:**
- bumper를 기반으로 target을 생성하여 개발 시간 단축
- 하늘색(#87CEEB)으로 bumper(빨간색)와 시각적 구분
- restitution 1.5로 충돌 시 강한 반발력 제공

## 게임 오브젝트 구조

```
핀볼 게임 오브젝트
├── 경계
│   ├── ground (바닥)
│   ├── leftWall (왼쪽 벽)
│   ├── rightWall (오른쪽 벽)
│   ├── upWall (위 벽)
│   └── deathZone (죽음 구역)
├── 공
│   └── ball
├── 장애물
│   ├── obstacle1
│   └── obstacle2
├── 상호작용 오브젝트
│   ├── bumper (빨간색, 위치: 400, 600)
│   └── target (하늘색, 위치: 500, 500) ← 새로 추가
└── 플레이어 컨트롤
    ├── leftFlipper
    ├── rightFlipper
    ├── leftFlipperConstraint
    └── rightFlipperConstraint
```

## 충돌 이벤트 처리 순서

```
collisionStart 이벤트 발생
        │
        ▼
pairs.forEach((pair) => {
  │
  ├─ bumper 충돌? ──→ 공에 추가 속도 부여 (bumperForce)
  │
  ├─ target 충돌? ──→ console.log('target 충돌했음') ← 새로 추가
  │
  └─ deathZone 충돌? ──→ 부활 또는 게임 오버
})
```

## 결과
- 상태: 완료

## 배운내용
없음

## 다음 작업
- target 충돌 시 점수 증가 기능 추가
- target 충돌 횟수 표시 UI 구현
- 여러 개의 target 배치 (난이도 조절)
- target 충돌 시 시각적 효과 추가 (색상 변경, 애니메이션 등)


## 기본 정보
- 날짜: 2026-01-28 (화) 15:10~16:00
- 작성자: hexsera

## 진행 목표
핀볼 게임에 스테이지 전환 시스템을 도입하여 사용자에게 다양한 맵을 제공하고 반복적인 지루함을 줄임. 테스트를 위해 'n' 키로 스테이지 전환 가능하도록 설계 방법을 알아본다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 실행계획 문서 작성 | PRD/핀볼-맵-전환-실행계획.md | 구현 방법 및 단계별 절차 수립 |


## 주요 설계 사항

### 1. 스테이지 데이터 구조 설계

**신규 파일: react/main/src/stages.js**
```javascript
const stages = [
  {
    name: 'Stage 1',
    background: '/images/pinball_back.png',
    obstacles: [
      { type: 'circle', x: 300, y: 300, radius: 30, options: { isStatic: true, render: { fillStyle: '#0f3460' } } },
      { type: 'circle', x: 500, y: 300, radius: 30, options: { isStatic: true, render: { fillStyle: '#0f3460' } } },
    ],
    bumpers: [
      { x: 400, y: 600, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e74c3c' } } },
    ],
    targets: [
      { x: 500, y: 500, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#87CEEB' } } },
    ],
  },
  // Stage 2...
];
```

**특징:**
- 스테이지별로 name, background, obstacles, bumpers, targets 배열 정의
- 벽, 플리퍼, 공, 죽음구역은 공통이므로 스테이지 데이터에서 제외
- 확장성: 새 스테이지 추가 시 배열에 객체만 추가하면 됨

### 2. 스테이지 전환 로직 설계

**함수 1: createStageBodies(stageData)**
```javascript
const createStageBodies = (stageData) => {
  const bodies = [];

  // 장애물 생성
  stageData.obstacles.forEach((obs) => {
    if (obs.type === 'circle') {
      bodies.push(Bodies.circle(obs.x, obs.y, obs.radius, obs.options));
    }
  });

  // 범퍼 생성
  stageData.bumpers.forEach((b) => {
    bodies.push(Bodies.circle(b.x, b.y, b.radius, b.options));
  });

  // 타겟 생성
  stageData.targets.forEach((t) => {
    bodies.push(Bodies.circle(t.x, t.y, t.radius, t.options));
  });

  return bodies;
};
```

**함수 2: loadStage(stageIndex)**
```javascript
let currentStageIndex = 0;
let currentStageBodies = [];

const loadStage = (stageIndex) => {
  // 1. 기존 스테이지 Bodies 제거
  if (currentStageBodies.length > 0) {
    World.remove(engine.world, currentStageBodies);
  }

  // 2. 새 스테이지 Bodies 생성 및 추가
  const stageData = stages[stageIndex];
  currentStageBodies = createStageBodies(stageData);
  World.add(engine.world, currentStageBodies);

  // 3. 공 위치/속도 초기화
  Body.setPosition(ball, { x: 250, y: 400 });
  Body.setVelocity(ball, { x: 0, y: 0 });
  Body.setAngularVelocity(ball, 0);

  // 4. 스테이지 인덱스 업데이트
  currentStageIndex = stageIndex;

  console.log(`Stage loaded: ${stageData.name}`);
};
```

**특징:**
- `currentStageBodies` 배열로 현재 스테이지의 Bodies 추적
- `World.remove()` → 새 Bodies 생성 → `World.add()` 순서로 전환
- 공 초기화로 새 스테이지에서 다시 시작

### 3. 키보드 입력 처리

**handleKeyDown 함수에 추가:**
```javascript
if (event.key === 'n' || event.key === 'N') {
  const nextIndex = (currentStageIndex + 1) % stages.length;
  loadStage(nextIndex);
  console.log(`Stage changed to: ${stages[nextIndex].name}`);
}
```

**특징:**
- 'n' 또는 'N' 키로 다음 스테이지 전환
- `% stages.length`로 마지막 스테이지 → 첫 스테이지 순환

### 4. 초기 로딩 구조 변경

**변경 전:**
```javascript
// 개별 Bodies 생성
const obstacle1 = Bodies.circle(300, 300, 30, { isStatic: true });
const obstacle2 = Bodies.circle(500, 300, 30, { isStatic: true });
const bumper = Bodies.circle(400, 600, 40, { isStatic: true, restitution: 1.5, label: 'bumper' });
const target = Bodies.circle(500, 500, 40, { isStatic: true, restitution: 1.5, label: 'target' });

// 모든 Bodies를 World.add
World.add(engine.world, [
  ground, leftWall, rightWall, upWall, deathZone,
  ball, obstacle1, obstacle2, bumper, target,
  leftFlipper, rightFlipper,
  leftFlipperConstraint, rightFlipperConstraint
]);
```

**변경 후:**
```javascript
// 공통 Bodies만 World.add (벽, 플리퍼, 공, 죽음구역)
World.add(engine.world, [
  ground, leftWall, rightWall, upWall, deathZone,
  ball,
  leftFlipper, rightFlipper,
  leftFlipperConstraint, rightFlipperConstraint
]);

// 첫 번째 스테이지 로드
loadStage(0);
```

**특징:**
- 하드코딩된 장애물/범퍼/타겟 생성 코드 제거
- 공통 Bodies와 스테이지별 Bodies 분리
- `loadStage(0)`으로 첫 스테이지 초기화

## 현재 상태 분석 결과

### Pinball.jsx 구조 파악
- useEffect 내부에 모든 Bodies가 하드코딩되어 있음
- 키보드 핸들러(handleKeyDown/handleKeyUp) 이미 구현됨
- `World.add()`/`World.remove()` 사용 가능
- `ballRef`, `livesRef` 등 ref 사용 중
- cleanup 함수에서 `Engine.clear()` 호출로 모든 Bodies 정리

### 확장성 고려사항
- 스테이지 데이터를 별도 파일로 분리하여 관리 용이
- `createStageBodies()` 함수로 재사용성 확보
- `loadStage()` 함수로 스테이지 전환 로직 캡슐화
- 향후 스테이지별 배경이미지 변경 가능 (background 속성)

## 실행계획 문서 구성

### PRD/핀볼-맵-전환-실행계획.md

**섹션 구성:**
1. 요구사항 요약: 스테이지 전환 목적 및 'n' 키 테스트 기능
2. 현재상태 분석: 하드코딩된 Bodies 구조, 스테이지 개념 부재
3. 구현 방법: 스테이지 데이터 배열화, 동적 Bodies 생성/제거
4. 구현 단계: 6단계 (stages.js 생성, createStageBodies, loadStage, 초기화 변경, 'n' 키 핸들러, cleanup)
5. 수정/생성할 파일 목록: stages.js (생성), Pinball.jsx (수정)
6. 완료 체크리스트: 8개 항목 (스테이지 표시, 전환, 공 초기화, 순환, 벽/플리퍼 동작, 로그, 에러 확인)

**각 구현 단계 구성:**
- 단계 제목
- 코드 블록 (실제 구현 코드)
- 코드 설명 (bullet point)

## 결과
- 상태: 실행계획 완료 (구현은 미진행)
- 산출물: PRD/핀볼-맵-전환-실행계획.md

## 배운내용
레벨이라는 배열이 필요하다.
레벨 배열 안에는 레벨 안에 들어갈 객체들의 정보를 넣는다.
객체들의 정보들은 데이터의 집합과 같다.
이 데이터 집합을 레벨이 바뀔때
객체를 배치해주는 공장(함수) 에 넣는다.
이미 적인 객체 유형, 옵션을 공장에 넣어주면 공장은 자동으로 객체를 배치해준다.
이렇게 배치한 객체들은 "현재 객체" 배열에 미리 넣어주고
wolrd.add 에도 "현재 객체" 배열로 처리.
wolrd.remove 도 "현재 객체" 배열로 지워준다.

## 다음 작업
- PRD/핀볼-맵-전환-실행계획.md 구현 (stages.js 생성, Pinball.jsx 수정)
- 스테이지별 배경이미지 변경 기능 추가 (선택 사항)
- 스테이지 번호 UI 표시 (우측 상단에 "STAGE: X" 표시)
- 스테이지 클리어 조건 추가 (모든 target 충돌 시 자동 전환)


## 기본 정보
- 날짜: 2026-01-28 (화) 17:52~18:02
- 작성자: hexsera

## 진행 목표
핀볼 게임 화면이 사용자의 브라우저 크기에 맞게 동적으로 조정되도록 구현하여 다양한 화면 크기에서 최적의 게임 경험 제공.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 핀볼 화면 동적 크기변경 | | |

**총 작업시간: 10분**

## 주요 변경 사항

### 1. react/main/src/Pinball.jsx 수정

#### 변경 1: 화면 크기 상태 추가

**변경 전:**
```javascript
function Pinball() {
  const sceneRef = useRef(null);
  const bgmRef = useRef(null);
  const ballRef = useRef(null);
  const livesRef = useRef(3);
  const [isPlaying, setIsPlaying] = useState(false);
  const [score, setScore] = useState(30);
  const [lives, setLives] = useState(3);

  const BASE_WIDTH = 816;
  const BASE_HEIGHT = 1296;
```

**변경 후:**
```javascript
function Pinball() {
  const sceneRef = useRef(null);
  const bgmRef = useRef(null);
  const ballRef = useRef(null);
  const livesRef = useRef(3);
  const [isPlaying, setIsPlaying] = useState(false);
  const [score, setScore] = useState(30);
  const [lives, setLives] = useState(3);
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  const [gameScale, setGameScale] = useState(1);

  const BASE_WIDTH = 816;
  const BASE_HEIGHT = 1296;
```

**특징:**
- `windowSize`: 브라우저 창의 현재 너비와 높이 저장
- `gameScale`: 계산된 게임 화면 스케일 비율 저장 (기본값: 1)
- `window.innerWidth/innerHeight`로 초기값 설정

#### 변경 2: 최적 스케일 계산 함수 구현

**추가:**
```javascript
// 최적 스케일 계산 함수
const calculateScale = useCallback(() => {
  const canvasWidth = 700;
  const canvasHeight = 1200;
  const padding = 120; // 여백 (사용자가 40 → 120으로 조정)

  // 화면 너비/높이 기준으로 각각 계산
  const scaleByWidth = (windowSize.width - padding) / canvasWidth;
  const scaleByHeight = (windowSize.height - padding) / canvasHeight;

  // 둘 중 작은 값을 선택하여 화면에 꽉 차지 않도록
  const optimalScale = Math.min(scaleByWidth, scaleByHeight, 1);

  setGameScale(optimalScale);
}, [windowSize]);
```

**특징:**
- `useCallback`으로 함수 메모이제이션 (windowSize 변경 시에만 재생성)
- 캔버스 크기(700×1200) 대비 화면 크기로 스케일 계산
- `Math.min()`으로 너비/높이 기준 중 작은 값 선택 → 화면 벗어남 방지
- 최대 스케일 1로 제한 (원본보다 크게 표시하지 않음)
- padding 120으로 여백 확보 (사용자 요청 반영)

#### 변경 3: resize 이벤트 리스너 등록

**추가:**
```javascript
// 창 크기 변경 이벤트 리스너
useEffect(() => {
  const handleResize = () => {
    setWindowSize({
      width: window.innerWidth,
      height: window.innerHeight
    });
  };

  window.addEventListener('resize', handleResize);

  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []);
```

**특징:**
- `window.addEventListener('resize', handleResize)`로 창 크기 변경 감지
- 의존성 배열 `[]`로 컴포넌트 마운트 시 한 번만 등록
- cleanup 함수에서 `removeEventListener`로 메모리 누수 방지

#### 변경 4: windowSize 변경 시 스케일 재계산

**추가:**
```javascript
// windowSize 변경 시 스케일 재계산
useEffect(() => {
  calculateScale();
}, [windowSize, calculateScale]);
```

**특징:**
- `windowSize` 상태가 변경될 때마다 `calculateScale()` 호출
- `gameScale` 상태 자동 업데이트
- 의존성 배열에 `windowSize`, `calculateScale` 포함

#### 변경 5: 동적 스케일 적용 (Box sx 수정)

**변경 전:**
```javascript
<Box sx={{
  position: 'relative',
  width: '700px',
  height: '1200px',
  backgroundImage: 'url(/images/pinball_back.png)',
  backgroundSize: '100% 100%',
  backgroundPosition: 'center',
  backgroundRepeat: 'no-repeat',
  transform: { xs: 'scale(0.5)', sm: 'scale(0.5)', md: 'scale(0.8)' },
  transformOrigin: 'top center'
}}>
```

**변경 후:**
```javascript
<Box sx={{
  position: 'relative',
  width: '700px',
  height: '1200px',
  backgroundImage: 'url(/images/pinball_back.png)',
  backgroundSize: '100% 100%',
  backgroundPosition: 'center',
  backgroundRepeat: 'no-repeat',
  transform: `scale(${gameScale})`,
  transformOrigin: 'top center'
}}>
```

**특징:**
- 기존 MUI 반응형 객체 `{ xs: 'scale(0.5)', ... }` 제거
- 템플릿 리터럴로 동적 `gameScale` 적용
- `transformOrigin: 'top center'` 유지 (중앙 기준 스케일)

### 2. PRD/핀볼-화면-크기-조정-실행계획.md 작성

**섹션 구성:**
1. 요구사항 요약: 화면 크기 조정 목적 및 필요성
2. 현재상태 분석: 고정 캔버스 크기와 CSS transform scale의 문제점
3. 구현 방법: 브라우저 화면 크기 기반 동적 스케일링 방식
4. 주요 API 설명: `window.innerWidth/innerHeight`, `Math.min()` 설명 추가
5. 구현 단계: 5단계 (상태 추가, 계산 함수, resize 리스너, 재계산 로직, 동적 적용)
6. 수정/생성할 파일 목록: Pinball.jsx (5가지 수정)
7. 완료 체크리스트: 7개 항목 (창 크기 변경, 모바일/데스크톱, 정렬, 조작, 물리, 에러)

**주요 API 설명 추가:**
- `window.innerWidth/innerHeight`: 브라우저 창의 뷰포트 크기를 픽셀 단위로 반환
- `Math.min()`: 전달된 숫자들 중 가장 작은 값 반환 (화면 벗어남 방지)

## 데이터 흐름

```
컴포넌트 마운트
        │
        ▼
windowSize 초기화 (window.innerWidth/innerHeight)
        │
        ▼
calculateScale() 호출
        │
        ▼
최적 스케일 계산 (Math.min(scaleByWidth, scaleByHeight, 1))
        │
        ▼
setGameScale(optimalScale)
        │
        ▼
Box의 transform: scale(gameScale) 적용
        │
        ▼
사용자가 브라우저 크기 변경
        │
        ▼
resize 이벤트 발생
        │
        ▼
handleResize() 호출
        │
        ▼
setWindowSize(새 크기)
        │
        ▼
useEffect 트리거 (windowSize 의존성)
        │
        ▼
calculateScale() 재호출
        │
        ▼
gameScale 업데이트
        │
        ▼
리렌더링 (transform 재적용)
```

## 구현 원리

### window.innerWidth/innerHeight
- 브라우저 창의 뷰포트 크기를 픽셀 단위로 반환
- 스크롤바를 포함한 실제 콘텐츠 표시 영역
- 예: 1920×1080 창 → `window.innerWidth`는 1920, `window.innerHeight`는 1080

### Math.min() 사용 이유
- 너비 기준 스케일과 높이 기준 스케일 중 작은 값 선택
- 예: `scaleByWidth = 0.8`, `scaleByHeight = 1.2`인 경우 → `Math.min(0.8, 1.2, 1)` = 0.8
- 가장 작은 스케일을 선택함으로써 게임 화면이 화면을 벗어나지 않도록 보장
- 세 번째 인자 `1`로 최대 확대 제한 (원본보다 크게 표시하지 않음)

### useCallback 사용 이유
- `calculateScale` 함수를 메모이제이션하여 불필요한 재생성 방지
- `windowSize`가 변경될 때만 함수 재생성
- useEffect의 의존성 배열에 함수를 포함할 때 무한 루프 방지

## 결과
- 상태: 구현 완료 (테스트 보류)

## 배운내용
- window.innerWidth/innerHeight
- Math.min()
- window.addEventListener('resize', handleResize);

## 다음 작업
- 브라우저에서 실제 동작 테스트 및 검증
- padding 값 조정 (필요 시)
- 모바일 환경에서 테스트
- 스케일 조정 시 애니메이션 효과 추가 (선택 사항)
- Lives UI와 Score UI가 스케일에 맞게 조정되는지 확인
- 핀볼 화면 크기와 UI 크기 확정짓기.

## 기본 정보
- 날짜: 2026-01-28 (수요일) 6:20~6:34 6:52~6:55
- 작성자: hexsera

## 진행 목표
핀볼 게임에서 공이 충돌할 때 충돌 소리를 재생하여 사용자에게 청각적 피드백을 제공하고 게임 몰입감을 향상시킨다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| hitSoundRef 추가 | react/main/src/Pinball.jsx | useRef로 충돌 사운드 관리 |
| Audio 객체 생성 | react/main/src/Pinball.jsx | /audio/ball_hit.wav 로드 |
| 충돌 이벤트 수정 | react/main/src/Pinball.jsx | 소리 재생 로직 추가 |
| 정리 함수 수정 | react/main/src/Pinball.jsx | 메모리 해제 로직 추가 |

## 주요 변경 사항

### 1. PRD/핀볼-충돌소리-실행계획.md 생성

**내용:**
```markdown
# 핀볼 충돌 소리 실행계획

## 요구사항 요약
- 핀볼 게임에서 공이 충돌하면 충돌하는 소리 재생
- 사용자에게 청각적 즐거움을 제공하여 게임 몰입감 향상

## 구현 방법
- HTML5 Audio API 사용 (기존 배경음악과 동일한 방식)
- Matter.js collisionStart 이벤트 활용
- public/audio/ball_hit.wav 파일 사용
```


### 2. react/main/src/Pinball.jsx 수정

**변경 1: hitSoundRef 추가 (7-8번째 줄)**

**변경 전:**
```javascript
function Pinball() {
  const sceneRef = useRef(null);
  const bgmRef = useRef(null);
  const ballRef = useRef(null);
  const livesRef = useRef(3);
```

**변경 후:**
```javascript
function Pinball() {
  const sceneRef = useRef(null);
  const bgmRef = useRef(null);
  const hitSoundRef = useRef(null);
  const ballRef = useRef(null);
  const livesRef = useRef(3);
```

**특징:**
- useRef로 충돌 사운드 Audio 객체 관리
- 컴포넌트 생애주기 동안 재사용

**변경 2: 충돌 사운드 Audio 객체 생성 (56-59번째 줄)**

**변경 전:**
```javascript
useEffect(() => {
  // 배경음악 설정
  const bgm = new Audio('/audio/back_bgm.mp3');
  bgm.loop = true;
  bgm.volume = 0.05;
  bgmRef.current = bgm;

  // Matter.js 모듈 가져오기
  const Engine = Matter.Engine;
```

**변경 후:**
```javascript
useEffect(() => {
  // 배경음악 설정
  const bgm = new Audio('/audio/back_bgm.mp3');
  bgm.loop = true;
  bgm.volume = 0.05;
  bgmRef.current = bgm;

  // 충돌 사운드 설정
  const hitSound = new Audio('/audio/ball_hit.wav');
  hitSound.volume = 0.3;
  hitSoundRef.current = hitSound;

  // Matter.js 모듈 가져오기
  const Engine = Matter.Engine;
```

**특징:**
- `/audio/ball_hit.wav` 파일 로드
- 볼륨 0.3 설정 (배경음악 0.05보다 크게)
- loop 없음 (충돌마다 한 번씩 재생)

**변경 3: 충돌 이벤트에서 소리 재생 (235-243번째 줄)**

**변경 전:**
```javascript
Events.on(engine, 'collisionStart', (event) => {
  const pairs = event.pairs;

  pairs.forEach((pair) => {
    const { bodyA, bodyB } = pair;
    //console.log(bodyA);

    // 공과 범퍼가 충돌했는지 확인
    if ((bodyA.label === 'bumper' && bodyB === ball) ||
```

**변경 후:**
```javascript
Events.on(engine, 'collisionStart', (event) => {
  const pairs = event.pairs;

  pairs.forEach((pair) => {
    const { bodyA, bodyB } = pair;
    //console.log(bodyA);

    // 공이 포함된 충돌인지 확인하여 소리 재생
    if (bodyA === ball || bodyB === ball) {
      if (hitSoundRef.current) {
        hitSoundRef.current.currentTime = 0; // 재생 위치 초기화
        hitSoundRef.current.play().catch(err => {
          console.log('Sound play failed:', err);
        });
      }
    }

    // 공과 범퍼가 충돌했는지 확인
    if ((bodyA.label === 'bumper' && bodyB === ball) ||
```

**특징:**
- 공이 포함된 모든 충돌 감지 (`bodyA === ball || bodyB === ball`)
- `currentTime = 0`으로 재생 위치 초기화 (연속 충돌 시 소리 겹침 방지)
- `play().catch()`로 에러 처리 (브라우저 자동 재생 정책 대응)
- 벽, 플리퍼, bumper, target 등 모든 오브젝트 충돌에서 소리 재생

**변경 4: 정리 함수에 메모리 해제 (395-398번째 줄)**

**변경 전:**
```javascript
return () => {
  if (bgmRef.current) {
    bgmRef.current.pause();
    bgmRef.current.currentTime = 0;
  }
  Events.off(engine, 'beforeUpdate');
  Events.off(engine, 'collisionStart');
```

**변경 후:**
```javascript
return () => {
  if (bgmRef.current) {
    bgmRef.current.pause();
    bgmRef.current.currentTime = 0;
  }
  if (hitSoundRef.current) {
    hitSoundRef.current.pause();
    hitSoundRef.current.currentTime = 0;
  }
  Events.off(engine, 'beforeUpdate');
  Events.off(engine, 'collisionStart');
```

**특징:**
- 컴포넌트 언마운트 시 충돌 사운드 정지
- `pause()` 및 `currentTime = 0` 호출로 메모리 누수 방지

## 결과
- 상태: 완료
- 공이 모든 오브젝트(벽, 플리퍼, bumper, target 등)와 충돌할 때 소리 재생
- 연속 충돌 시 소리가 겹치지 않고 새로 재생
- 메모리 누수 없이 정리 완료

## 아키텍처 구조

### 충돌 소리 재생 흐름
```
Matter.js Physics Engine
        │
        ▼
Collision Detection (collisionStart)
        │
        ▼
공 포함 충돌 확인 (bodyA === ball || bodyB === ball)
        │
        ▼
hitSoundRef.current.currentTime = 0
        │
        ▼
hitSoundRef.current.play()
        │
        ▼
/audio/ball_hit.wav 재생
```

### Audio 객체 생애주기
```
Component Mount
        │
        ▼
useEffect 실행
        │
        ▼
new Audio('/audio/ball_hit.wav')
        │
        ▼
hitSoundRef.current = hitSound
        │
        ▼
게임 플레이 중 (충돌마다 재생)
        │
        ▼
Component Unmount
        │
        ▼
hitSoundRef.current.pause()
        │
        ▼
메모리 해제
```

## 배운내용


## 다음 작업
- 충돌 소리 볼륨 조절 기능 추가 (설정 UI)
- 다양한 충돌 소리 적용 (bumper, target 등 각각 다른 소리)
- 효과음 On/Off 토글 버튼 추가
- 브라우저 자동 재생 정책 대응 개선 (사용자 인터랙션 후 활성화)

## 기본 정보
- 날짜: 2026-01-28 (수요일) 19:17~19:32 20:13~20:16
- 작성자: hexsera

## 진행 목표
범퍼 이쁘게 변경

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 범퍼 이미지 검색 | | |

## 주요 변경 사항
없음

## 배운내용
핀볼용 이미지를 찾기 좀 어렵다... 1시간동안 뒤져야 마음에 드는게 나올텐데...
이 마음이 욕심인걸까?

## 다음 작업
- 이미지 씌울 방법 모색 (CSS 를 사용할것인가?)

## 기본 정보
- 날짜: 2026-01-28 (수요일) 20:31~21:10
- 작성자: hexsera

## 진행 목표
핀볼 게임에 UI 영역(700x100px)과 게임 영역(700x1100px)을 분리하여 추가 변경사항으로 인한 사양변경과 개발 부채를 줄임.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| Matter.js 캔버스 높이 변경 | react/main/src/Pinball.jsx |  |
| UI 영역 Box 추가 | react/main/src/Pinball.jsx | |
| 게임 영역 Box 추가 | react/main/src/Pinball.jsx |  |
| 레이아웃 구조 변경 | react/main/src/Pinball.jsx | flexDirection: column |

**총 6분**

## 주요 변경 사항

### 1. PRD/핀볼-UI-비율-조정-실행계획.md 생성

**내용:**
```markdown
# 핀볼 UI 비율 조정 실행계획

## 요구사항 요약
- 핀볼 게임에 UI 영역(700x100px)과 게임 영역(700x1100px)을 분리
- 영역을 확정시켜 추가 변경사항으로 인한 사양변경과 개발 부채를 줄임

## 구현 방법
- Material-UI Box 컴포넌트 (UI 영역 컨테이너)
- Matter.js Render 옵션 수정 (캔버스 높이 변경)
- CSS Flexbox (수직 레이아웃)
```

**특징:**
- Matter.js 캔버스 높이를 1200px → 1100px로 변경 (사용자 요청 반영)
- UI 영역 높이를 300px → 100px로 축소 (사용자 요청 반영)
- 게임 오브젝트 좌표 조정은 별도 작업으로 분리

### 2. react/main/src/Pinball.jsx 수정

**변경 1: Matter.js 캔버스 높이 변경 (87번째 줄)**

**변경 전:**
```javascript
const render = Render.create({
  element: sceneRef.current,
  engine: engine,
  options: {
    width: 700,
    height: 1200,
    wireframes: false,
    background: 'transparent'
  }
});
```

**변경 후:**
```javascript
const render = Render.create({
  element: sceneRef.current,
  engine: engine,
  options: {
    width: 700,
    height: 1100,
    wireframes: false,
    background: 'transparent'
  }
});
```

**특징:**
- 캔버스 높이를 1200px에서 1100px로 변경
- width는 700px 유지
- 게임 영역이 100px 줄어듦

**변경 2: UI 영역 Box 추가 및 레이아웃 변경 (468-513번째 줄)**

**변경 전:**
```javascript
<Box sx={{
  position: 'relative',
  width: '700px',
  height: '1200px',
  backgroundImage: 'url(/images/pinball_back.png)',
  backgroundSize: '100% 100%',
  backgroundPosition: 'center',
  backgroundRepeat: 'no-repeat',
  transform: `scale(${gameScale})`,
  transformOrigin: 'top center'
}}>
  {/* 점수 표시 UI */}
  <Box sx={{
    position: 'absolute',
    top: '20px',
    right: '20px',
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    padding: '10px 20px',
    borderRadius: '8px',
    border: '2px solid #ffffff'
  }}>
    <Typography sx={{
      fontSize: '24px',
      fontWeight: 'bold',
      color: '#ffffff',
    }}>
      SCORE: {score}
    </Typography>
  </Box>

  <div ref={sceneRef} />
</Box>
```

**변경 후:**
```javascript
<Box sx={{
  position: 'relative',
  width: '700px',
  height: '1200px',
  transform: `scale(${gameScale})`,
  transformOrigin: 'top center'
}}>
  {/* UI 영역 (상단 100px) */}
  <Box sx={{
    width: '700px',
    height: '100px',
    backgroundColor: '#000000',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
    alignItems: 'center'
  }}>
    <Typography sx={{
      fontSize: '48px',
      fontWeight: 'bold',
      color: '#ffffff'
    }}>
      SCORE: {score}
    </Typography>
    <Typography sx={{
      fontSize: '32px',
      fontWeight: 'bold',
      color: '#ffffff',
      marginTop: '20px'
    }}>
      LIVES: {lives}
    </Typography>
  </Box>

  {/* 게임 영역 (하단 1100px) */}
  <Box sx={{
    width: '700px',
    height: '1100px',
    backgroundImage: 'url(/images/pinball_back.png)',
    backgroundSize: '100% 100%',
    backgroundPosition: 'center',
    backgroundRepeat: 'no-repeat'
  }}>
    <div ref={sceneRef} />
  </Box>
</Box>
```

**특징:**
- UI 영역: 700x100px, 검은색 배경 (#000000)
- 점수(SCORE)와 생명(LIVES) 중앙 정렬
- 게임 영역: 700x1100px, 배경이미지 적용
- flexDirection: 'column'으로 수직 배치
- 전체 컨테이너는 1200px 높이 유지 (스케일 계산 기준)
- 기존 absolute 오버레이 UI 제거

## 레이아웃 구조

```
전체 컨테이너 (700x1200px)
├── UI 영역 (700x100px)
│   ├── SCORE 표시
│   └── LIVES 표시
└── 게임 영역 (700x1100px)
    ├── 배경이미지
    └── Matter.js 캔버스
```

## 결과
- 상태: 완료

## 배운내용


## 다음 작업
- 게임 오브젝트 y 좌표 조정 (100px만큼 이동)
- UI 영역 디자인 개선 (그라데이션, 보더 등)
- 스테이지 번호 UI 추가
