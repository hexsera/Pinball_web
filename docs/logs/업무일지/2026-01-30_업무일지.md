# 업무일지

## 기본 정보
- 날짜: 2026-01-30 (목요일) 11:00~12:00 1:00~2:00
- 작성자: hexsera

## 진행 목표
FastAPI에 월간 점수 랭킹 시스템 구축을 위한 3단계 작업 수행:
1. MonthlyScore SQLAlchemy 모델 생성
2. 월간 랭킹용 Pydantic 스키마 설계
3. CRUD API 엔드포인트 구현 (메모리 저장소 기반, Upsert 방식)

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| MonthlyScore 모델 생성 | fastapi/models.py | SQLAlchemy ORM 모델 추가 |
| Alembic 마이그레이션 생성 | fastapi/alembic/versions/7974a0858fbe_add_monthly_scores_table.py | 테이블 스키마 버전 관리 |
| 메모리 저장소 추가 | fastapi/main.py | monthly_scores, monthly_score_id_counter 변수 |
| Pydantic 스키마 5개 정의 | fastapi/main.py | 요청/응답 스키마 |
| CRUD 엔드포인트 5개 구현 | fastapi/main.py | POST, GET(2개), PUT, DELETE |

## 주요 변경 사항

### 1. fastapi/models.py 수정

**추가:**
```python
class MonthlyScore(Base):
    __tablename__ = "monthly_scores"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)
    score = Column(Integer, nullable=False, index=True)
    created_at = Column(DateTime, nullable=False, server_default=func.now(), index=True)
```

**특징:**
- 월간 점수 집계 데이터를 저장하는 전용 테이블
- 모든 필드에 인덱스 설정 (조회 성능 최적화)
- created_at으로 월별 필터링 가능 (DATE_FORMAT 활용)
- Score 테이블과 독립적으로 운영

### 2. fastapi/main.py 수정 - 메모리 저장소

**추가:**
```python
# 월간 점수 메모리 저장소 (임시)
monthly_scores: List[dict] = []
monthly_score_id_counter: int = 0
```

**특징:**
- DB 없이 빠른 프로토타입 테스트
- AUTO_INCREMENT 동작 모방 (id_counter)
- 각 dict 구조: {"id": int, "user_id": int, "score": int, "created_at": datetime}

### 3. fastapi/main.py 수정 - Pydantic 스키마

**추가:**
```python
class MonthlyScoreCreateRequest(BaseModel):
    """월간 점수 생성/수정 요청 (Upsert)"""
    user_id: int
    score: int


class MonthlyScoreUpdateRequest(BaseModel):
    """월간 점수 수정 요청"""
    score: int


class MonthlyScoreResponse(BaseModel):
    """월간 점수 응답"""
    id: int
    user_id: int
    score: int
    created_at: datetime

    class Config:
        from_attributes = True


class MonthlyScoreListResponse(BaseModel):
    """월간 점수 목록 응답"""
    scores: List[MonthlyScoreResponse]
    total: int


class MonthlyScoreDeleteResponse(BaseModel):
    """월간 점수 삭제 응답"""
    message: str
    deleted_user_id: int
```

**특징:**
- Create와 Update 스키마 분리 (각 엔드포인트 의도 명확화)
- Response에 from_attributes = True (dict → Pydantic 자동 변환)
- List 응답에 total 필드 포함 (페이지네이션 준비)

### 4. fastapi/main.py 수정 - CRUD 엔드포인트

**추가 1: POST (Upsert)**
```python
@app.post("/api/v1/monthly-scores", response_model=MonthlyScoreResponse)
def create_or_update_monthly_score(score_data: MonthlyScoreCreateRequest):
    """월간 점수 생성 또는 수정 (Upsert)"""
    global monthly_score_id_counter

    # 기존 레코드 검색
    existing_score = next(
        (s for s in monthly_scores if s["user_id"] == score_data.user_id),
        None
    )

    if existing_score:
        # 업데이트: score만 수정, created_at 유지
        existing_score["score"] = score_data.score
        return existing_score
    else:
        # 생성: 새 레코드 추가
        monthly_score_id_counter += 1
        new_score = {
            "id": monthly_score_id_counter,
            "user_id": score_data.user_id,
            "score": score_data.score,
            "created_at": datetime.now()
        }
        monthly_scores.append(new_score)
        return new_score
```

**추가 2: GET (전체 조회)**
```python
@app.get("/api/v1/monthly-scores", response_model=MonthlyScoreListResponse)
def get_monthly_scores(
    order_by: str = "score",
    order: str = "desc"
):
    """전체 월간 점수 조회 (정렬)"""
    sorted_scores = monthly_scores.copy()

    # 정렬
    reverse = (order == "desc")
    if order_by == "score":
        sorted_scores.sort(key=lambda x: x["score"], reverse=reverse)
    elif order_by == "created_at":
        sorted_scores.sort(key=lambda x: x["created_at"], reverse=reverse)
    elif order_by == "user_id":
        sorted_scores.sort(key=lambda x: x["user_id"], reverse=reverse)

    return MonthlyScoreListResponse(
        scores=sorted_scores,
        total=len(sorted_scores)
    )
```

**추가 3: GET (단일 조회)**
```python
@app.get("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreResponse)
def get_monthly_score(user_id: int):
    """특정 사용자 월간 점수 조회"""
    score = next(
        (s for s in monthly_scores if s["user_id"] == user_id),
        None
    )

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    return score
```

**추가 4: PUT (수정)**
```python
@app.put("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreResponse)
def update_monthly_score(user_id: int, score_data: MonthlyScoreUpdateRequest):
    """특정 사용자 월간 점수 수정"""
    score = next(
        (s for s in monthly_scores if s["user_id"] == user_id),
        None
    )

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    score["score"] = score_data.score
    return score
```

**추가 5: DELETE (삭제)**
```python
@app.delete("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreDeleteResponse)
def delete_monthly_score(user_id: int):
    """특정 사용자 월간 점수 삭제"""
    global monthly_scores

    score = next(
        (s for s in monthly_scores if s["user_id"] == user_id),
        None
    )

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    monthly_scores = [s for s in monthly_scores if s["user_id"] != user_id]

    return MonthlyScoreDeleteResponse(
        message="Monthly score deleted successfully",
        deleted_user_id=user_id
    )
```

**특징:**
- Upsert 로직: 같은 user_id 존재 시 점수만 업데이트, created_at 유지
- 정렬 옵션: order_by (score/created_at/user_id), order (desc/asc)
- 에러 처리: 404 Not Found (레코드 없을 때)
- global 키워드: 메모리 저장소 재할당 시 필요
- next() 함수: 리스트에서 조건 검색 (제너레이터 표현식)

## 아키텍처

### API 엔드포인트 구조
```
/api/v1/monthly-scores
├── POST              → Upsert (생성 또는 수정)
├── GET               → 전체 조회 (정렬)
├── GET /{user_id}    → 단일 조회
├── PUT /{user_id}    → 수정
└── DELETE /{user_id} → 삭제
```

### Upsert 동작 흐름
```
POST /api/v1/monthly-scores
       │
       ▼
user_id로 기존 레코드 검색
       │
       ├─ 존재함 ──→ score 업데이트, created_at 유지 → 200 OK
       │
       └─ 없음 ────→ 새 레코드 생성, id 자동 증가 → 200 OK
```



## 결과
- 상태: 완료

## 배운내용
너무 많이 했다. 학습을 전혀 못함.

## 다음 작업

- DB 연동으로 전환 (메모리 저장소 → SQLAlchemy 쿼리)
- 점수테이블 로직 수정.

---

## 기본 정보
- 날짜: 2026-01-30 (목요일) 16:30~17:10
- 작성자: hexsera

## 진행 목표
월간 점수 CRUD API 수정:
1. MonthlyScoreResponse 스키마에서 id 필드 제거 (user_id를 식별자로 사용)
2. POST API에 점수 비교 로직 추가 (새 점수가 기존 점수보다 클 때만 갱신)
3. monthly_score_id_counter 변수 제거

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| MonthlyScoreResponse id 제거 | fastapi/main.py | 스키마 수정 |
| POST API 점수 비교 로직 추가 | fastapi/main.py | Upsert 로직 개선 |
| id 카운터 변수 제거 | fastapi/main.py | monthly_score_id_counter 삭제 |

## 주요 변경 사항

### 1. fastapi/main.py 수정 - MonthlyScoreResponse 스키마

**변경 전:**
```python
class MonthlyScoreResponse(BaseModel):
    """월간 점수 응답"""
    id: int
    user_id: int
    score: int
    created_at: datetime

    class Config:
        from_attributes = True
```

**변경 후:**
```python
class MonthlyScoreResponse(BaseModel):
    """월간 점수 응답"""
    user_id: int
    score: int
    created_at: datetime

    class Config:
        from_attributes = True
```

**특징:**
- id 필드 제거하여 user_id를 고유 식별자로 사용
- 월간 점수는 사용자당 하나만 존재하는 구조에 맞춤
- API 응답에서 불필요한 id 제거로 명확성 향상

### 2. fastapi/main.py 수정 - POST API 점수 비교 로직

**변경 전:**
```python
@app.post("/api/v1/monthly-scores", response_model=MonthlyScoreResponse)
def create_or_update_monthly_score(score_data: MonthlyScoreCreateRequest):
    """월간 점수 생성 또는 수정 (Upsert)"""
    global monthly_score_id_counter

    # 기존 레코드 검색
    existing_score = next(
        (s for s in monthly_scores if s["user_id"] == score_data.user_id),
        None
    )

    if existing_score:
        # 업데이트: score만 수정, created_at 유지
        existing_score["score"] = score_data.score
        return existing_score
    else:
        # 생성: 새 레코드 추가
        monthly_score_id_counter += 1
        new_score = {
            "id": monthly_score_id_counter,
            "user_id": score_data.user_id,
            "score": score_data.score,
            "created_at": datetime.now()
        }
        monthly_scores.append(new_score)
        return new_score
```

**변경 후:**
```python
@app.post("/api/v1/monthly-scores", response_model=MonthlyScoreResponse)
def create_or_update_monthly_score(score_data: MonthlyScoreCreateRequest):
    """월간 점수 생성 또는 수정 (최고 점수만 저장)"""
    # 기존 레코드 검색
    existing_score = next(
        (s for s in monthly_scores if s["user_id"] == score_data.user_id),
        None
    )

    if existing_score:
        # 새 점수가 기존 점수보다 큰 경우에만 업데이트
        if score_data.score > existing_score["score"]:
            existing_score["score"] = score_data.score
        # 새 점수가 작거나 같으면 기존 점수 유지
        return existing_score
    else:
        # 생성: 새 레코드 추가 (id 필드 없음)
        new_score = {
            "user_id": score_data.user_id,
            "score": score_data.score,
            "created_at": datetime.now()
        }
        monthly_scores.append(new_score)
        return new_score
```

**특징:**
- 점수 비교 로직 추가: `score_data.score > existing_score["score"]`
- 새 점수가 기존 점수보다 높을 때만 갱신 (월간 최고 점수 유지)
- 낮은 점수는 무시하여 기존 점수 보호
- id 필드 제거로 dict 구조 단순화
- global monthly_score_id_counter 제거 (불필요)

### 3. fastapi/main.py 수정 - 메모리 저장소 변수

**변경 전:**
```python
# 월간 점수 메모리 저장소 (임시)
monthly_scores: List[dict] = []
monthly_score_id_counter: int = 0
```

**변경 후:**
```python
# 월간 점수 메모리 저장소 (임시)
monthly_scores: List[dict] = []
```

**특징:**
- monthly_score_id_counter 변수 제거
- id 필드가 없으므로 id 생성 카운터 불필요
- 메모리 저장소는 유지 (현재 DB 연결 안 함)

## 아키텍처

### POST API 동작 흐름 (변경 후)
```
POST /api/v1/monthly-scores
       │
       ▼
user_id로 기존 레코드 검색
       │
       ├─ 존재함 ──→ 점수 비교
       │             │
       │             ├─ 새 점수 > 기존 점수 → score 업데이트 → 200 OK
       │             │
       │             └─ 새 점수 ≤ 기존 점수 → 기존 점수 유지 → 200 OK
       │
       └─ 없음 ────→ 새 레코드 생성 (id 없음) → 200 OK
```

### 데이터 구조 변경
```
변경 전 dict:
{
  "id": 1,                    ← 제거됨
  "user_id": 100,
  "score": 5000,
  "created_at": "2026-01-30T..."
}

변경 후 dict:
{
  "user_id": 100,             ← 식별자로 사용
  "score": 7000,
  "created_at": "2026-01-30T..."
}
```

## 결과
- 상태: 완료

## 배운내용


## 다음 작업
- DB 연동으로 전환 (메모리 저장소 → SQLAlchemy 쿼리)
- React 프론트엔드에서 월간 점수 API 연동
- 월간 랭킹 화면 구현

---

## 기본 정보
- 날짜: 2026-01-30 (목요일) 17:30~18:30 7:05~7:45
- 작성자: hexsera

## 진행 목표
친구 추가 API 중복 방지 기능 구현:
1. DB 레벨: Friendship 테이블에 UNIQUE 제약조건 추가
2. API 레벨: 중복 및 역방향 검증 로직 추가
3. 메모리 저장소 제거: DB를 단일 진실 소스로 변경

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| Friendship 모델 제약조건 추가 | fastapi/models.py | UniqueConstraint, CheckConstraint |
| Alembic 마이그레이션 생성 | fastapi/alembic/versions/afd5d050d260_*.py | 제약조건 적용 |
| 기존 중복 데이터 정리 | MySQL friendships 테이블 | 4개 레코드 정리 |
| 마이그레이션 적용 | MySQL DB | UNIQUE/CHECK 제약조건 추가 |
| 친구 요청 생성 API 수정 | fastapi/main.py | 중복/역방향 검증 로직 추가 |
| GET /api/friend-requests 수정 | fastapi/main.py | DB 조회로 변경 |
| 메모리 저장소 제거 | fastapi/main.py | friend_requests 배열 제거 |
| 역방향 검증 버그 수정 | fastapi/main.py | rejected 상태 처리 추가 |

## 주요 변경 사항

### 1. fastapi/models.py 수정 - Friendship 모델

**변경 전:**
```python
from sqlalchemy import Column, Integer, String, Date, DateTime
from sqlalchemy.sql import func

class Friendship(Base):
    __tablename__ = "friendships"

    id = Column(Integer, primary_key=True, index=True)
    requester_id = Column(Integer, nullable=False, index=True)
    receiver_id = Column(Integer, nullable=False, index=True)
    status = Column(String(20), nullable=False, default='pending')
    created_at = Column(DateTime, nullable=False, server_default=func.now(), index=True)
```

**변경 후:**
```python
from sqlalchemy import Column, Integer, String, Date, DateTime, UniqueConstraint, CheckConstraint
from sqlalchemy.sql import func

class Friendship(Base):
    __tablename__ = "friendships"

    id = Column(Integer, primary_key=True, index=True)
    requester_id = Column(Integer, nullable=False, index=True)
    receiver_id = Column(Integer, nullable=False, index=True)
    status = Column(String(20), nullable=False, default='pending')
    created_at = Column(DateTime, nullable=False, server_default=func.now(), index=True)

    __table_args__ = (
        UniqueConstraint('requester_id', 'receiver_id', name='uq_friendship_pair'),
        CheckConstraint('requester_id != receiver_id', name='ck_no_self_friend'),
    )
```

**특징:**
- UniqueConstraint: (requester_id, receiver_id) 조합의 유일성 보장
- CheckConstraint: 자기 자신 친구 추가 방지
- DB 레벨에서 물리적 중복 차단 (가장 안전한 방법)

### 2. fastapi/main.py 수정 - 친구 요청 생성 API

**변경 전:**
```python
@app.post("/api/friend-requests", response_model=FriendRequestResponse)
def create_friend_request(request: FriendRequestRequest, db: Session = Depends(get_db)):
    """친구 추가 요청을 받는 엔드포인트 (DB와 메모리에 저장)"""

    # 1. DB에 Friendship 레코드 생성
    db_friendship = Friendship(
        requester_id=request.requester_id,
        receiver_id=request.receiver_id,
        status="pending"
    )
    db.add(db_friendship)
    db.commit()
    db.refresh(db_friendship)

    print(f"친구 요청 저장됨 (DB+메모리): {request.requester_id} -> {request.receiver_id}")

    return FriendRequestResponse(
        message="Friend request received",
        receiver_id=db_friendship.receiver_id,
        requester_id=db_friendship.requester_id
    )
```

**변경 후:**
```python
@app.post("/api/friend-requests", response_model=FriendRequestResponse)
def create_friend_request(request: FriendRequestRequest, db: Session = Depends(get_db)):
    """친구 추가 요청 (중복 및 역방향 검증)"""

    # 자기 자신에게 친구 요청 방지
    if request.requester_id == request.receiver_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot send friend request to yourself"
        )

    # 중복 검증: A→B 요청이 이미 존재하는지 확인
    existing_request = db.query(Friendship).filter(
        Friendship.requester_id == request.requester_id,
        Friendship.receiver_id == request.receiver_id
    ).first()

    if existing_request:
        if existing_request.status == "pending":
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Friend request already sent"
            )
        elif existing_request.status == "accepted":
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Already friends"
            )
        elif existing_request.status == "rejected":
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Friend request was rejected"
            )

    # 역방향 검증: B→A 요청이 이미 존재하는지 확인
    reverse_request = db.query(Friendship).filter(
        Friendship.requester_id == request.receiver_id,
        Friendship.receiver_id == request.requester_id
    ).first()

    if reverse_request:
        if reverse_request.status == "pending":
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="This user already sent you a friend request. Please accept or reject it first."
            )
        elif reverse_request.status == "accepted":
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Already friends"
            )
        elif reverse_request.status == "rejected":
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Cannot send friend request. Previous request was rejected."
            )

    # 모든 검증 통과 시 친구 요청 생성
    db_friendship = Friendship(
        requester_id=request.requester_id,
        receiver_id=request.receiver_id,
        status="pending"
    )
    db.add(db_friendship)
    db.commit()
    db.refresh(db_friendship)

    print(f"친구 요청 생성됨: {request.requester_id} -> {request.receiver_id}")

    return FriendRequestResponse(
        message="Friend request sent successfully",
        receiver_id=db_friendship.receiver_id,
        requester_id=db_friendship.requester_id
    )
```

**특징:**
- 자기 자신 친구 요청 방지 (API 레벨)
- 동일 요청 중복 검증 (pending/accepted/rejected 상태별 메시지)
- 역방향 요청 검증 (B→A 요청 차단, rejected 상태 포함)
- DB 제약조건과 이중 안전장치 구성

### 3. fastapi/main.py 수정 - GET /api/friend-requests

**변경 전:**
```python
@app.get("/api/friend-requests", response_model=FriendRequestListResponse)
def get_friend_requests(user_id: int):
    """특정 사용자가 받은 친구 요청 조회"""
    # requester_id가 user_id와 일치하는 요청 필터링
    user_requests = [
        req for req in friend_requests
        if req["requester_id"] == user_id
    ]

    return FriendRequestListResponse(requests=user_requests)
```

**변경 후:**
```python
@app.get("/api/friend-requests", response_model=FriendRequestListResponse)
def get_friend_requests(user_id: int, db: Session = Depends(get_db)):
    """특정 사용자가 받은 친구 요청 조회 (DB 연동)"""
    # DB에서 receiver_id가 user_id인 pending 요청 조회
    requests = db.query(Friendship).filter(
        Friendship.receiver_id == user_id,
        Friendship.status == "pending"
    ).all()

    # FriendRequestData 형식으로 변환
    request_data = [
        FriendRequestData(
            id=req.id,
            requester_id=req.requester_id,
            status=req.status
        )
        for req in requests
    ]

    return FriendRequestListResponse(requests=request_data)
```

**특징:**
- 메모리 배열 대신 DB에서 실제 데이터 조회
- receiver_id가 user_id이고 status가 pending인 요청만 필터링
- DB와 API의 데이터 일관성 확보

### 4. fastapi/main.py 수정 - 메모리 저장소 제거

**변경 전:**
```python
app = FastAPI(title="Hexsera API", version="1.0.0")

# 친구 요청 메모리 저장소 (임시)
friend_requests: List[dict] = []

# 월간 점수 메모리 저장소 (임시)
monthly_scores: List[dict] = []
```

**변경 후:**
```python
app = FastAPI(title="Hexsera API", version="1.0.0")

# 월간 점수 메모리 저장소 (임시)
monthly_scores: List[dict] = []
```

**특징:**
- friend_requests 메모리 배열 제거
- DB가 단일 진실 소스(Single Source of Truth)가 됨
- monthly_scores는 유지 (별도 마이그레이션 필요)

## 아키텍처

### 중복 방지 이중 안전장치
```
┌─────────────────────────────────────────────┐
│      API Level (사용자 친화적 메시지)        │
│  ┌─────────────────────────────────────┐   │
│  │ 1. 자기 자신 검증                    │   │
│  │ 2. 동일 요청 검증 (pending/accepted) │   │
│  │ 3. 역방향 요청 검증 (pending/rejected)│   │
│  └─────────────────────────────────────┘   │
└────────────────┬────────────────────────────┘
                 │ 검증 통과
                 ▼
┌─────────────────────────────────────────────┐
│      DB Level (물리적 제약)                  │
│  ┌─────────────────────────────────────┐   │
│  │ UNIQUE (requester_id, receiver_id)  │   │
│  │ CHECK (requester_id != receiver_id) │   │
│  └─────────────────────────────────────┘   │
└─────────────────────────────────────────────┘
```

### 검증 로직 흐름
```
친구 요청 생성 (A → B)
       │
       ▼
자기 자신 검증 (A == B?)
       │ No
       ▼
동일 요청 검증 (A→B 존재?)
       │ No
       ▼
역방향 요청 검증 (B→A 존재?)
       │
       ├─ pending → "상대방이 이미 요청을 보냄"
       ├─ accepted → "이미 친구"
       ├─ rejected → "이전 요청이 거절됨"
       └─ 없음 → 친구 요청 생성
```

### 데이터 흐름 변경
```
변경 전 (메모리 + DB):
API → friend_requests (메모리) → 재시작 시 손실
  └─→ DB (friendships 테이블) → 영구 저장

변경 후 (DB만):
API → DB (friendships 테이블) → 단일 진실 소스
```

## 발견된 버그 및 해결

### 버그: 역방향 검증 누락 (rejected 상태)

**문제:**
- 2→1 요청이 rejected 상태일 때, 1→2 요청이 생성됨
- 역방향 검증에서 rejected 상태 처리가 누락

**원인:**
```python
if reverse_request:
    if reverse_request.status == "pending":
        # 에러 발생
    elif reverse_request.status == "accepted":
        # 에러 발생
    # rejected 상태는 처리하지 않음 → 검증 통과!
```

**해결:**
```python
elif reverse_request.status == "rejected":
    raise HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail="Cannot send friend request. Previous request was rejected."
    )
```

## 결과
- 상태: 완료


## 배운내용


## 다음 작업
- 프론트엔드에서 친구 추가 기능 연동
- 친구 목록 조회 화면 구현
- 친구 요청 알림 기능 추가