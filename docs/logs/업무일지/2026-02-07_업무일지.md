# 업무일지

## 기본 정보
- 날짜: 2026-02-07 (금) 10:00~10:30
- 작성자: hexsera

## 진행 목표
frontend(React)에 TDD(Test-Driven Development) 구조를 구축하여 앞으로 새로운 기능 개발 시 테스트 우선 개발 방식을 적용할 수 있는 환경을 만든다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| TDD 구조 실행계획 작성 | PRD/TDD-구조생성-실행계획.md | Vitest 기반 TDD 구조 설계 |
| 테스트 패키지 설치 | frontend/package.json | vitest, @testing-library/react 등 5개 패키지 설치 |
| Vitest 설정 파일 생성 | frontend/vitest.config.js | jsdom 환경, globals, setupFiles 설정 |
| 테스트 셋업 파일 생성 | frontend/src/test/setup.js | jest-dom 매처 전역 등록 |
| 테스트 스크립트 추가 | frontend/package.json | test, test:run, test:ui 명령어 추가 |
| 샘플 테스트 작성 | frontend/src/test/sample.test.jsx | TDD 구조 검증용 테스트 |
| 테스트 실행 검증 | - | 1개 테스트 통과 확인 |

## 주요 변경 사항

### 1. frontend/package.json 수정

**변경 전:**
```json
"scripts": {
  "start": "vite",
  "build": "vite build"
},
"devDependencies": {
  "@vitejs/plugin-react": "^5.1.2",
  "vite": "^7.3.0"
}
```

**변경 후:**
```json
"scripts": {
  "start": "vite",
  "build": "vite build",
  "test": "vitest",
  "test:run": "vitest run",
  "test:ui": "vitest --ui"
},
"devDependencies": {
  "@testing-library/jest-dom": "^6.9.1",
  "@testing-library/react": "^16.3.2",
  "@testing-library/user-event": "^14.6.1",
  "@vitejs/plugin-react": "^5.1.2",
  "@vitest/ui": "^4.0.18",
  "jsdom": "^28.0.0",
  "vite": "^7.3.0",
  "vitest": "^4.0.18"
}
```

**특징:**
- 테스트 실행을 위한 3개의 npm 스크립트 추가
- `test`: watch 모드로 테스트 실행 (파일 변경 시 자동 재실행)
- `test:run`: 한 번만 실행하고 종료 (CI/CD 환경용)
- `test:ui`: 브라우저에서 시각적으로 테스트 결과 확인
- vitest 및 React Testing Library 관련 패키지 5개 추가

### 2. frontend/vitest.config.js 생성

**추가:**
```javascript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: './src/test/setup.js',
  },
});
```

**특징:**
- `environment: 'jsdom'`: 브라우저 없이 DOM 환경 시뮬레이션
- `globals: true`: describe, it, expect 등을 import 없이 사용 가능
- `setupFiles`: 모든 테스트 실행 전 setup.js 자동 실행
- Vite의 React 플러그인 재사용하여 별도의 Babel 설정 불필요

### 3. frontend/src/test/setup.js 생성

**추가:**
```javascript
import '@testing-library/jest-dom';
```

**특징:**
- jest-dom 매처를 전역으로 등록
- `toBeInTheDocument()`, `toBeVisible()`, `toHaveTextContent()` 등 DOM 전용 매처 사용 가능
- vitest.config.js의 setupFiles 설정에 의해 모든 테스트 실행 전 자동 실행

### 4. frontend/src/test/sample.test.jsx 생성

**추가:**
```javascript
import { render, screen } from '@testing-library/react';
import { describe, it, expect } from 'vitest';

describe('TDD 구조 검증', () => {
  it('테스트 환경이 정상적으로 작동한다', () => {
    render(<div>테스트 성공</div>);
    expect(screen.getByText('테스트 성공')).toBeInTheDocument();
  });
});
```

**특징:**
- TDD 구조가 올바르게 설정되었는지 검증하는 샘플 테스트
- `render()`: JSX를 가상 DOM에 렌더링
- `screen.getByText()`: 렌더링된 화면에서 텍스트로 요소 찾기
- `toBeInTheDocument()`: 요소가 DOM에 존재하는지 확인 (jest-dom 매처)

### 5. PRD/TDD-구조생성-실행계획.md 생성

**추가:**
- 요구사항 요약: TDD 구조 생성 목적 명시
- 현재상태 분석: 테스트 프레임워크 미설치 상태 확인
- 구현 방법: Vitest + React Testing Library 선정 이유
- 구현 단계: 6단계 상세 절차 (패키지 설치 → 설정 → 검증)
- 수정/생성할 파일 목록: 4개 파일
- 완료 체크리스트: 3개 항목

**특징:**
- Vitest 선정 이유: Vite 기반 프로젝트의 표준 테스트 프레임워크
- Jest 호환 API 제공으로 학습 곡선 낮음
- 별도의 Babel/Webpack 설정 불필요

## 아키텍처 구조

### TDD 테스트 실행 흐름

```
npm test 실행
    │
    ▼
vitest.config.js 로드
    │
    ├─→ environment: 'jsdom' 설정
    ├─→ globals: true 설정
    └─→ setupFiles 실행
            │
            ▼
    src/test/setup.js 실행
            │
            ▼
    @testing-library/jest-dom 매처 등록
            │
            ▼
    *.test.jsx 파일 스캔
            │
            ▼
    테스트 실행 및 결과 출력
```

### 프로젝트 디렉토리 구조 (테스트 관련)

```
frontend/
├── package.json (test 스크립트 추가)
├── vitest.config.js (Vitest 설정)
└── src/
    └── test/
        ├── setup.js (jest-dom 전역 등록)
        └── sample.test.jsx (샘플 테스트)
```

## 결과
- 상태: 완료

## 배운내용


## 다음 작업
- 복잡한 컴포넌트(AuthContext, Pinball 등) 테스트 작성 시 추가 mocking 전략 수립 필요

# 업무일지

## 기본 정보
- 날짜: 2026-02-07 (금) 10:33~11:10 11:10~11:50
- 작성자: hexsera

## 진행 목표
친구 페이지에 닉네임 검색 기능을 TDD 방식으로 구현한다. API 없이 Mock 데이터를 사용하여 검색 기능을 먼저 구현하고, 검색 결과에 "친구추가" 버튼을 표시한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 친구 페이지 추가 | frontend/src/FriendPage.jsx | |
| 검색 테스트 파일 생성 | frontend/src/test/FriendSearch.test.jsx | 6개 테스트 케이스 작성 |
| FriendPage 검색 기능 구현 | frontend/src/FriendPage.jsx | Mock 데이터, 검색 UI, 검색 로직, 친구추가 버튼 구현 |



## 주요 변경 사항



### 2. frontend/src/test/FriendSearch.test.jsx 생성

**추가:**
```javascript
import { render, screen } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import userEvent from '@testing-library/user-event';
import FriendPage from '../FriendPage';

describe('FriendPage 검색기능', () => {
  it('검색바가 존재한다', () => {
    render(<FriendPage />);
    const searchInput = screen.getByPlaceholderText('닉네임을 입력하세요');
    expect(searchInput).toBeInTheDocument();
  });

  it('검색 버튼이 존재한다', () => {
    render(<FriendPage />);
    const searchButton = screen.getByRole('button', { name: '검색' });
    expect(searchButton).toBeInTheDocument();
  });

  it('검색바에 닉네임을 입력할 수 있다', async () => {
    const user = userEvent.setup();
    render(<FriendPage />);

    const searchInput = screen.getByPlaceholderText('닉네임을 입력하세요');
    await user.type(searchInput, '테스트유저');

    expect(searchInput).toHaveValue('테스트유저');
  });

  it('검색 버튼 클릭 시 사용자 리스트가 표시된다', async () => {
    const user = userEvent.setup();
    render(<FriendPage />);

    const searchInput = screen.getByPlaceholderText('닉네임을 입력하세요');
    await user.type(searchInput, '테스트');

    const searchButton = screen.getByRole('button', { name: '검색' });
    await user.click(searchButton);

    const results = await screen.findAllByText(/테스트유저/);
    expect(results.length).toBeGreaterThan(0);
  });

  it('검색 결과가 없으면 안내 메시지를 표시한다', async () => {
    const user = userEvent.setup();
    render(<FriendPage />);

    const searchInput = screen.getByPlaceholderText('닉네임을 입력하세요');
    await user.type(searchInput, 'zzz존재하지않는닉네임zzz');

    const searchButton = screen.getByRole('button', { name: '검색' });
    await user.click(searchButton);

    const message = await screen.findByText('검색 결과가 없습니다');
    expect(message).toBeInTheDocument();
  });

  it('검색 결과 각 항목에 "친구추가" 버튼이 존재한다', async () => {
    const user = userEvent.setup();
    render(<FriendPage />);

    const searchInput = screen.getByPlaceholderText('닉네임을 입력하세요');
    await user.type(searchInput, '테스트');

    const searchButton = screen.getByRole('button', { name: '검색' });
    await user.click(searchButton);

    const addButtons = await screen.findAllByRole('button', { name: '친구추가' });
    expect(addButtons.length).toBeGreaterThan(0);
  });
});
```

**특징:**
- 6개의 테스트 케이스로 검색 기능 전체 검증
- `userEvent`를 사용하여 사용자 상호작용 시뮬레이션
- `findAllByText`, `findByText`로 비동기 렌더링 처리
- 검색 결과가 여러 개일 때 `findAllByText` 사용
- "친구추가" 버튼이 검색 결과 개수만큼 존재하는지 검증

### 3. frontend/src/FriendPage.jsx 수정

**변경 전:**
```javascript
import React from 'react';
import { Box, Paper } from '@mui/material';

function FriendPage() {
  return (
    <Box data-testid="friend-page" sx={{ display: 'flex', width: '100%', gap: 2 }}>
      <Box data-testid="friend-left-area" sx={{ width: '60%' }}>
        <Paper sx={{ p: 2, minHeight: '200px' }}>
          {/* 왼쪽 영역 콘텐츠 */}
        </Paper>
      </Box>
      <Box data-testid="friend-right-area" sx={{ width: '40%' }}>
        <Paper sx={{ p: 2, minHeight: '200px' }}>
          {/* 오른쪽 영역 콘텐츠 */}
        </Paper>
      </Box>
    </Box>
  );
}

export default FriendPage;
```

**변경 후:**
```javascript
import React, { useState } from 'react';
import { Box, Paper, TextField, Button, List, ListItem, ListItemText, Typography } from '@mui/material';

// Mock 사용자 데이터 (추후 API로 대체 예정)
const MOCK_USERS = [
  { id: 1, email: 'user1@test.com', nickname: '테스트유저1', birth_date: '2000-01-01', role: 'user' },
  { id: 2, email: 'user2@test.com', nickname: '테스트유저2', birth_date: '2000-01-02', role: 'user' },
  { id: 3, email: 'user3@test.com', nickname: '홍길동', birth_date: '2000-01-03', role: 'user' },
  { id: 4, email: 'user4@test.com', nickname: '김철수', birth_date: '2000-01-04', role: 'user' },
  { id: 5, email: 'user5@test.com', nickname: '박영희', birth_date: '2000-01-05', role: 'user' },
];

function FriendPage() {
  const [searchNickname, setSearchNickname] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [hasSearched, setHasSearched] = useState(false);

  const handleSearch = () => {
    // Mock 데이터에서 닉네임으로 검색 (부분 일치)
    const results = MOCK_USERS.filter(user =>
      user.nickname.includes(searchNickname)
    );
    setSearchResults(results);
    setHasSearched(true);
  };

  const handleAddFriend = (user) => {
    // TODO: 친구 추가 기능 구현 예정
    console.log('친구 추가:', user.nickname);
  };

  return (
    <Box data-testid="friend-page" sx={{ display: 'flex', width: '100%', gap: 2 }}>
      <Box data-testid="friend-left-area" sx={{ width: '60%' }}>
        <Paper sx={{ p: 2, minHeight: '200px' }}>
          <Box sx={{ display: 'flex', gap: 1, mb: 2 }}>
            <TextField
              placeholder="닉네임을 입력하세요"
              value={searchNickname}
              onChange={(e) => setSearchNickname(e.target.value)}
              size="small"
              fullWidth
            />
            <Button variant="contained" onClick={handleSearch}>검색</Button>
          </Box>
          {hasSearched && searchResults.length === 0 && (
            <Typography>검색 결과가 없습니다</Typography>
          )}
          <List>
            {searchResults.map((user) => (
              <ListItem
                key={user.id}
                secondaryAction={
                  <Button
                    variant="outlined"
                    size="small"
                    onClick={() => handleAddFriend(user)}
                  >
                    친구추가
                  </Button>
                }
              >
                <ListItemText primary={user.nickname} secondary={user.email} />
              </ListItem>
            ))}
          </List>
        </Paper>
      </Box>
      <Box data-testid="friend-right-area" sx={{ width: '40%' }}>
        <Paper sx={{ p: 2, minHeight: '200px' }}>
          {/* 오른쪽 영역 콘텐츠 */}
        </Paper>
      </Box>
    </Box>
  );
}

export default FriendPage;
```

**특징:**
- **Mock 데이터 추가**: `MOCK_USERS` 배열에 5명의 테스트 사용자 하드코딩
- **상태 관리**: `searchNickname`, `searchResults`, `hasSearched` 3개의 state 추가
- **검색 UI**: TextField(검색바) + Button(검색 버튼) 조합
- **검색 로직**: `Array.filter()`와 `String.includes()`로 부분 일치 검색
- **검색 결과 표시**: MUI List 컴포넌트로 사용자 리스트 렌더링
- **결과 없음 처리**: `hasSearched && searchResults.length === 0` 조건으로 안내 메시지 표시
- **친구추가 버튼**: ListItem의 `secondaryAction` prop으로 각 항목에 버튼 추가
- **TODO 마커**: `handleAddFriend` 함수는 현재 console.log만 출력 (추후 구현 예정)

## 아키텍처 구조

### 검색 기능 데이터 흐름

```
사용자 입력
    │
    ▼
TextField (닉네임 입력)
    │
    └─→ searchNickname state 업데이트
              │
              ▼
        검색 버튼 클릭
              │
              ▼
        handleSearch() 함수
              │
              ├─→ MOCK_USERS.filter()
              │   (닉네임 부분 일치 검색)
              │
              └─→ setSearchResults(결과)
                  setHasSearched(true)
                        │
                        ▼
                  조건부 렌더링
                        │
        ┌───────────────┴───────────────┐
        │                               │
  결과 있음                         결과 없음
        │                               │
        ▼                               ▼
  List 컴포넌트                   안내 메시지
  (검색 결과 표시)               "검색 결과가 없습니다"
        │
        └─→ ListItem (사용자별)
              │
              ├─→ 닉네임, 이메일 표시
              └─→ "친구추가" 버튼
                        │
                        ▼
                  handleAddFriend()
                  (console.log만 출력)
```

### FriendPage 컴포넌트 구조

```
FriendPage
├── 왼쪽 영역 (60%)
│   └── Paper
│       ├── 검색 UI (Flexbox)
│       │   ├── TextField (닉네임 입력)
│       │   └── Button (검색)
│       │
│       ├── 안내 메시지 (조건부)
│       │   └── Typography "검색 결과가 없습니다"
│       │
│       └── 검색 결과 List
│           └── ListItem (반복)
│               ├── ListItemText
│               │   ├── primary: 닉네임
│               │   └── secondary: 이메일
│               │
│               └── secondaryAction
│                   └── Button "친구추가"
│
└── 오른쪽 영역 (40%)
    └── Paper (빈 영역)
```

## 결과
- 상태: 완료


## 배운내용


## 다음 작업
- user get api 에 nickname 쿼리 추가

## 기본 정보
- 날짜: 2026-02-07 (금) 13:50 ~ 2:50
- 작성자: hexsera

## 진행 목표
친구 페이지에 현재 나에게 온 친구 신청과 현재 나의 친구 목록을 띄운다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| test 파일 생성 | FriendList, FriendPageIntegration.test, FriendRequest.test | |
| FriendPage.jsx 변경 | | |

## 결과
- 상태: 미완료

## 배운내용
TDD 는 내가 앞으로 할 작업이 얼마나 복잡할지 보여주는거 같기도 하다.
특히 레이아웃에 api 연결까지 같이 하려니깐 일이 너무 복잡하다.
특히 RED, GREEN 테스트를 시켜버리면 토큰이 녹아버린다. 이건 내가 해야할거 같다.

RED 작성을 시킬때 꼼꼼히 봐야한다. 지금은 코드를 잘 못봐서 잘 안보이는데, 가끔 ai 가 요청사항 이외의 퀄리티를 RED 에 추가해버리기도 한다.

TDD 를 위한 skill 도 필요할거 같다. RED GREEN 용 코드를 작성하게끔 해야한다.

## 다음 작업
- 로딩 테스트 및 컴포넌트 제거.
- api 에 user nickname 쿼리 추가
- 친구 현황 nickname 표시

# 업무일지

## 기본 정보
- 날짜: 2026-02-07 (금) 15:00 ~ 16:00
- 작성자: hexsera

## 진행 목표
친구 페이지의 로딩 UI와 불필요한 표시 정보를 제거하여 UI를 간소화한다. "친구 페이지 보완.md" PRD에 따라 Phase 1(로딩 UI 제거)과 Phase 2(표시 정보 간소화)를 완료한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| Phase 1-1: 로딩 테스트 제거 | frontend/src/test/FriendPageIntegration.test.jsx | 'API 호출 중 로딩 표시가 나타난다' 테스트 삭제 |
| Phase 1-2: 친구 요청 로딩 UI 제거 | frontend/src/FriendPage.jsx | pendingLoading CircularProgress + "로딩 중..." 삭제 |
| Phase 1-2: 친구 목록 로딩 UI 제거 | frontend/src/FriendPage.jsx | friendLoading CircularProgress + "로딩 중..." 삭제 |
| Phase 1-2: CircularProgress import 제거 | frontend/src/FriendPage.jsx | MUI import에서 CircularProgress 제거 |
| 로딩 테스트 수정 | frontend/src/test/FriendPageIntegration.test.jsx | 에러 메시지 테스트 getAllByText로 수정, vi.clearAllMocks() 추가 |
| Phase 2-1: 친구 요청 표시 간소화 | frontend/src/FriendPage.jsx | ListItemText를 "요청 ID"만 표시하도록 변경 |
| Phase 2-2: 친구 목록 표시 간소화 | frontend/src/FriendPage.jsx | ListItemText를 "친구 ID"만 표시하도록 변경 |
| 친구 요청 테스트 수정 | frontend/src/test/FriendRequest.test.jsx | 테스트 기대값을 "요청 ID: 1|요청 ID: 2"로 변경 |


## 주요 변경 사항

### 1. PRD/친구페이지-보완-실행계획.md 생성

**추가:**
- Phase 1: 로딩 UI 제거 계획 (테스트 + 컴포넌트 코드)
- Phase 2: 표시 정보 간소화 계획 (친구 요청, 친구 목록)
- 수정 파일 목록: 2개 (FriendPageIntegration.test.jsx, FriendPage.jsx)
- 완료 체크리스트: 4개 항목

**특징:**
- PRD 요구사항을 Phase별로 세분화하여 단계적 실행 계획 수립
- 변경 전/후 코드를 명확히 비교하여 실행 용이성 향상

### 2. frontend/src/test/FriendPageIntegration.test.jsx 수정

**변경 전:**
```javascript
  it('API 호출 중 로딩 표시가 나타난다', async () => {
    // 지연된 Promise로 mock
    let resolvePending;
    let resolveAccepted;

    axios.get.mockImplementation((url, config) => {
      if (config?.params?.friend_status === 'pending') {
        return new Promise((resolve) => {
          resolvePending = resolve;
        });
      }
      if (config?.params?.friend_status === 'accepted') {
        return new Promise((resolve) => {
          resolveAccepted = resolve;
        });
      }
      return Promise.resolve({ data: { requests: [] } });
    });

    render(<FriendPage />);

    // 로딩 인디케이터가 표시되는지 확인
    await waitFor(() => {
      const loadingElement = screen.queryByText(/로딩|Loading/i) ||
                            document.querySelector('.MuiCircularProgress-root');
      expect(loadingElement).toBeInTheDocument();
    });

    // Promise resolve하여 로딩 종료
    resolvePending({ data: { requests: [] } });
    resolveAccepted({ data: { requests: [] } });
  });

  it('API 호출 실패 시 에러 메시지가 표시된다', async () => {
    axios.get.mockRejectedValue({
      response: { status: 500, data: { detail: 'Internal server error' } }
    });

    render(<FriendPage />);

    await waitFor(() => {
      // 에러 메시지가 화면에 표시되는지 확인
      expect(screen.getByText(/에러|실패|오류|error/i)).toBeInTheDocument();
    });
  });

  it('로그인하지 않은 상태에서는 API를 호출하지 않는다', () => {
    // localStorage에 user 미설정
    localStorage.clear();

    render(<FriendPage />);

    // axios.get이 호출되지 않았는지 확인
    expect(axios.get).not.toHaveBeenCalled();
  });
```

**변경 후:**
```javascript
  it('API 호출 실패 시 에러 메시지가 표시된다', async () => {
    axios.get.mockRejectedValue({
      response: { status: 500, data: { detail: 'Internal server error' } }
    });

    render(<FriendPage />);

    await waitFor(() => {
      // 에러 메시지가 2개 표시되므로 getAllByText 사용
      const errorMessages = screen.getAllByText(/에러|실패|오류|error/i);
      expect(errorMessages.length).toBeGreaterThan(0);
    });
  });

  it('로그인하지 않은 상태에서는 API를 호출하지 않는다', () => {
    // localStorage에 user 미설정
    localStorage.clear();

    // mock을 clear하여 이전 테스트의 호출 기록 제거
    vi.clearAllMocks();

    render(<FriendPage />);

    // axios.get이 호출되지 않았는지 확인
    expect(axios.get).not.toHaveBeenCalled();
  });
```

**특징:**
- 로딩 테스트 전체 삭제 (32줄 제거)
- 에러 메시지 테스트: `getByText` → `getAllByText`로 변경 (친구 요청 + 친구 목록 2개 에러 처리)
- 로그인 미인증 테스트: `vi.clearAllMocks()` 추가하여 이전 테스트의 mock 호출 기록 제거

### 3. frontend/src/FriendPage.jsx 수정 (Phase 1: 로딩 UI 제거)

**변경 전:**
```javascript
import {
  Box,
  Paper,
  TextField,
  Button,
  List,
  ListItem,
  ListItemText,
  Typography,
  CircularProgress,
  Alert,
  Divider
} from '@mui/material';

// 친구 요청 섹션
{pendingLoading && (
  <Box sx={{ display: 'flex', justifyContent: 'center', p: 2 }}>
    <CircularProgress size={24} />
    <Typography sx={{ ml: 2 }}>로딩 중...</Typography>
  </Box>
)}

// 현재 친구 섹션
{friendLoading && (
  <Box sx={{ display: 'flex', justifyContent: 'center', p: 2 }}>
    <CircularProgress size={24} />
    <Typography sx={{ ml: 2 }}>로딩 중...</Typography>
  </Box>
)}
```

**변경 후:**
```javascript
import {
  Box,
  Paper,
  TextField,
  Button,
  List,
  ListItem,
  ListItemText,
  Typography,
  Alert,
  Divider
} from '@mui/material';

// 친구 요청 섹션 - 로딩 UI 제거됨

// 현재 친구 섹션 - 로딩 UI 제거됨
```

**특징:**
- CircularProgress import 제거 (더 이상 사용하지 않음)
- 친구 요청 영역 로딩 UI 제거 (6줄 삭제)
- 현재 친구 영역 로딩 UI 제거 (6줄 삭제)
- 총 13줄 코드 감소

### 4. frontend/src/FriendPage.jsx 수정 (Phase 2: 표시 정보 간소화)

**변경 전:**
```javascript
// 친구 요청 리스트
<ListItemText
  primary={`사용자 ID: ${request.requester_id}`}
  secondary={`요청 ID: ${request.id}`}
/>

// 현재 친구 리스트
<ListItemText
  primary={`친구 ID: ${friendId}`}
  secondary={`관계 ID: ${friendship.id}`}
/>
```

**변경 후:**
```javascript
// 친구 요청 리스트
<ListItemText
  primary={`요청 ID: ${request.id}`}
/>

// 현재 친구 리스트
<ListItemText
  primary={`친구 ID: ${friendId}`}
/>
```

**특징:**
- 친구 요청: `사용자 ID` 제거, `요청 ID`만 primary로 표시 (secondary 제거)
- 현재 친구: `관계 ID` 제거, `친구 ID`만 표시 (secondary 제거)
- UI 간소화로 사용자 혼란 감소

### 5. frontend/src/test/FriendRequest.test.jsx 수정

**변경 전:**
```javascript
it('API 응답으로 받은 친구 요청 목록이 화면에 표시된다', async () => {
  render(<FriendPage />);

  await waitFor(() => {
    // requester_id 3, 5가 표시되는지 확인 (닉네임 또는 ID)
    const rightArea = screen.getByTestId('friend-right-area');
    expect(rightArea.textContent).toMatch(/3|5|홍길동|박영희/);
  });
});
```

**변경 후:**
```javascript
it('API 응답으로 받은 친구 요청 목록이 화면에 표시된다', async () => {
  render(<FriendPage />);

  await waitFor(() => {
    // 요청 ID 1, 2가 표시되는지 확인
    const rightArea = screen.getByTestId('friend-right-area');
    expect(rightArea.textContent).toMatch(/요청 ID: 1|요청 ID: 2/);
  });
});
```

**특징:**
- Phase 2 변경사항에 맞춰 테스트 기대값 수정
- `requester_id` → `요청 ID`로 검증 대상 변경
- 주석도 명확하게 수정하여 테스트 의도 명시

## 아키텍처 구조

### Phase 1/2 변경 전후 비교

**변경 전:**
```
FriendPage
└── 오른쪽 영역
    ├── 친구 요청 섹션
    │   ├── 로딩 UI (CircularProgress + "로딩 중...")
    │   ├── 에러 UI
    │   └── 요청 리스트
    │       └── ListItemText
    │           ├── primary: "사용자 ID: X"
    │           └── secondary: "요청 ID: Y"
    │
    └── 현재 친구 섹션
        ├── 로딩 UI (CircularProgress + "로딩 중...")
        ├── 에러 UI
        └── 친구 리스트
            └── ListItemText
                ├── primary: "친구 ID: X"
                └── secondary: "관계 ID: Y"
```

**변경 후:**
```
FriendPage
└── 오른쪽 영역
    ├── 친구 요청 섹션
    │   ├── 에러 UI
    │   └── 요청 리스트
    │       └── ListItemText
    │           └── primary: "요청 ID: Y"
    │
    └── 현재 친구 섹션
        ├── 에러 UI
        └── 친구 리스트
            └── ListItemText
                └── primary: "친구 ID: X"
```

## 결과
- 상태: 완료

## 배운내용


## 다음 작업

# 업무일지

## 기본 정보
- 날짜: 2026-02-07 (금) 17:20~18:00
- 작성자: hexsera

## 진행 목표
Dashboard.jsx의 회원정보 UI 컴포넌트를 재사용 가능한 독립 컴포넌트로 분리하여 Admin 페이지에서도 동일한 UI를 사용할 수 있도록 리팩토링

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| HeaderUserInfo 컴포넌트 생성 | frontend/src/components/HeaderUserInfo.jsx | Dashboard의 458~511줄 회원정보 UI 추출 |
| AdminHeader에 컴포넌트 배치 | frontend/src/admin/AdminHeader.jsx | Toolbar에 HeaderUserInfo 추가 |
| Dashboard 인라인 코드 교체 | frontend/src/Dashboard.jsx | 인라인 UI를 컴포넌트로 교체, 불필요한 상태/함수 제거 |


## 주요 변경 사항

### 1. HeaderUserInfo.jsx 생성

**추가:**
```jsx
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box, IconButton, Badge, Avatar, Typography,
  Button, Menu, MenuItem
} from '@mui/material';
import { Notifications, Mail } from '@mui/icons-material';
import { useAuth } from '../AuthContext';

function HeaderUserInfo() {
  const navigate = useNavigate();
  const { isLoggedIn, user, logout } = useAuth();

  const [anchorEl, setAnchorEl] = useState(null);
  const [avatarMenu, setAvatarMenu] = useState(false);

  function AvatarButtonClick(event) {
    setAnchorEl(event.currentTarget);
    setAvatarMenu(!avatarMenu);
  }

  function handleAvatarMenuClose() {
    setAnchorEl(null);
    setAvatarMenu(false);
  }

  function AvatarLogoutButton() {
    logout();
  }

  return (
    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
      {isLoggedIn ? (
        <>
          <IconButton onClick={() => navigate('/admin')}>
            <Badge>
              <Notifications />
            </Badge>
          </IconButton>
          <IconButton>
            <Badge>
              <Mail />
            </Badge>
          </IconButton>
          <Button id="basic-button" onClick={AvatarButtonClick}>
            <Avatar sx={{ width: 40, height: 40, ml: 1 }}>U</Avatar>
            <Typography>{user.name}</Typography>
          </Button>
          <Menu
            anchorEl={anchorEl}
            onClose={handleAvatarMenuClose}
            id="user-menu"
            open={avatarMenu}
          >
            <MenuItem>프로필</MenuItem>
            <MenuItem onClick={() => AvatarLogoutButton()}>로그아웃</MenuItem>
          </Menu>
        </>
      ) : (
        <>
          <Button variant="contained" onClick={() => navigate('/login')}>
            로그인
          </Button>
          <Button variant="outlined" onClick={() => navigate('/Register')}>
            회원가입
          </Button>
        </>
      )}
    </Box>
  );
}

export default HeaderUserInfo;
```

**특징:**
- Dashboard.jsx의 458~511줄 회원정보 UI를 독립 컴포넌트로 분리
- AuthContext의 `isLoggedIn`, `user`, `logout`을 자체적으로 사용하여 props 없이 동작
- 로그인 상태에 따라 알림/메일 아이콘, 아바타 메뉴 또는 로그인/회원가입 버튼 표시
- `anchorEl`, `avatarMenu` 상태와 관련 함수를 컴포넌트 내부에 캡슐화

### 2. AdminHeader.jsx 수정

**변경 전:**
```jsx
import { AppBar, Toolbar, Box } from '@mui/material';

const drawerWidth = 260;

function AdminHeader() {
  return (
    <AppBar
      position="fixed"
      sx={{
        width: { sm: `calc(100% - ${drawerWidth}px)` },
        ml: { sm: `${drawerWidth}px` },
        backgroundColor: '#ffffffff',
        color: '#1f2937',
        boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)',
        borderBottom: '1px solid #e5e7eb',
      }}
    >
      <Toolbar>

      </Toolbar>
    </AppBar>
  );
}
```

**변경 후:**
```jsx
import { AppBar, Toolbar, Box } from '@mui/material';
import HeaderUserInfo from '../components/HeaderUserInfo';

const drawerWidth = 260;

function AdminHeader() {
  return (
    <AppBar
      position="fixed"
      sx={{
        width: { sm: `calc(100% - ${drawerWidth}px)` },
        ml: { sm: `${drawerWidth}px` },
        backgroundColor: '#ffffffff',
        color: '#1f2937',
        boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)',
        borderBottom: '1px solid #e5e7eb',
      }}
    >
      <Toolbar sx={{ justifyContent: 'flex-end' }}>
        <HeaderUserInfo />
      </Toolbar>
    </AppBar>
  );
}
```

**특징:**
- HeaderUserInfo import 추가 (`../components/HeaderUserInfo`)
- Toolbar에 `justifyContent: 'flex-end'` 스타일 추가하여 우측 정렬
- 비어있던 Toolbar에 HeaderUserInfo 컴포넌트 배치

### 3. Dashboard.jsx 수정

**변경 전 (import 부분):**
```jsx
import Pinball from './Pinball';
import UserInfo from './UserInfo';
import FriendPage from './FriendPage';
```

**변경 후 (import 부분):**
```jsx
import Pinball from './Pinball';
import UserInfo from './UserInfo';
import FriendPage from './FriendPage';
import HeaderUserInfo from './components/HeaderUserInfo';
```

**변경 전 (상태 부분):**
```jsx
const [openMenus, setOpenMenus] = useState({});
const [menuIndex, setMenuIndex] = useState(0);
const [anchorEl, setAnchorEl] = useState(null);
const [avatarMenu, setAvatarMenu] = useState(false);
```

**변경 후 (상태 부분):**
```jsx
const [openMenus, setOpenMenus] = useState({});
const [menuIndex, setMenuIndex] = useState(0);
```

**변경 전 (함수 부분):**
```jsx
function AvatarButtonClick (event)
{
  setAnchorEl(event.currentTarget);
  setAvatarMenu(!avatarMenu);
}

function handleAvatarMenuClose ()
{
  setAnchorEl(null);
  setAvatarMenu(false);
}

function AvatarLogoutButton()
{
  logout();
}
```

**변경 후 (함수 부분):**
```jsx
// 함수 제거됨 (HeaderUserInfo로 이동)
```

**변경 전 (JSX 부분, 458~511줄):**
```jsx
<Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
  {isLoggedIn ? (
      <>
      <IconButton onClick={() => navigate('/admin')}>
    <Badge >
      <Notifications />
    </Badge>
  </IconButton>
  <IconButton>
    <Badge >
      <Mail />
    </Badge>
  </IconButton>
  <Button
    id="basic-button"
    onClick={AvatarButtonClick}
    >
    <Avatar sx={{ width: 40, height: 40, ml: 1 }}>U</Avatar>
    <Typography>
      {user.name}
    </Typography>
  </Button>
  <Menu
  anchorEl={anchorEl}
  onClose={handleAvatarMenuClose}
  id="user-menu"
  open={avatarMenu}
  >
    <MenuItem>
    프로필
    </MenuItem>
    <MenuItem
    onClick={()=>AvatarLogoutButton()}>
    로그아웃
    </MenuItem>
  </Menu>
      </>

  ) : (
      <>
      <Button
       variant="contained"
       onClick={()=>navigate('/login')}>
          로그인
      </Button>
      <Button
        variant="outlined"
        onClick={()=>navigate('/Register')}>
          회원가입
      </Button>
      </>
  )}

</Box>
```

**변경 후 (JSX 부분):**
```jsx
<HeaderUserInfo />
```

**특징:**
- 54줄의 인라인 회원정보 UI를 1줄의 컴포넌트 호출로 간소화
- `anchorEl`, `avatarMenu` 상태 제거 (HeaderUserInfo 내부로 이동)
- `AvatarButtonClick`, `handleAvatarMenuClose`, `AvatarLogoutButton` 함수 제거
- 코드 중복 제거 및 컴포넌트 재사용성 향상

## 컴포넌트 구조

**변경 전:**
```
Dashboard
└── AppBar
    └── Toolbar
        └── [458~511줄 인라인 회원정보 UI]

AdminPage
├── AdminHeader
│   └── AppBar
│       └── Toolbar (비어있음)
├── AdminSidebar
└── AdminMain
```

**변경 후:**
```
Dashboard
└── AppBar
    └── Toolbar
        └── HeaderUserInfo (컴포넌트)

AdminPage
├── AdminHeader
│   └── AppBar
│       └── Toolbar
│           └── HeaderUserInfo (컴포넌트)
├── AdminSidebar
└── AdminMain

HeaderUserInfo (독립 컴포넌트)
├── AuthContext 사용
├── react-router navigate 사용
└── 로그인 상태에 따른 UI 분기
    ├── 로그인: 알림, 메일, 아바타, 메뉴
    └── 비로그인: 로그인, 회원가입 버튼
```

## 결과
- 상태: 완료

## 배운내용


## 다음 작업


# 업무일지

## 기본 정보
- 날짜: 2026-02-07 (금) 18:00~17:00
- 작성자: hexsera

## 진행 목표
HeaderUserInfo 컴포넌트의 Menu에 "페이지 이동" MenuItem을 추가하고, TDD 방식으로 현재 경로에 따라 토글 방식으로 페이지를 이동하는 기능을 구현한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| TDD 계획서 작성 (MenuItem 추가) | PRD/HeaderUserInfo-페이지이동-버튼-추가-TDD.md | Step 1: MenuItem 존재 확인 테스트 |
| 테스트 코드 작성 (RED) | frontend/src/test/HeaderUserInfo.test.jsx | "페이지 이동" MenuItem 존재 확인 테스트 |
| MenuItem 추가 (GREEN) | frontend/src/components/HeaderUserInfo.jsx | Menu에 "페이지 이동" MenuItem 추가 |
| TDD 계획서 작성 (토글 기능) | PRD/HeaderUserInfo-페이지이동-토글-기능-TDD.md | Step 2: 페이지 이동 동작 테스트 |
| 주소인식 기능 테스트 작성 (RED) | frontend/src/test/HeaderUserInfo.test.jsx | 2개 테스트 케이스 추가 (/ ↔ /admin) |
| 주소인식 기능 구현 (GREEN) | frontend/src/components/HeaderUserInfo.jsx | useLocation, handlePageNavigation 구현 |

## 주요 변경 사항

### 1. PRD/HeaderUserInfo-페이지이동-버튼-추가-TDD.md 생성

**추가:**
- Context: "페이지 이동" MenuItem 추가 필요성 설명
- Step 1 (RED): 1개 테스트 케이스 작성
- Step 2 (GREEN): HeaderUserInfo.jsx에 MenuItem 추가
- Step 3: 테스트 실행 확인
- 테스트 패턴 설명: MemoryRouter, AuthProvider, localStorage 사용법

**특징:**
- TDD의 RED-GREEN 사이클을 명확히 구분
- 기존 FriendPage.test.jsx의 테스트 패턴 재사용
- 최소한의 테스트로 시작 (MenuItem 존재 여부만 확인)

### 2. frontend/src/test/HeaderUserInfo.test.jsx 생성 (Phase 1 - MenuItem 추가)

**테스트 실행 결과: FAIL → PASS**

### 3. frontend/src/components/HeaderUserInfo.jsx 수정 (Phase 1 - MenuItem 추가)

**변경:**
"프로필"과 "로그아웃" 사이에 `<MenuItem>페이지 이동</MenuItem>` 추가

### 4. PRD/HeaderUserInfo-페이지이동-토글-기능-TDD.md 생성

**추가:**
- `/`에서 클릭 → `/admin` 이동 테스트
- `/admin`으로 시작하는 페이지에서 클릭 → `/` 이동 테스트
- startsWith 메서드의 장점: `/admin/*` 하위 경로 자동 감지

### 5. frontend/src/test/HeaderUserInfo.test.jsx 수정 (Phase 2 - 주소인식 기능)

**추가:**
- LocationTracker 컴포넌트 패턴 사용 (경로 추적용)
- MemoryRouter의 initialEntries로 초기 경로 설정
- 테스트 실행 결과: 2 FAIL → 3 PASS

### 6. frontend/src/components/HeaderUserInfo.jsx 수정 (Phase 2 - 주소인식 기능)

**추가:**
```jsx
import { useNavigate, useLocation } from 'react-router-dom';

function handlePageNavigation() {
  if (location.pathname.startsWith('/admin')) {
    navigate('/');
  } else {
    navigate('/admin');
  }
  handleAvatarMenuClose();
}

<MenuItem onClick={handlePageNavigation}>페이지 이동</MenuItem>
```

## 결과
- 상태: 완료

## 배운내용


## 다음 작업
- "페이지 이동" 글자가 어드민 페이지일때, 사용자 페이지일때 나누어야함
- 어드민 계정이 아니라면 "페이지 이동" 없어야함.
