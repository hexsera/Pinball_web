# 업무일지

## 기본 정보
- 날짜: 2026-01-22 (수)
- 작성자: hexsera

## 진행 목표
FastAPI User CRUD 및 Login API DB 연동 구현
(FastAPI 재구축)

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|

[요구사항 분석]
요구사항.md 파일 확인 → PRD 작성 스킬 사용
| PRD 작성 | PRD/user-crud-db-연동.md | User CRUD 및 Login API PRD
20분

[실행]
| auth.py 생성 | fastapi/auth.py | API Key 인증 의존성 (verify_api_key)
| main.py 수정 | fastapi/main.py | User CRUD 엔드포인트 6개 + Login 구현
  - POST /api/v1/users: 사용자 생성 (API Key 필요)
  - GET /api/v1/users: 전체 사용자 조회 (API Key 필요)
  - GET /api/v1/users/{user_id}: 특정 사용자 조회 (API Key 필요)
  - PUT /api/v1/users/{user_id}: 사용자 수정 (API Key 필요)
  - DELETE /api/v1/users/{user_id}: 사용자 삭제 (API Key 필요)
  - POST /api/v1/login: 로그인 (API Key 불필요)
  - POST /api/v1/register: 회원가입 (API Key 불필요, role='user' 고정)
5분

[테스트]
Docker 환경에서 11개 체크리스트 항목 테스트
| API Key 인증 | curl 테스트 | 401 Unauthorized, 403 Forbidden 확인
| 사용자 생성 | curl 테스트 | 중복 이메일 검증 (400), DB 저장 확인
| 사용자 조회 | curl 테스트 | 전체 조회, 특정 조회, 404 확인
| 사용자 수정 | curl 테스트 | 닉네임 수정, 중복 이메일 검증 (400)
| 사용자 삭제 | curl 테스트 | 삭제 성공, 삭제 후 404 확인
| 로그인 | curl 테스트 | 성공, 잘못된 비밀번호 (401)
SRP 원칙 적용 여부 판단 → 서비스 레이어 도입 시도
| services.py 생성 | fastapi/services.py | UserService 클래스 구현 (비즈니스 로직 분리)
| main.py 리팩토링 | fastapi/main.py | 엔드포인트에서 UserService 사용
| 테스트 계획 작성 | PRD/srp-리팩토링-테스트-계획.md | 기능 회귀 테스트, SRP 효과 검증
| Docker 테스트 | 13개 테스트 케이스 | 모든 테스트 통과 확인
| 사용자 요청으로 롤백 | fastapi/services.py 삭제, main.py 복원 | 코드가 너무 복잡하다는 이유

25분

[업무일지 작성]
15분 

**총 1시간 5분**

## 주요 변경 사항

### 1. fastapi/auth.py 생성

**추가:**
```python
from fastapi import HTTPException, Security, status
from fastapi.security import APIKeyHeader

API_KEY = "hexsera-secret-api-key-2026"
API_KEY_HEADER = APIKeyHeader(name="X-API-Key", auto_error=False)


def verify_api_key(api_key: str = Security(API_KEY_HEADER)):
    """API Key 검증 의존성"""
    if api_key is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API Key is missing"
        )
    if api_key != API_KEY:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Invalid API Key"
        )
    return api_key
```

**특징:**
- APIKeyHeader를 사용하여 X-API-Key 헤더에서 API Key 추출
- auto_error=False로 설정하여 수동 에러 처리
- 401 Unauthorized: API Key 없음
- 403 Forbidden: API Key 잘못됨

### 2. fastapi/main.py - Pydantic 스키마 추가

**추가된 스키마:**
```python
class UserUpdateRequest(BaseModel):
    """사용자 수정 요청 (모든 필드 선택적)"""
    email: Optional[str] = None
    nickname: Optional[str] = None
    password: Optional[str] = None
    birth_date: Optional[date] = None
    role: Optional[str] = None

class LoginRequest(BaseModel):
    """로그인 요청"""
    email: str
    password: str

class LoginResponse(BaseModel):
    """로그인 응답"""
    message: str
    user_id: int
    email: str
    nickname: str

class DeleteResponse(BaseModel):
    """삭제 응답"""
    message: str
    deleted_user_id: int
```

**특징:**
- UserUpdateRequest: 모든 필드 Optional (부분 수정 지원)
- LoginResponse: password 제외한 사용자 정보 반환
- UserResponse에 id 필드 추가 및 Config.from_attributes = True 설정

### 3. POST /api/v1/users - 사용자 생성 (main.py:91-118)

**변경 전:**
```python
@app.post("/api/v1/users", response_model=UserResponse)
def create_user(user: UserCreateRequest):
    """범용 사용자 생성 엔드포인트 (DB 저장은 추후 구현)"""
    return UserResponse(
        email=user.email,
        nickname=user.nickname,
        birth_date=user.birth_date,
        role=user.role
    )
```

**변경 후:**
```python
@app.post("/api/v1/users", response_model=UserResponse)
def create_user(
    user: UserCreateRequest,
    db: Session = Depends(get_db),
    api_key: str = Depends(verify_api_key)
):
    """범용 사용자 생성 엔드포인트 (role 지정 가능, API Key 필요)"""
    # 이메일 중복 검증
    existing_user = db.query(User).filter(User.email == user.email).first()
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )

    # DB에 사용자 저장
    db_user = User(
        email=user.email,
        nickname=user.nickname,
        password=user.password,
        birth_date=user.birth_date,
        role=user.role
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)

    return db_user
```

**특징:**
- API Key 인증 추가 (verify_api_key)
- DB 세션 의존성 추가 (get_db)
- 이메일 중복 검증 (400 Bad Request)
- SQLAlchemy를 사용한 DB 저장
- db.refresh()로 생성된 id 등 자동 필드 갱신

### 4. GET /api/v1/users - 전체 사용자 조회 (main.py:121-128)

**구현:**
```python
@app.get("/api/v1/users", response_model=List[UserResponse])
def get_all_users(
    db: Session = Depends(get_db),
    api_key: str = Depends(verify_api_key)
):
    """전체 사용자 조회 (API Key 필요)"""
    users = db.query(User).all()
    return users
```

**특징:**
- response_model을 List[UserResponse]로 지정
- db.query(User).all()로 전체 사용자 조회
- API Key 인증 필요

### 5. GET /api/v1/users/{user_id} - 특정 사용자 조회 (main.py:131-144)

**구현:**
```python
@app.get("/api/v1/users/{user_id}", response_model=UserResponse)
def get_user(
    user_id: int,
    db: Session = Depends(get_db),
    api_key: str = Depends(verify_api_key)
):
    """특정 사용자 조회 (API Key 필요)"""
    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"User with id {user_id} not found"
        )
    return user
```

**특징:**
- Path parameter로 user_id 받기
- 존재하지 않는 사용자: 404 Not Found

### 6. PUT /api/v1/users/{user_id} - 사용자 정보 수정 (main.py:147-179)

**구현:**
```python
@app.put("/api/v1/users/{user_id}", response_model=UserResponse)
def update_user(
    user_id: int,
    user_update: UserUpdateRequest,
    db: Session = Depends(get_db),
    api_key: str = Depends(verify_api_key)
):
    """사용자 정보 수정 (API Key 필요)"""
    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"User with id {user_id} not found"
        )

    # 이메일 변경 시 중복 검증
    if user_update.email and user_update.email != user.email:
        existing_user = db.query(User).filter(User.email == user_update.email).first()
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )

    # 수정할 필드만 업데이트
    update_data = user_update.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        if value is not None:
            setattr(user, field, value)

    db.commit()
    db.refresh(user)
    return user
```

**특징:**
- model_dump(exclude_unset=True)로 실제 전송된 필드만 추출
- 이메일 변경 시 중복 검증 (기존 이메일과 다를 때만)
- setattr()로 동적 필드 업데이트
- 부분 수정 지원 (Optional 필드)

### 7. DELETE /api/v1/users/{user_id} - 사용자 삭제 (main.py:182-202)

**구현:**
```python
@app.delete("/api/v1/users/{user_id}", response_model=DeleteResponse)
def delete_user(
    user_id: int,
    db: Session = Depends(get_db),
    api_key: str = Depends(verify_api_key)
):
    """사용자 삭제 (API Key 필요)"""
    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"User with id {user_id} not found"
        )

    db.delete(user)
    db.commit()

    return DeleteResponse(
        message="User deleted successfully",
        deleted_user_id=user_id
    )
```

**특징:**
- db.delete()로 사용자 삭제
- 삭제된 user_id를 응답에 포함

### 8. POST /api/v1/login - 로그인 (main.py:205-229)

**구현:**
```python
@app.post("/api/v1/login", response_model=LoginResponse)
def login(
    login_request: LoginRequest,
    db: Session = Depends(get_db)
):
    """로그인 엔드포인트 (API Key 불필요)"""
    user = db.query(User).filter(User.email == login_request.email).first()
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password"
        )

    if user.password != login_request.password:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password"
        )

    return LoginResponse(
        message="Login successful",
        user_id=user.id,
        email=user.email,
        nickname=user.nickname
    )
```

**특징:**
- API Key 인증 불필요
- 이메일로 사용자 조회
- 비밀번호 평문 비교 (추후 해싱 필요)
- 존재하지 않는 이메일 또는 잘못된 비밀번호: 401 Unauthorized
- 동일한 에러 메시지로 보안 강화 (이메일/비밀번호 구분 불가)

### 9. POST /api/v1/register - 회원가입 (main.py:232-258)

**구현:**
```python
@app.post("/api/v1/register", response_model=UserResponse)
def register_user(
    user: UserRegisterRequest,
    db: Session = Depends(get_db)
):
    """일반 회원가입 엔드포인트 (API Key 불필요)"""
    # 이메일 중복 검증
    existing_user = db.query(User).filter(User.email == user.email).first()
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )

    # DB에 사용자 저장
    db_user = User(
        email=user.email,
        nickname=user.nickname,
        password=user.password,
        birth_date=user.birth_date,
        role="user"
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)

    return db_user
```

**특징:**
- API Key 인증 불필요
- role을 'user'로 고정 (일반 회원가입)
- POST /api/v1/users와 유사한 로직 (코드 중복)

### API 엔드포인트 구조

```
/api/v1/users (POST)    → 사용자 생성 (API Key 필요, role 지정 가능)
/api/v1/users (GET)     → 전체 사용자 조회 (API Key 필요)
/api/v1/users/{id} (GET)    → 특정 사용자 조회 (API Key 필요)
/api/v1/users/{id} (PUT)    → 사용자 정보 수정 (API Key 필요)
/api/v1/users/{id} (DELETE) → 사용자 삭제 (API Key 필요)
/api/v1/login (POST)    → 로그인 (API Key 불필요)
/api/v1/register (POST) → 회원가입 (API Key 불필요, role='user' 고정)
```

### 의존성 주입 흐름

```
엔드포인트 함수
  ↓
db: Session = Depends(get_db)
  → SessionLocal() 생성
  → yield로 세션 제공
  → finally로 세션 종료
  ↓
api_key: str = Depends(verify_api_key)
  → X-API-Key 헤더 추출
  → API Key 검증 (401/403)
  → 검증 통과 시 반환
```

### 에러 처리 계층

```
HTTPException
├── 400 Bad Request: 이메일 중복
├── 401 Unauthorized: API Key 없음, 로그인 실패
├── 403 Forbidden: 잘못된 API Key
└── 404 Not Found: 사용자 없음
```

## 현재 남은 문제점

### 1. 코드 중복
POST /api/v1/users와 POST /api/v1/register가 거의 동일한 로직 반복
- 이메일 중복 검증 로직 중복
- DB 저장 로직 중복
- 향후 비밀번호 해싱 추가 시 두 곳 모두 수정 필요

### 2. 비밀번호 평문 저장
- 현재: password를 그대로 DB에 저장
- 보안 취약: DB 유출 시 모든 비밀번호 노출
- 해결 필요: bcrypt 또는 passlib로 해싱

### 3. API Key 하드코딩
- auth.py에 API Key가 하드코딩됨
- 환경변수로 이동 필요 (.env 파일)

## 결과
- 상태: 완료

## 다음 작업
- React Login.jsx에서 POST /api/v1/login 연동 확인 및 수정
- React Register.jsx에서 POST /api/v1/register 연동 확인 및 수정
