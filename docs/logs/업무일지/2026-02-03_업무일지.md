# 업무일지

## 기본 정보
- 날짜: 2026-02-03 (월) 9:10~9:40
- 작성자: hexsera

## 진행 목표
Admin 페이지에 통계 페이지를 추가하고, 사이드바 메뉴에서 접근 가능하도록 구현

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 통계 메인 컴포넌트 생성 | react/main/src/admin/AdminStatisticsMain.jsx | 통계 페이지 메인 콘텐츠 영역 |
| 통계 페이지 컴포넌트 생성 | react/main/src/admin/AdminStatisticsPage.jsx | 헤더, 사이드바, 메인 조합 레이아웃 |
| 사이드바 메뉴 추가 | react/main/src/admin/AdminSidebar.jsx | '통계' 메뉴 항목 추가 |
| 라우팅 설정 | react/main/src/App.jsx | /admin/statistics 경로 추가 |

## 주요 변경 사항

### 1. AdminStatisticsMain.jsx 생성

**추가:**
```javascript
import { Box, Typography, Toolbar } from '@mui/material';

function AdminStatisticsMain() {
  const drawerWidth = 260;

  return (
    <Box
      component="main"
      sx={{
        flexGrow: 1,
        p: 3,
        width: { sm: `calc(100% - ${drawerWidth}px)` },
        backgroundColor: '#F9FAFB',
        minHeight: '100vh',
      }}
    >
      <Toolbar/>
      <Typography variant="h4" sx={{ mb: 3, color: '#1f2937' }}>
        통계
      </Typography>
      <Box sx={{
        backgroundColor: '#ffffff',
        borderRadius: 1,
        p: 3,
        border: '1px solid #e5e7eb'
      }}>
        <Typography variant="body1" sx={{ color: '#6b7280' }}>
          통계 데이터가 여기에 표시됩니다.
        </Typography>
      </Box>
    </Box>
  );
}

export default AdminStatisticsMain;
```

**특징:**
- AdminMain.jsx와 동일한 레이아웃 패턴 적용
- `component="main"`으로 시맨틱 HTML 적용
- Toolbar 컴포넌트로 헤더 공간 확보
- `width: calc(100% - 260px)`로 사이드바 공간 제외
- 색상 체계: Dashboard와 동일 (#F9FAFB 배경, #ffffff 카드, #e5e7eb 보더)

### 2. AdminStatisticsPage.jsx 생성

**추가:**
```javascript
import { Box } from '@mui/material';
import AdminHeader from './AdminHeader';
import AdminSidebar from './AdminSidebar';
import AdminStatisticsMain from './AdminStatisticsMain';

function AdminStatisticsPage() {
  return (
    <Box sx={{ display: 'flex' }}>
      <AdminHeader />
      <AdminSidebar />
      <AdminStatisticsMain />
    </Box>
  );
}

export default AdminStatisticsPage;
```

**특징:**
- AdminPage.jsx와 동일한 구조 사용
- Flexbox로 Header, Sidebar, Main 조합
- 기존 공통 컴포넌트 재사용

### 3. AdminSidebar.jsx 수정

**변경 전:**
```javascript
import { Dashboard as DashboardIcon, People } from '@mui/icons-material';

const menuItems = [
  { text: '대시보드', icon: <DashboardIcon />, path: '/admin' },
  { text: '회원관리', icon: <People />, path: '/admin/users' },
];
```

**변경 후:**
```javascript
import { Dashboard as DashboardIcon, People, BarChart } from '@mui/icons-material';

const menuItems = [
  { text: '대시보드', icon: <DashboardIcon />, path: '/admin' },
  { text: '회원관리', icon: <People />, path: '/admin/users' },
  { text: '통계', icon: <BarChart />, path: '/admin/statistics' },
];
```

**특징:**
- BarChart 아이콘 import 추가
- menuItems 배열에 '통계' 메뉴 추가
- path는 `/admin/statistics`로 설정

### 4. App.jsx 수정

**변경 전:**
```javascript
import AdminPage from './admin/AdminPage';
import AdminUserPage from './admin/AdminUserPage';

<Routes>
  <Route path="/" element={<Dashboard />} />
  <Route path="/login" element={<Login />} />
  <Route path="/Register" element={<Register/>} />
  <Route path="/Pinball_test" element={<Pinball/>} />
  <Route path="/admin" element={<AdminPage/>} />
  <Route path="/admin/users" element={<AdminUserPage/>} />
</Routes>
```

**변경 후:**
```javascript
import AdminPage from './admin/AdminPage';
import AdminUserPage from './admin/AdminUserPage';
import AdminStatisticsPage from './admin/AdminStatisticsPage';

<Routes>
  <Route path="/" element={<Dashboard />} />
  <Route path="/login" element={<Login />} />
  <Route path="/Register" element={<Register/>} />
  <Route path="/Pinball_test" element={<Pinball/>} />
  <Route path="/admin" element={<AdminPage/>} />
  <Route path="/admin/users" element={<AdminUserPage/>} />
  <Route path="/admin/statistics" element={<AdminStatisticsPage/>} />
</Routes>
```

**특징:**
- AdminStatisticsPage import 추가
- `/admin/statistics` 경로에 AdminStatisticsPage 연결

## 아키텍처 구조

```
AdminStatisticsPage (/admin/statistics)
├── AdminHeader (상단 고정)
├── AdminSidebar (좌측 260px)
│   ├── 대시보드 (/admin)
│   ├── 회원관리 (/admin/users)
│   └── 통계 (/admin/statistics) ← 신규 추가
└── AdminStatisticsMain (메인 콘텐츠)
    └── 통계 데이터 표시 영역
```

## 결과
- 상태: 완료

## 배운내용
ai 가 메인 페이지 레이아웃 이상하게 짰다. mui 헤더, 사이드바의 대한 기억이 없나...

## 다음 작업

## 기본 정보
- 날짜: 2026-02-03 (월) 11:00~11:50
- 작성자: hexsera

## 진행 목표
관리자 통계 페이지에 주별 회원 방문 통계 Line Chart 추가

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| mui x charts 패키지 설치 | | |
| Line Chart 구현 | react/main/src/admin/AdminStatisticsMain.jsx | LineChart 컴포넌트 추가 및 임시 데이터 생성 |

## 주요 변경 사항

### 1. 통계-그래프-실행계획.md 작성

**추가:**
- MUI X Charts 패키지 설치 계획
- LineChart 컴포넌트 사용 방법
- 임시 데이터 구조 (최근 8주간 방문자 수)
- 구현 단계별 상세 가이드

**특징:**
- MUI 공식 차트 라이브러리 선택 (업계 표준)
- 주별 통계로 변경 (8주 데이터)
- 800x400px 크기의 Line Chart
- 마커(점) 표시로 데이터 포인트 강조

### 2. AdminStatisticsMain.jsx 수정

**변경 전:**
```javascript
import { Box, Typography, Toolbar } from '@mui/material';

function AdminStatisticsMain() {
  const drawerWidth = 260;

  return (
    <Box component="main" sx={{ ... }}>
      <Toolbar/>
      <Typography variant="h4" sx={{ mb: 3, color: '#1f2937' }}>
        통계
      </Typography>
      <Box sx={{ backgroundColor: '#ffffff', ... }}>
        <Typography variant="body1" sx={{ color: '#6b7280' }}>
          통계 데이터가 여기에 표시됩니다.
        </Typography>
      </Box>
    </Box>
  );
}
```

**변경 후:**
```javascript
import { Box, Typography, Toolbar } from '@mui/material';
import { LineChart } from '@mui/x-charts/LineChart';

function AdminStatisticsMain() {
  const drawerWidth = 260;

  // 임시 데이터: 최근 8주간 방문자 수
  const visitData = {
    visitors: [320, 450, 380, 520, 600, 470, 560, 610],
  };

  return (
    <Box component="main" sx={{ ... }}>
      <Toolbar/>
      <Typography variant="h4" sx={{ mb: 3, color: '#1f2937' }}>
        통계
      </Typography>
      <Box sx={{ backgroundColor: '#ffffff', ... }}>
        <Typography variant="h6" sx={{ mb: 2, color: '#1f2937' }}>
          회원 방문 통계 (최근 8주)
        </Typography>
        <LineChart
          xAxis={[{
            data: [1, 2, 3, 4, 5, 6, 7, 8],
            scaleType: 'point',
            label: '주차'
          }]}
          series={[{
            data: visitData.visitors,
            label: '방문자 수',
            color: '#465FFF',
            showMark: true,
          }]}
          width={800}
          height={400}
        />
      </Box>
    </Box>
  );
}
```

**특징:**
- LineChart 컴포넌트 import 추가 (@mui/x-charts/LineChart)
- visitData 객체로 8주간 방문자 수 데이터 관리
- xAxis: 1~8 숫자 데이터, scaleType: 'point'로 점 단위 표시
- series: 방문자 수 데이터, 파란색(#465FFF), 마커 표시
- 차트 크기: 800x400px

## 데이터 구조

**임시 데이터 (최근 8주간 방문자 수):**
```
주차:     1주차  2주차  3주차  4주차  5주차  6주차  7주차  8주차
방문자:    320    450    380    520    600    470    560    610
```

**차트 구성:**
```
┌─────────────────────────────────────────┐
│  회원 방문 통계 (최근 8주)               │
│                                         │
│  600 ┼               ●                  │
│      │          ●         ●       ●     │
│  500 ┼                                  │
│      │     ●                  ●         │
│  400 ┼               ●                  │
│      │  ●                               │
│  300 ┼                                  │
│      └─┴─┴─┴─┴─┴─┴─┴─                  │
│       1 2 3 4 5 6 7 8 (주차)            │
└─────────────────────────────────────────┘
```

## 결과
- 상태: 완료 (패키지 설치 제외)
- AdminStatisticsMain에 LineChart 컴포넌트 추가 완료
- 임시 데이터로 주별 방문 통계 시각화 구현
- @mui/x-charts 패키지 설치 필요 (로컬 환경에서 `npm install @mui/x-charts` 실행)

## 배운내용
- LineChart 컴포넌트

## 다음 작업
- 데이터 필터링

## 기본 정보
- 날짜: 2026-02-03 (월) 13:08~13:27 14:06~14:40
- 작성자: hexsera

## 진행 목표
관리자 통계 페이지에 API 연동 기능 구현 및 일주일 단위 집계 로직 추가

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 실행계획 작성 | docs/prd/관리자-통계-페이지-GET-실행계획.md | API 연동 구현 계획 수립 |
| API 연동 구현 | react/main/src/admin/AdminStatisticsMain.jsx | axios GET 요청 및 일주일 집계 함수 구현 |
| 날짜 선택 UI 제거 | react/main/src/admin/AdminStatisticsMain.jsx | 자동 날짜 계산으로 변경 |
| 임시 데이터 생성 함수 추가 | react/main/src/admin/AdminStatisticsMain.jsx | 3개월 분량 일별 데이터 생성 |
| 패키지 의존성 추가 | react/main/package.json | dayjs 패키지 추가, @mui/x-date-pickers 패키지 추가  |


## 주요 변경 사항

### 1. 관리자-통계-페이지-GET-실행계획.md 작성

**추가:**
- API 스펙 정의: `GET /api/v1/game-plays`
- 쿼리 파라미터: `start_date`, `end_date`
- 응답 구조: `[{ date: "2026-01-20", play_count: 150 }, ...]`
- 일주일 단위 집계 함수 구현 계획
- 5단계 구현 절차 수립

**특징:**
- 게임 플레이 기록 데이터로 용어 통일 (접속 → 게임 플레이)
- API 인증 불필요 (API Key 제거)
- 오늘부터 8주 전 날짜를 자동으로 쿼리
- API 미구현 시 임시 데이터 사용

### 2. AdminStatisticsMain.jsx - API 연동 구현

**변경 전:**
```javascript
import { Box, Typography, Toolbar } from '@mui/material';
import { LineChart } from '@mui/x-charts/LineChart';

function AdminStatisticsMain() {
  const drawerWidth = 260;

  // 임시 데이터: 최근 8주간 방문자 수
  const visitData = {
    visitors: [320, 450, 380, 520, 600, 470, 560, 610],
  };

  return (
    <Box component="main" sx={{ ... }}>
      <LineChart
        xAxis={[{ data: [1, 2, 3, 4, 5, 6, 7, 8], ... }]}
        series={[{ data: visitData.visitors, label: '방문자 수', ... }]}
      />
    </Box>
  );
}
```

**변경 후:**
```javascript
import { useState, useEffect } from 'react';
import { Box, Typography, Toolbar } from '@mui/material';
import { LineChart } from '@mui/x-charts/LineChart';
import dayjs from 'dayjs';
import axios from 'axios';

function AdminStatisticsMain() {
  const drawerWidth = 260;

  // 상태 변수
  const [weeklyData, setWeeklyData] = useState([]);
  const [loading, setLoading] = useState(false);

  // 일주일 단위 집계 함수
  const aggregateByWeek = (dailyData, startDate) => {
    const weekMap = {};

    dailyData.forEach(item => {
      const date = dayjs(item.date);
      const weekNumber = Math.floor(date.diff(startDate, 'day') / 7) + 1;

      if (!weekMap[weekNumber]) {
        weekMap[weekNumber] = 0;
      }
      weekMap[weekNumber] += item.play_count;
    });

    return Object.keys(weekMap).map(week => ({
      week: parseInt(week),
      play_count: weekMap[week]
    })).sort((a, b) => a.week - b.week);
  };

  // 임시 일별 데이터 생성 함수 (3개월 분량)
  const generateMockDailyData = (startDate, endDate) => {
    const dailyData = [];
    let currentDate = dayjs(startDate);
    const end = dayjs(endDate);

    while (currentDate.isBefore(end) || currentDate.isSame(end, 'day')) {
      const playCount = Math.floor(Math.random() * 91) + 10;

      dailyData.push({
        date: currentDate.format('YYYY-MM-DD'),
        play_count: playCount
      });

      currentDate = currentDate.add(1, 'day');
    }

    return dailyData;
  };

  // API 호출 및 데이터 로딩 함수
  const fetchStatistics = async () => {
    setLoading(true);

    const endDate = dayjs();
    const startDate = dayjs().subtract(8, 'week');

    try {
      console.log('통계 데이터 로딩 시작:', {
        start_date: startDate.format('YYYY-MM-DD'),
        end_date: endDate.format('YYYY-MM-DD')
      });

      const response = await axios.get('/api/v1/game-plays', {
        params: {
          start_date: startDate.format('YYYY-MM-DD'),
          end_date: endDate.format('YYYY-MM-DD')
        }
      });

      console.log('API 응답:', response.data);

      const dailyData = response.data;
      const aggregated = aggregateByWeek(dailyData, startDate);
      setWeeklyData(aggregated);
    } catch (error) {
      console.error('통계 데이터 로딩 실패:', error);

      // API 미구현 시 임시 일별 데이터 생성 (3개월 분량)
      const mockStartDate = dayjs().subtract(12, 'week');
      const mockEndDate = dayjs();
      const mockDailyData = generateMockDailyData(mockStartDate, mockEndDate);

      console.log('임시 일별 데이터 생성:', mockDailyData.length + '일 분량');
      console.log('첫 5개 데이터:', mockDailyData.slice(0, 5));

      const aggregated = aggregateByWeek(mockDailyData, mockStartDate);
      console.log('집계된 주차별 데이터:', aggregated);

      setWeeklyData(aggregated);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchStatistics();
  }, []);

  return (
    <Box component="main" sx={{ ... }}>
      <Typography variant="h6" sx={{ mb: 2, color: '#1f2937' }}>
        게임 플레이 통계 (최근 8주)
      </Typography>
      <LineChart
        xAxis={[{
          data: weeklyData.map(item => item.week),
          scaleType: 'point',
          label: '주차'
        }]}
        series={[{
          data: weeklyData.map(item => item.play_count),
          label: '게임 플레이 횟수',
          color: '#465FFF',
          showMark: true,
        }]}
        width={800}
        height={400}
        loading={loading}
      />
    </Box>
  );
}
```

**특징:**
- useState/useEffect로 상태 관리 및 라이프사이클 처리
- axios를 사용한 API GET 요청 구현
- dayjs로 날짜 계산 및 포맷팅
- 일주일 단위 집계 함수 구현 (일별 데이터 → 주차별 데이터)
- 임시 데이터 생성 함수로 3개월(약 84일) 분량 데이터 생성
- API 실패 시 자동으로 임시 데이터 사용
- 로딩 상태 표시 (loading prop)
- 콘솔 로그로 디버깅 가능

### 3. package.json 수정

**변경 전:**
```json
{
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@mui/icons-material": "^7.3.6",
    "@mui/material": "^7.3.6",
    "@mui/x-charts": "^8.27.0",
    "@mui/x-data-grid": "^8.26.0",
    "axios": "^1.13.2",
    "matter-js": "^0.20.0",
    "react": "^19.2.3",
    "react-dom": "^19.2.3",
    "react-router-dom": "^7.11.0",
    "yup": "^1.7.1"
  }
}
```

**변경 후:**
```json
{
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@mui/icons-material": "^7.3.6",
    "@mui/material": "^7.3.6",
    "@mui/x-charts": "^8.27.0",
    "@mui/x-data-grid": "^8.26.0",
    "@mui/x-date-pickers": "^8.27.0",
    "axios": "^1.13.2",
    "dayjs": "^1.11.19",
    "matter-js": "^0.20.0",
    "react": "^19.2.3",
    "react-dom": "^19.2.3",
    "react-router-dom": "^7.11.0",
    "yup": "^1.7.1"
  }
}
```

**특징:**
- dayjs 패키지 추가 (^1.11.19)
- @mui/x-date-pickers 패키지 추가 (^8.27.0) - 향후 날짜 선택 UI에 사용 가능

## 데이터 흐름

```
1. 컴포넌트 마운트
   │
   ▼
2. useEffect 실행
   │
   ▼
3. fetchStatistics() 호출
   │
   ├─→ API 성공: GET /api/v1/game-plays
   │   │ params: { start_date: "2025-12-09", end_date: "2026-02-03" }
   │   │
   │   ▼
   │   일별 데이터 수신: [{ date: "2025-12-09", play_count: 45 }, ...]
   │   │
   │   ▼
   │   aggregateByWeek(dailyData, startDate)
   │   │
   │   └─→ 주차별 데이터: [{ week: 1, play_count: 320 }, ...]
   │
   └─→ API 실패: catch 블록
       │
       ▼
       generateMockDailyData(12주 전, 오늘)
       │ 랜덤 데이터 생성: 10~100 사이 값
       │
       ▼
       84일 분량 일별 데이터 생성
       │
       ▼
       aggregateByWeek(mockDailyData, mockStartDate)
       │
       └─→ 주차별 데이터: [{ week: 1, play_count: 450 }, ...]

4. setWeeklyData(aggregated)
   │
   ▼
5. LineChart 렌더링
   │ xAxis: weeklyData.map(item => item.week)
   │ series: weeklyData.map(item => item.play_count)
   │
   └─→ 화면에 차트 표시
```

## 일주일 단위 집계 로직

**입력 데이터 (일별):**
```
[
  { date: "2025-12-09", play_count: 45 },
  { date: "2025-12-10", play_count: 60 },
  { date: "2025-12-11", play_count: 30 },
  ...
  { date: "2025-12-15", play_count: 55 }, // 7일째
  { date: "2025-12-16", play_count: 40 }, // 8일째 (2주차 시작)
  ...
]
```

**처리 과정:**
1. 각 날짜가 시작일로부터 몇 일째인지 계산
2. `Math.floor(일수 / 7) + 1`로 주차 번호 계산
3. weekMap 객체에 주차별로 play_count 누적
4. 배열로 변환 및 정렬

**출력 데이터 (주차별):**
```
[
  { week: 1, play_count: 320 },  // 1~7일째 합계
  { week: 2, play_count: 450 },  // 8~14일째 합계
  { week: 3, play_count: 380 },  // 15~21일째 합계
  ...
]
```

## 결과
- 상태: 미완료
- 테스트 시간 없음

## 배운내용
요구사항에 없는 걸 막 추가하지 말자. 시간도 없는데...
날짜 선택 UI 막 만들어주니깐 그냥 해버렸음...

## 다음 작업
- 임시 데이터 삭제
- 주간 데이터 -> 일간 데이터 수정

## 기본 정보
- 날짜: 2026-02-03 (월) 14:50~15:40
- 작성자: hexsera

## 진행 목표
UserInfo.jsx에서 회원 탈퇴 버튼 클릭 시 "회원 탈퇴" 텍스트 확인 후 회원 삭제 및 로그아웃 처리 구현

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 텍스트 입력 상태 추가 | react/main/src/UserInfo.jsx | deleteConfirmText, deleteError 상태 추가 |
| Dialog UI 개선 | react/main/src/UserInfo.jsx | TextField, Alert 컴포넌트 추가 |
| handleDelete 함수 구현 | react/main/src/UserInfo.jsx | 텍스트 검증 + API 연동 |

## 주요 변경 사항

### 2. UserInfo.jsx - 텍스트 입력 상태 추가

**변경 전:**
```javascript
// 회원 탈퇴 상태
const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
```

**변경 후:**
```javascript
// 회원 탈퇴 상태
const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
const [deleteConfirmText, setDeleteConfirmText] = useState('');
const [deleteError, setDeleteError] = useState(null);
```

**특징:**
- `deleteConfirmText`: 사용자가 입력한 확인 텍스트를 저장
- `deleteError`: 텍스트 불일치 또는 API 에러 메시지를 저장

### 3. UserInfo.jsx - Dialog UI 개선

**변경 전:**
```javascript
<Dialog
  open={deleteDialogOpen}
  onClose={() => setDeleteDialogOpen(false)}
>
  <DialogTitle>회원 탈퇴</DialogTitle>
  <DialogContent>
    <Typography>
      정말 탈퇴하시겠습니까? 모든 데이터가 삭제되며 복구할 수 없습니다.
    </Typography>
  </DialogContent>
  <DialogActions>
    <Button onClick={() => setDeleteDialogOpen(false)}>취소</Button>
    <Button onClick={handleDelete} color="error" variant="contained">
      탈퇴
    </Button>
  </DialogActions>
</Dialog>
```

**변경 후:**
```javascript
<Dialog
  open={deleteDialogOpen}
  onClose={() => {
    setDeleteDialogOpen(false);
    setDeleteConfirmText('');
    setDeleteError(null);
  }}
>
  <DialogTitle>회원 탈퇴</DialogTitle>
  <DialogContent>
    <Typography gutterBottom>
      정말 탈퇴하시겠습니까? 삭제된 정보는 되돌릴 수 없습니다.
    </Typography>
    <Typography variant="body2" color="text.secondary" gutterBottom sx={{ mt: 2 }}>
      진행하려면 아래 입력란에 <strong>"회원 탈퇴"</strong>를 정확히 입력해 주세요.
    </Typography>
    <TextField
      fullWidth
      label="회원 탈퇴 확인"
      placeholder="회원 탈퇴"
      value={deleteConfirmText}
      onChange={(e) => setDeleteConfirmText(e.target.value)}
      sx={{ mt: 2 }}
    />
    {deleteError && (
      <Alert severity="error" sx={{ mt: 2 }}>
        {deleteError}
      </Alert>
    )}
  </DialogContent>
  <DialogActions>
    <Button onClick={() => {
      setDeleteDialogOpen(false);
      setDeleteConfirmText('');
      setDeleteError(null);
    }}>
      취소
    </Button>
    <Button onClick={handleDelete} color="error" variant="contained">
      확인
    </Button>
  </DialogActions>
</Dialog>
```

**특징:**
- TextField 추가: "회원 탈퇴" 텍스트 입력
- Alert 컴포넌트: 에러 메시지 표시
- Dialog 닫을 때 입력값과 에러 메시지 초기화
- 안내 문구: "회원 탈퇴"를 정확히 입력하도록 명시

### 4. UserInfo.jsx - handleDelete 함수 구현

**변경 전:**
```javascript
// 회원 탈퇴
const handleDelete = () => {
  // TODO: 백엔드 API 연동
  console.log('탈퇴 요청');
  setDeleteDialogOpen(false);
  logout();
  navigate('/');
};
```

**변경 후:**
```javascript
// 회원 탈퇴
const handleDelete = async () => {
  setDeleteError(null);

  // "회원 탈퇴" 텍스트 일치 검증
  if (deleteConfirmText !== '회원 탈퇴') {
    setDeleteError('"회원 탈퇴"를 정확히 입력해주세요.');
    return;
  }

  try {
    // 회원 삭제 (DELETE /api/v1/users/{user_id})
    console.log('회원 삭제 API 호출 시작');
    await axios.delete(`/api/v1/users/${user.id}`, {
      headers: { 'X-API-Key': 'hexsera-secret-api-key-2026' }
    });
    console.log('회원 삭제 API 호출 성공');

    // 로그아웃 및 메인 페이지 이동
    setDeleteDialogOpen(false);
    logout();
    navigate('/');
  } catch (err) {
    console.error('회원 탈퇴 실패:', err);

    // 사용자를 찾을 수 없음 (404)
    if (err.response?.status === 404) {
      setDeleteError('사용자를 찾을 수 없습니다.');
    }
    // 기타 에러
    else {
      setDeleteError('회원 탈퇴에 실패했습니다.');
    }
  }
};
```

**특징:**
- async/await로 비동기 처리 구현
- "회원 탈퇴" 텍스트 정확히 일치 검증 (대소문자, 띄어쓰기 구분)
- DELETE /api/v1/users/{user_id} API 호출 (API Key 포함)
- 성공 시 logout() 호출 → localStorage 제거 및 AuthContext 상태 초기화
- navigate('/')로 메인 페이지 이동 (불가능)
- 에러 처리: 404, 기타 에러 상태별 메시지 표시
- console.log로 디버깅 가능

## 데이터 흐름

```
사용자 입력
    │
    ▼
회원 탈퇴 버튼 클릭
    │
    ▼
Dialog 열림 (TextField 표시)
    │
    ▼
"회원 탈퇴" 텍스트 입력
    │
    ▼
확인 버튼 클릭 → handleDelete() 호출
    │
    ├─→ 텍스트 불일치: setDeleteError() → 에러 메시지 표시
    │
    └─→ 텍스트 일치
        │
        ▼
    DELETE /api/v1/users/{user_id}
    (API Key: hexsera-secret-api-key-2026)
        │
        ├─→ 성공 (200)
        │   │
        │   ▼
        │   logout() → localStorage.removeItem('user')
        │   │
        │   ▼
        │   navigate('/') → 메인 페이지 이동
        │
        └─→ 실패 (404 or 기타)
            │
            ▼
            setDeleteError() → 에러 메시지 표시
```

## 결과
- 상태: 미완료
- 로그아웃 후 메인페이지 가기가 navigate 형태로 불가능함
- 페이지 동작 구조 잊어먹어서 실수 생겼다...
- 비밀번호 입력 시키는거도 미구현.

## 배운내용


## 다음 작업
- 회원 탈퇴 기능 테스트
  - 텍스트 불일치 시 에러 메시지 표시 확인
  - "회원 탈퇴" 정확히 입력 시 삭제 및 로그아웃 확인
  - 삭제된 회원으로 재로그인 시도 시 실패 확인

## 기본 정보
- 날짜: 2026-02-03 (월) 15:40~15:50
- 작성자: hexsera

## 진행 목표
회원 탈퇴 후 메인 페이지 이동 문제 해결 (navigate 미작동 이슈)

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| navigate 제거 | react/main/src/UserInfo.jsx | useNavigate import 및 변수 제거 |
| 페이지 이동 방식 변경 | react/main/src/UserInfo.jsx | navigate('/') → window.location.href = '/' |

## 주요 변경 사항

### 1. UserInfo.jsx - import 수정

**변경 전:**
```javascript
import { useNavigate } from 'react-router-dom';
import { useAuth } from './AuthContext';
import axios from 'axios';

function UserInfo() {
  const navigate = useNavigate();
  const { user, logout } = useAuth();
```

**변경 후:**
```javascript
import { useAuth } from './AuthContext';
import axios from 'axios';

function UserInfo() {
  const { user, logout } = useAuth();
```

**특징:**
- `useNavigate` import 제거 (더 이상 사용하지 않음)
- `navigate` 변수 제거

### 2. UserInfo.jsx - handleDelete 함수 수정

**변경 전:**
```javascript
// 로그아웃 및 메인 페이지 이동
setDeleteDialogOpen(false);
logout();
navigate('/');
```

**변경 후:**
```javascript
// 로그아웃 및 메인 페이지 이동
setDeleteDialogOpen(false);
logout();
// 페이지 전체 새로고침으로 메인 페이지로 이동
window.location.href = '/';
```

**특징:**
- `navigate('/')` 대신 `window.location.href = '/'` 사용
- 페이지를 완전히 새로고침하여 메인 페이지로 이동
- React 상태가 모두 초기화됨 (Dashboard의 showUserInfo 상태도 리셋)

## 문제 원인 및 해결

### 문제 상황
- UserInfo는 Dashboard 내부에 포함되어 있음 (URL은 동일하게 `/`)
- Dashboard의 `showUserInfo` 상태로 UserInfo 표시/숨김 제어
- `navigate('/')`는 이미 `/` 경로에 있어서 작동하지 않음
- 회원 탈퇴 후 UserInfo가 그대로 표시되는 문제 발생

### 해결 방법
- `window.location.href = '/'`로 페이지 전체 새로고침
- logout()으로 localStorage 제거 후 페이지 리로드
- Dashboard의 모든 상태가 초기화되어 메인 콘텐츠 표시

## 데이터 흐름

```
회원 탈퇴 성공
    │
    ▼
setDeleteDialogOpen(false)
    │
    ▼
logout()
    │ localStorage.removeItem('user')
    │ setUser(null)
    │ setIsLoggedIn(false)
    │
    ▼
window.location.href = '/'
    │
    │ 페이지 전체 새로고침
    │
    ▼
App.jsx 리렌더링
    │
    ▼
Dashboard.jsx 마운트
    │ showUserInfo = false (초기 상태)
    │ showPinball = false (초기 상태)
    │ isLoggedIn = false (localStorage 비어있음)
    │
    ▼
메인 콘텐츠 표시
```

## 결과
- 상태: 완료
- navigate 미작동 문제 해결
- window.location.href로 페이지 새로고침 방식 적용
- 회원 탈퇴 후 메인 페이지로 정상 이동

## 배운내용


## 다음 작업
- 회원 탈퇴 기능 전체 테스트
  - 텍스트 불일치 시 에러 메시지 표시 확인
  - "회원 탈퇴" 정확히 입력 시 삭제 및 로그아웃 확인
  - 메인 페이지 이동 확인 (페이지 새로고침)
  - 삭제된 회원으로 재로그인 시도 시 실패 확인

## 기본 정보
- 날짜: 2026-02-03 (월) 16:00~16:45
- 작성자: hexsera

## 진행 목표
AdminStatisticsMain.jsx의 게임 플레이 통계를 주간 집계에서 일일 데이터로 변경 (최근 2주 데이터 표시)

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| aggregateByWeek 함수 제거 | react/main/src/admin/AdminStatisticsMain.jsx | 주간 집계 로직 삭제 |
| 상태 변수 변경 | react/main/src/admin/AdminStatisticsMain.jsx | weeklyData → dailyData |
| API 호출 범위 변경 | react/main/src/admin/AdminStatisticsMain.jsx | 8주 → 2주, 정렬 로직 추가 |
| Mock 데이터 범위 변경 | react/main/src/admin/AdminStatisticsMain.jsx | 12주 → 2주 |
| 차트 x축 변경 | react/main/src/admin/AdminStatisticsMain.jsx | 주차 → 날짜(MM-DD) |

## 주요 변경 사항

### 2. AdminStatisticsMain.jsx - 상태 변수 및 함수 제거

**변경 전:**
```javascript
// 상태 변수
const [weeklyData, setWeeklyData] = useState([]);
const [loading, setLoading] = useState(false);

// 일주일 단위 집계 함수
const aggregateByWeek = (dailyData, startDate) => {
  // dailyData: [{ date: "2026-01-20", play_count: 150 }, ...]
  const weekMap = {};

  dailyData.forEach(item => {
    const date = dayjs(item.date);
    // 해당 날짜가 시작일로부터 몇 번째 주인지 계산
    const weekNumber = Math.floor(date.diff(startDate, 'day') / 7) + 1;

    if (!weekMap[weekNumber]) {
      weekMap[weekNumber] = 0;
    }
    weekMap[weekNumber] += item.play_count;
  });

  // { 1: 500, 2: 450, ... } → [{ week: 1, play_count: 500 }, ...]
  return Object.keys(weekMap).map(week => ({
    week: parseInt(week),
    play_count: weekMap[week]
  })).sort((a, b) => a.week - b.week);
};
```

**변경 후:**
```javascript
// 상태 변수
const [dailyData, setDailyData] = useState([]);
const [loading, setLoading] = useState(false);
```

**특징:**
- weeklyData → dailyData로 변경하여 의미 명확화
- aggregateByWeek 함수 전체 삭제 (더 이상 주간 집계 불필요)
- 코드 약 25줄 감소

### 3. AdminStatisticsMain.jsx - API 호출 범위 변경

**변경 전:**
```javascript
// 오늘부터 8주 전 날짜 계산
const endDate = dayjs();
const startDate = dayjs().subtract(8, 'week');

try {
  const response = await axios.get('/api/v1/game-plays', {
    params: {
      start_date: startDate.format('YYYY-MM-DD'),
      end_date: endDate.format('YYYY-MM-DD')
    }
  });

  console.log('API 응답:', response.data);

  // 예상 응답 구조: [{ date: "2026-01-20", play_count: 150 }, ...]
  const dailyData = response.data;
  const aggregated = aggregateByWeek(dailyData, startDate);
  setWeeklyData(aggregated);
```

**변경 후:**
```javascript
// 오늘부터 2주 전 날짜 계산
const endDate = dayjs();
const startDate = dayjs().subtract(2, 'week');

try {
  const response = await axios.get('/api/v1/game-plays', {
    params: {
      start_date: startDate.format('YYYY-MM-DD'),
      end_date: endDate.format('YYYY-MM-DD')
    }
  });

  console.log('API 응답:', response.data);

  // 일별 데이터를 그대로 사용 (집계 없이)
  const dailyDataFromAPI = response.data;

  // 날짜 오름차순 정렬 (2주 전 → 오늘)
  const sortedData = dailyDataFromAPI.sort((a, b) =>
    dayjs(a.date).isAfter(dayjs(b.date)) ? 1 : -1
  );

  setDailyData(sortedData);
```

**특징:**
- 데이터 범위: 8주(56일) → 2주(14일)
- aggregateByWeek() 호출 제거
- 날짜 오름차순 정렬 로직 추가 (과거 → 현재)
- API 응답 데이터를 집계 없이 직접 사용

### 4. AdminStatisticsMain.jsx - Mock 데이터 생성 로직 수정

**변경 전:**
```javascript
} catch (error) {
  console.error('통계 데이터 로딩 실패:', error);

  // API 미구현 시 임시 일별 데이터 생성 (3개월 분량)
  const mockStartDate = dayjs().subtract(12, 'week'); // 3개월 (약 12주)
  const mockEndDate = dayjs();
  const mockDailyData = generateMockDailyData(mockStartDate, mockEndDate);

  console.log('임시 일별 데이터 생성:', mockDailyData.length + '일 분량');
  console.log('첫 5개 데이터:', mockDailyData.slice(0, 5));

  // 일주일 단위 집계 함수 테스트
  const aggregated = aggregateByWeek(mockDailyData, mockStartDate);
  console.log('집계된 주차별 데이터:', aggregated);

  setWeeklyData(aggregated);
```

**변경 후:**
```javascript
} catch (error) {
  console.error('통계 데이터 로딩 실패:', error);

  // API 미구현 시 임시 일별 데이터 생성 (2주 분량)
  const mockStartDate = dayjs().subtract(2, 'week');
  const mockEndDate = dayjs();
  const mockDailyData = generateMockDailyData(mockStartDate, mockEndDate);

  console.log('임시 일별 데이터 생성:', mockDailyData.length + '일 분량');
  console.log('첫 5개 데이터:', mockDailyData.slice(0, 5));

  // 집계 없이 바로 사용
  setDailyData(mockDailyData);
```

**특징:**
- Mock 데이터 범위: 12주(84일) → 2주(14일)
- aggregateByWeek() 호출 제거
- 일별 데이터를 그대로 상태에 저장
- 콘솔 로그에 "14일 분량" 메시지 출력

### 5. AdminStatisticsMain.jsx - 차트 컴포넌트 수정

**변경 전:**
```javascript
<Typography variant="h6" sx={{ mb: 2, color: '#1f2937' }}>
  게임 플레이 통계 (최근 8주)
</Typography>
<LineChart
  xAxis={[{
    data: weeklyData.map(item => item.week),
    scaleType: 'point',
    label: '주차'
  }]}
  series={[{
    data: weeklyData.map(item => item.play_count),
    label: '게임 플레이 횟수',
    color: '#465FFF',
    showMark: true,
  }]}
  width={800}
  height={400}
  loading={loading}
/>
```

**변경 후:**
```javascript
<Typography variant="h6" sx={{ mb: 2, color: '#1f2937' }}>
  게임 플레이 통계 (최근 2주)
</Typography>
<LineChart
  xAxis={[{
    data: dailyData.map(item => dayjs(item.date).format('MM-DD')),
    scaleType: 'point',
    label: '날짜'
  }]}
  series={[{
    data: dailyData.map(item => item.play_count),
    label: '게임 플레이 횟수',
    color: '#465FFF',
    showMark: true,
  }]}
  width={800}
  height={400}
  loading={loading}
/>
```

**특징:**
- 차트 제목: "최근 8주" → "최근 2주"
- x축 데이터: 주차 번호(1, 2, 3...) → 날짜 형식(01-20, 01-21, 01-22...)
- x축 레이블: "주차" → "날짜"
- series 데이터: weeklyData → dailyData
- dayjs().format('MM-DD')로 날짜 포맷팅

## 데이터 구조 변경

**변경 전 (주차별 집계):**
```
[
  { week: 1, play_count: 320 },   // 1~7일째 합계
  { week: 2, play_count: 450 },   // 8~14일째 합계
  { week: 3, play_count: 380 },   // 15~21일째 합계
  ...
  { week: 8, play_count: 610 }    // 50~56일째 합계
]
```

**변경 후 (일별 데이터):**
```
[
  { date: "2026-01-20", play_count: 45 },
  { date: "2026-01-21", play_count: 60 },
  { date: "2026-01-22", play_count: 30 },
  ...
  { date: "2026-02-03", play_count: 75 }
]
```

## 차트 표시 비교

**변경 전:**
```
┌─────────────────────────────────────────┐
│  게임 플레이 통계 (최근 8주)             │
│                                         │
│  600 ┼                         ●        │
│      │                    ●             │
│  500 ┼          ●                       │
│      │     ●                            │
│  400 ┼               ●                  │
│      │                    ●             │
│  300 ┼  ●                               │
│      └─┴─┴─┴─┴─┴─┴─┴─                  │
│       1 2 3 4 5 6 7 8 (주차)            │
└─────────────────────────────────────────┘
```

**변경 후:**
```
┌─────────────────────────────────────────┐
│  게임 플레이 통계 (최근 2주)             │
│                                         │
│  100 ┼  ●     ●                    ●    │
│      │     ●    ●  ●   ●                │
│   80 ┼           ●    ●   ●  ●     ●    │
│      │                 ●       ●        │
│   60 ┼     ●                            │
│      │  ●                               │
│   40 ┼                                  │
│      └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─      │
│       01-20 ... 01-27 ... 02-03 (날짜)  │
└─────────────────────────────────────────┘
```

## 결과
- 상태: 완료

## 배운내용
mock data

## 다음 작업
- 원하는 날짜 가져오기

## 기본 정보
- 날짜: 2026-02-03 (월) 17:08~17:35
- 작성자: hexsera

## 진행 목표
Dashboard.jsx의 월간 랭킹 테이블에 API 연동 기능 구현 (GET /api/v1/monthly-scores)

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| axios import 추가 | react/main/src/Dashboard.jsx | axios 패키지 import |
| 상태 관리 추가 | react/main/src/Dashboard.jsx | useState 3개 추가 |
| API 호출 구현 | react/main/src/Dashboard.jsx | useEffect로 월간 점수 조회 |
| 테이블 UI 개선 | react/main/src/Dashboard.jsx | 로딩/에러 처리 및 overflow 추가 |
| 하드코딩 데이터 제거 | react/main/src/Dashboard.jsx | monthlyRankingData 임시 배열 삭제 |

## 주요 변경 사항

### 2. Dashboard.jsx - axios import 추가

**변경 전:**
```javascript
import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Drawer,
  // ...
} from '@mui/material';
```

**변경 후:**
```javascript
import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import {
  Box,
  Drawer,
  // ...
} from '@mui/material';
```

**특징:**
- axios 패키지 import 추가
- API 호출을 위한 준비

### 3. Dashboard.jsx - 상태 관리 추가

**변경 전:**
```javascript
const [showPinball, setShowPinball] = useState(false);
const [showUserInfo, setShowUserInfo] = useState(false);
const [mobileOpen, setMobileOpen] = useState(false);
```

**변경 후:**
```javascript
const [showPinball, setShowPinball] = useState(false);
const [showUserInfo, setShowUserInfo] = useState(false);
const [mobileOpen, setMobileOpen] = useState(false);

const [monthlyRankingData, setMonthlyRankingData] = useState([]);
const [isLoadingRanking, setIsLoadingRanking] = useState(true);
const [rankingError, setRankingError] = useState(null);
```

**특징:**
- `monthlyRankingData`: 랭킹 데이터 배열 (빈 배열로 초기화)
- `isLoadingRanking`: 로딩 상태 (true로 시작)
- `rankingError`: 에러 메시지 저장 (null로 초기화)

### 4. Dashboard.jsx - useEffect로 API 호출 구현

**추가:**
```javascript
// 월간 랭킹 데이터 조회
useEffect(() => {
  const fetchMonthlyRanking = async () => {
    try {
      setIsLoadingRanking(true);

      // 월간 점수 목록 조회
      const response = await axios.get('/api/v1/monthly-scores');
      const scores = response.data.scores;

      // 응답 데이터를 rank와 임시 nickname 추가하여 변환
      const rankingData = scores.slice(0, 10).map((score, index) => ({
        rank: index + 1,
        nickname: 'testnickname',  // 임시 닉네임 (추후 API에서 제공 예정)
        score: score.score
      }));

      setMonthlyRankingData(rankingData);
      setRankingError(null);
    } catch (error) {
      console.error('월간 랭킹 조회 실패:', error);
      setRankingError('랭킹 데이터를 불러오는데 실패했습니다.');
    } finally {
      setIsLoadingRanking(false);
    }
  };

  fetchMonthlyRanking();
}, []); // 컴포넌트 마운트 시 한 번만 실행
```

**특징:**
- async/await로 비동기 처리
- GET /api/v1/monthly-scores 호출 (인증 불필요)
- scores.slice(0, 10)으로 TOP 10만 선택
- rank 필드 추가 (index + 1)
- nickname은 임시로 "testnickname" 고정
- try-catch-finally로 에러 처리 및 로딩 상태 관리
- 의존성 배열 비어있음 (마운트 시 1회만 실행)

### 5. Dashboard.jsx - 테이블 UI 개선

**변경 전:**
```javascript
<Paper sx={{ p: 3, boxShadow: '0 1px 3px rgba(0, 0, 0, 0.08)', border: '1px solid #e5e7eb' }}>
  <Typography variant="h6" fontWeight={600} gutterBottom>
    한달 랭킹 TOP 10
  </Typography>
  <TableContainer>
    <Table size="small">
      <TableHead>
        <TableRow>
          <TableCell sx={{ fontWeight: 600 }}>순위</TableCell>
          <TableCell sx={{ fontWeight: 600 }}>닉네임</TableCell>
          <TableCell sx={{ fontWeight: 600 }} align="right">점수</TableCell>
        </TableRow>
      </TableHead>
      <TableBody>
        {monthlyRankingData.map((row) => (
          <TableRow key={row.rank}>
            <TableCell>{row.rank}</TableCell>
            <TableCell>{row.nickname}</TableCell>
            <TableCell align="right">{row.score.toLocaleString()}</TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  </TableContainer>
</Paper>
```

**변경 후:**
```javascript
<Paper sx={{ p: 3, boxShadow: '0 1px 3px rgba(0, 0, 0, 0.08)', border: '1px solid #e5e7eb', maxHeight: 500 }}>
  <Typography variant="h6" fontWeight={600} gutterBottom>
    한달 랭킹 TOP 10
  </Typography>
  {isLoadingRanking ? (
    <Typography sx={{ py: 3, textAlign: 'center' }}>
      로딩 중...
    </Typography>
  ) : rankingError ? (
    <Typography sx={{ py: 3, textAlign: 'center', color: 'error.main' }}>
      {rankingError}
    </Typography>
  ) : (
    <TableContainer sx={{
      maxHeight: 400,
      overflow: 'auto',
      '&::-webkit-scrollbar': { width: '8px' },
      '&::-webkit-scrollbar-thumb': { backgroundColor: '#e5e7eb', borderRadius: '4px' },
      '&::-webkit-scrollbar-thumb:hover': { backgroundColor: '#d1d5db' },
    }}>
      <Table size="small" stickyHeader>
        <TableHead>
          <TableRow>
            <TableCell sx={{ fontWeight: 600, backgroundColor: '#F9FAFB' }}>순위</TableCell>
            <TableCell sx={{ fontWeight: 600, backgroundColor: '#F9FAFB' }}>닉네임</TableCell>
            <TableCell sx={{ fontWeight: 600, backgroundColor: '#F9FAFB' }} align="right">점수</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {monthlyRankingData.map((row) => (
            <TableRow key={row.rank}>
              <TableCell>{row.rank}</TableCell>
              <TableCell>{row.nickname}</TableCell>
              <TableCell align="right">{row.score.toLocaleString()}</TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  )}
</Paper>
```

**특징:**
- 조건부 렌더링: isLoadingRanking, rankingError 상태에 따라 다른 UI 표시
- 로딩 중: "로딩 중..." 메시지 표시
- 에러 발생: 에러 메시지 표시 (빨간색)
- Paper maxHeight: 500px 제한
- TableContainer maxHeight: 400px, overflow: 'auto'
- 웹킷 스크롤바 커스터마이징 (너비 8px, 색상 #e5e7eb)
- stickyHeader: 스크롤 시 헤더 고정
- TableCell backgroundColor: '#F9FAFB' (헤더 배경색)

### 6. Dashboard.jsx - 하드코딩 데이터 제거

**변경 전:**
```javascript
// 한달 랭킹 임시 데이터
const monthlyRankingData = [
  { rank: 1, nickname: '핀볼마스터', score: 152000 },
  { rank: 2, nickname: '게임왕', score: 148500 },
  { rank: 3, nickname: '플리퍼킹', score: 145200 },
  { rank: 4, nickname: '점수사냥꾼', score: 138900 },
  { rank: 5, nickname: '핀볼러버', score: 135600 },
  { rank: 6, nickname: '고수', score: 128300 },
  { rank: 7, nickname: '챔피언', score: 125000 },
  { rank: 8, nickname: '도전자', score: 118700 },
  { rank: 9, nickname: '핀볼신', score: 112400 },
  { rank: 10, nickname: '초보탈출', score: 108100 },
];
```

**변경 후:**
```javascript
// 제거됨 (useState로 대체)
```

**특징:**
- 하드코딩된 임시 데이터 배열 삭제
- useState의 monthlyRankingData로 대체
- API 응답 데이터로 동적으로 채워짐

## 데이터 흐름

```
컴포넌트 마운트
    │
    ▼
useEffect 실행
    │
    ▼
fetchMonthlyRanking() 호출
    │
    ├─→ setIsLoadingRanking(true)
    │
    ├─→ axios.get('/api/v1/monthly-scores')
    │   │
    │   ├─→ 성공
    │   │   │
    │   │   ▼
    │   │   scores = response.data.scores
    │   │   │
    │   │   ▼
    │   │   scores.slice(0, 10).map(...)
    │   │   │ rank: index + 1
    │   │   │ nickname: 'testnickname'
    │   │   │ score: score.score
    │   │   │
    │   │   ▼
    │   │   setMonthlyRankingData(rankingData)
    │   │   setRankingError(null)
    │   │
    │   └─→ 실패
    │       │
    │       ▼
    │       console.error(...)
    │       setRankingError('랭킹 데이터를 불러오는데 실패했습니다.')
    │
    └─→ setIsLoadingRanking(false)
        │
        ▼
    테이블 렌더링
        │
        ├─→ isLoadingRanking === true
        │   └─→ "로딩 중..." 표시
        │
        ├─→ rankingError !== null
        │   └─→ 에러 메시지 표시
        │
        └─→ 정상 데이터
            └─→ 테이블에 랭킹 표시 (순위, "testnickname", 점수)
```

## 결과
- 상태: 완료

## 배운내용


## 다음 작업
- 랭킹 테이블에서 nickname 저장
- 랭킹 테이블 api get 에서 nickname 제공
- 랭킹 테이블 testnickname 실제 닉네임으로 바꾸기

# 기본 정보
- 날짜: 2026-02-03 (월) 7:00~7:45
- 작성자: hexsera

## 진행 목표
프론트엔드 프로젝트 구조 개선 Phase 0 완료: react/main 폴더를 frontend로 변경하여 프로젝트 구조 명확화

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 프론트엔드 구조 개선 실행계획 작성 | `PRD/프론트엔드-구조-개선-실행계획.md` | 7개 Phase로 구성된 점진적 마이그레이션 계획 |
| Phase 0 추가 (react/main → frontend 변경) | `PRD/프론트엔드-구조-개선-실행계획.md` | 폴더명 변경 단계 추가 |
| react/main 폴더를 frontend로 이름 변경 | `react/main/` → `frontend/` | 폴더 구조 명확화 |
| 비어있는 react 폴더 제거 | `react/` 삭제 | 불필요한 중첩 구조 제거 |
| CLAUDE.md 문서 업데이트 | `CLAUDE.md` | 모든 react/main 경로를 frontend로 변경 (3곳) |

**총 1시간**

## 주요 변경 사항

### 1. PRD/프론트엔드-구조-개선-실행계획.md 생성

**추가:**
```markdown
# 프론트엔드 구조 개선 실행계획

## 요구사항 요약
- 컴포넌트 재사용성 향상 (공통 컴포넌트 분리)
- 코드 유지보수성 개선 (역할별 폴더 구조)
- API 호출 로직 중앙화 (services 레이어)
- 비즈니스 로직과 UI 분리 (hooks, utils)

## 구현 단계
- Phase 0: react/main → frontend 폴더명 변경
- Phase 1: 디렉토리 구조 생성 및 Context 이동
- Phase 2: 공통 레이아웃 컴포넌트 분리
- Phase 3: API 서비스 레이어 생성
- Phase 4: 페이지 컴포넌트 이동 (Login, Register)
- Phase 5: 페이지 컴포넌트 이동 (Dashboard, UserInfo, Pinball)
- Phase 6: Admin 페이지 이동 및 App.jsx 업데이트
- Phase 7: Vite 경로 별칭 설정 (선택 사항)
```

**특징:**
- 7개 Phase로 구성된 점진적 마이그레이션 계획
- 각 Phase별 코드 예시 및 상세 설명 포함
- barrel exports를 활용한 import 경로 간소화
- 완료 체크리스트 제공 (Phase 0와 Phase 1~7로 분리)

### 2. 폴더 구조 변경

**변경 전:**
```
Pinball_web/
├── react/
│   └── main/           # 현재 프론트엔드 위치
│       ├── src/
│       ├── package.json
│       └── vite.config.js
└── backend/
```

**변경 후:**
```
Pinball_web/
├── frontend/          # react/main에서 이동
│   ├── src/
│   ├── package.json
│   └── vite.config.js
└── backend/
```

**특징:**
- react/main → frontend 폴더명 변경으로 프로젝트 구조 명확화
- 불필요한 react 중간 폴더 제거
- backend와 나란히 위치하여 가독성 향상

### 3. CLAUDE.md 수정

**변경 전:**
```markdown
### React 개발 (./react/main/)
```bash
cd react/main
npm install
npm run start    # 개발 서버 (Vite)
npm run build    # 프로덕션 빌드 → dist/
```

## 결과
- 상태: 완료 (Phase 0)

## 배운내용


## 다음 작업
- Phase 1 실행.
