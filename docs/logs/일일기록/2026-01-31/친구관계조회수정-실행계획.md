# 친구 관계 조회 수정 실행계획

## 요구사항 요약

**요구사항**: GET /api/friend-requests 엔드포인트에 `status` 쿼리 파라미터를 추가하여, 특정 status의 친구 요청만 조회할 수 있고, `"all"`을 전달하면 모든 status를 반환하도록 수정. 또한 `user_id`가 `requester_id`인 경우와 `receiver_id`인 경우 모두를 검색하도록 수정.

**목적**: 현재 엔드포인트는 자신이 받은(receiver) pending 요청만 조회할 수 있다. 이를 통해 자신이 보낸 요청, 승인/거절된 요청 등 모든 친구 관계 상태를 조회할 수 있게 된다.

## 현재상태 분석

- `GET /api/friend-requests`는 `receiver_id == user_id`이고 `status == "pending"`인 레코드만 반환
- `FriendRequestData` 스키마에 `receiver_id` 필드가 없어, user_id가 requester_id일 때 상대방 정보를 식별할 수 없음
- status는 하드코딩된 `"pending"`으로 고정되어 있어 쿼리 파라미터로 받지 않음
- SQLAlchemy의 `or_()` 함수를 사용하면 requester_id/receiver_id 양방향 OR 조건 처리 가능

## 구현 방법

- `status` 쿼리 파라미터를 추가 (기본값: `"pending"`, 유효값: `pending`, `accepted`, `rejected`, `all`)
- SQLAlchemy의 `or_()` 함수로 `requester_id == user_id OR receiver_id == user_id` 조건 구성
- `status == "all"`이면 status 필터를 적용하지 않고, 그 외에는 해당 status로 필터링
- `FriendRequestData` 스키마에 `receiver_id` 필드 추가하여 양방향 조회 시 상대방 식별 가능하게 함
- 유효하지 않은 status 값이 전달되면 400 Bad Request 반환

## 구현 단계

### 1. FriendRequestData 스키마에 receiver_id 추가
```python
class FriendRequestData(BaseModel):
    """친구 요청 데이터 (조회용)"""
    id: int
    requester_id: int
    receiver_id: int       # 추가: 양방향 조회 시 상대방 식별에 필요
    status: str
```
- **무엇을 하는가**: 응답 스키마에 `receiver_id`를 추가하여, 클라이언트가 해당 친구 관계의 요청자와 수신자를 모두 확인할 수 있게 한다
- `requester_id`만 있으면 user_id가 requester_id일 때 상대방(receiver)을 알 수 없음

### 2. GET /api/friend-requests 엔드포인트 수정
```python
from sqlalchemy import or_

VALID_STATUSES = {"pending", "accepted", "rejected", "all"}

@app.get("/api/friend-requests", response_model=FriendRequestListResponse)
def get_friend_requests(user_id: int, status: str = "pending", db: Session = Depends(get_db)):
    """특정 사용자의 친구 요청 조회 (양방향, status 필터)"""

    # status 유효성 검증
    if status not in VALID_STATUSES:
        raise HTTPException(
            status_code=status_module.HTTP_400_BAD_REQUEST,
            detail=f"Invalid status. Allowed values: {list(VALID_STATUSES)}"
        )

    # 양방향 조건: user_id가 requester_id 또는 receiver_id인 경우
    direction_filter = or_(
        Friendship.requester_id == user_id,
        Friendship.receiver_id == user_id
    )

    # status 필터 구성: "all"이면 status 필터 미적용
    if status == "all":
        query = db.query(Friendship).filter(direction_filter)
    else:
        query = db.query(Friendship).filter(
            direction_filter,
            Friendship.status == status
        )

    requests = query.all()

    # FriendRequestData 형식으로 변환
    request_data = [
        FriendRequestData(
            id=req.id,
            requester_id=req.requester_id,
            receiver_id=req.receiver_id,
            status=req.status
        )
        for req in requests
    ]

    return FriendRequestListResponse(requests=request_data)
```
- **무엇을 하는가**: 기존 엔드포인트를 양방향 검색과 status 필터로 확장한다
- `or_()`: SQLAlchemy에서 OR 조건을 만드는 함수. `requester_id == user_id OR receiver_id == user_id`로 양방향 검색
- `status == "all"`: status 필터를 조건에 추가하지 않아 모든 status의 레코드를 반환
- 기본값 `status="pending"`: 기존 동작과의 호환성 유지 (파라미터 미전달 시 pending만 반환)
- `status` 파라미터 이름이 FastAPI의 `status` 모듈과 충돌할 수 있으므로, HTTPException에서 `status` 모듈을 사용할 때는 별도 이름(예: `status_module`)으로 임포트해야 한다

## 수정/생성할 파일 목록

| 파일 경로 | 작업 유형 | 변경 내용 |
|-----------|-----------|-----------|
| backend/main.py | 수정 | `FriendRequestData` 스키마에 `receiver_id` 추가, GET 엔드포인트에 `status` 파라미터 및 양방향 조건 추가, `or_` 임포트 추가 |

## 완료 체크리스트

- [o] `GET /api/friend-requests?user_id=1` 호출 시 user_id=1이 requester_id인 것과 receiver_id인 것 모두 반환됨 (기본 status=pending)
- [o] `GET /api/friend-requests?user_id=1&status=accepted` 호출 시 accepted 상태만 반환됨
- [o] `GET /api/friend-requests?user_id=1&status=rejected` 호출 시 rejected 상태만 반환됨
- [o] `GET /api/friend-requests?user_id=1&status=all` 호출 시 pending, accepted, rejected 모든 상태가 반환됨
- [o] `GET /api/friend-requests?user_id=1&status=invalid` 호출 시 400 Bad Request 반환됨
- [o] 응답 데이터에 `requester_id`와 `receiver_id` 모두 포함됨
- [o] 기존 엔드포인트 호출 방식(status 파라미터 미전달)이 이전과 동일하게 동작 (pending만 반환)
