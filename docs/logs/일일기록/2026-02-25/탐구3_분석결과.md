# OpenClaw Tool 호출 작동과정 분석

> OpenClaw가 스스로 tool 사용을 판단하고, 호출하며, 결과를 해석하는 전체 과정을 코드 기반으로 분석한 문서입니다.

---

## 1. 전체 아키텍처 개요

```
+------------------------------------------------------------------+
|                        OpenClaw 시스템                             |
+------------------------------------------------------------------+
|                                                                    |
|  +------------------+    +------------------+    +---------------+ |
|  |   CLI / Channel  |--->|    Gateway       |--->|  Agent Runner | |
|  | (Telegram, etc.) |    | (WebSocket 서버)  |    | (pi-embedded) | |
|  +------------------+    +------------------+    +-------+-------+ |
|                                                          |         |
|                          +-------------------------------v-------+ |
|                          |        pi-agent-core (SDK)            | |
|                          |  +----------+    +-----------------+  | |
|                          |  | Agent    |    | Session Manager |  | |
|                          |  | Loop     |    | (대화 이력 관리) |  | |
|                          |  +----+-----+    +-----------------+  | |
|                          +-------|-------------------------------+ |
|                                  |                                 |
|                          +-------v------+                          |
|                          |  streamFn()  |  (LLM API 호출)         |
|                          +-------+------+                          |
|                                  |                                 |
+----------------------------------|--+------------------------------+
                                   |  ^
                            요청   |  | 응답
                                   v  |
                          +--------+--+--------+
                          |   OpenRouter API    |
                          |  (LLM: Claude,     |
                          |   GPT, Gemini 등)  |
                          +--------------------+
```

---

## 2. Tool 정의 및 등록 과정

### 2.1 Tool 정의 구조

OpenClaw의 모든 tool은 `AgentTool` 인터페이스를 따릅니다.

```
소스: src/agents/tools/common.ts

+------------------------------------------+
|            AgentTool 인터페이스             |
+------------------------------------------+
| name: string          // "exec"          |
| label?: string        // "Shell 실행"     |
| description?: string  // 용도 설명        |
| parameters: Schema    // TypeBox 스키마   |
| ownerOnly?: boolean   // 권한 제한        |
| execute: async (                         |
|   toolCallId,         // "toolu_xxxx"    |
|   args,               // {command:"ls"}  |
|   signal,             // AbortSignal     |
|   onUpdate            // 스트리밍 콜백    |
| ) => AgentToolResult                     |
+------------------------------------------+
```

### 2.2 Tool 생성 팩토리 패턴

```
소스: src/agents/tools/*.ts

각 tool은 팩토리 함수로 생성됩니다:

  createExecTool()          --> Shell 명령 실행
  createBrowserTool()       --> 브라우저 자동화
  createMessageTool()       --> 메시지 전송
  createWebSearchTool()     --> 웹 검색
  createWebFetchTool()      --> URL 내용 가져오기
  createMemorySearchTool()  --> 메모리 검색
  createCronTool()          --> 정기 작업 등록
  createCanvasTool()        --> Canvas UI
  createTtsTool()           --> 음성 합성
  ...
```

### 2.3 Tool 등록 파이프라인

```
소스: src/agents/pi-tools.ts, pi-tool-definition-adapter.ts

+-------------------+     +------------------+     +------------------+
| createOpenClaw    |     | 정책 필터링       |     | 스키마 정규화     |
| CodingTools()     |---->| (Policy Pipeline)|---->| (Provider별)     |
| + OpenClawTools() |     |                  |     |                  |
+-------------------+     +------------------+     +------------------+
                                                          |
        +-------------------+     +-------------------+   |
        | AbortSignal 래핑  |<----| Hook 래핑          |<--+
        |                   |     | (before_tool_call) |
        +--------+----------+     +-------------------+
                 |
                 v
        +-------------------+     +-------------------+
        | toToolDefinitions |---->| createAgentSession|
        | (변환 어댑터)      |     | (SDK에 등록)      |
        +-------------------+     +-------------------+
```

### 2.4 Tool 정책 필터링 파이프라인

```
소스: src/agents/tool-policy-pipeline.ts, pi-tools.policy.ts

전체 tool 목록에서 정책에 따라 필터링:

  [모든 Tool] ──> ownerOnly 정책 ─┐
                                   v
              프로필(Profile) 정책 ──> 프로바이더 프로필 정책 ──┐
                                                               v
              글로벌 allow/deny ──> 프로바이더별 allow/deny ──┐
                                                              v
              에이전트별 정책 ──> 그룹(채널)별 정책 ──┐
                                                     v
              샌드박스 정책 ──> 서브에이전트 정책 ──> [최종 Tool 목록]
```

---

## 3. Tool 사용 판단 과정 (LLM의 자율 판단)

### 3.1 핵심 원리

OpenClaw는 **tool 사용 여부를 직접 판단하지 않습니다**. LLM(Claude, GPT 등)이 스스로 판단합니다.

```
+---------------------------------------------------------------------+
|                      LLM의 Tool 사용 판단 과정                        |
+---------------------------------------------------------------------+
|                                                                       |
|  1. 시스템 프롬프트에 tool 스키마가 포함됨                              |
|     ┌─────────────────────────────────────────────────────────┐       |
|     │  System: "당신은 AI 비서입니다.                          │       |
|     │  사용 가능한 도구:                                       │       |
|     │  - exec: Shell 명령 실행 {command: string}              │       |
|     │  - web_search: 웹 검색 {query: string}                  │       |
|     │  - message: 메시지 전송 {text: string, channel: string} │       |
|     │  ..."                                                   │       |
|     └─────────────────────────────────────────────────────────┘       |
|                                                                       |
|  2. 사용자 메시지를 받으면 LLM이 자율적으로 판단                       |
|     ┌─────────────────────────────────────────────────────────┐       |
|     │  User: "현재 디렉토리의 파일 목록을 보여줘"               │       |
|     └─────────────────────────────────────────────────────────┘       |
|                          |                                            |
|                          v                                            |
|     ┌─────────────────────────────────────────────────────────┐       |
|     │  LLM 내부 추론:                                         │       |
|     │  "파일 목록을 보려면 shell 명령이 필요하다.               │       |
|     │   exec tool을 사용하여 'ls -la'를 실행하겠다."           │       |
|     └─────────────────────────────────────────────────────────┘       |
|                          |                                            |
|                          v                                            |
|     ┌─────────────────────────────────────────────────────────┐       |
|     │  LLM 응답: tool_use 블록 생성                           │       |
|     │  {                                                      │       |
|     │    type: "tool_use",                                    │       |
|     │    id: "toolu_01ABC",                                   │       |
|     │    name: "exec",                                        │       |
|     │    input: { command: "ls -la" }                         │       |
|     │  }                                                      │       |
|     └─────────────────────────────────────────────────────────┘       |
+---------------------------------------------------------------------+
```

### 3.2 시스템 프롬프트 구성

```
소스: src/agents/pi-embedded-runner/run/attempt.ts (buildEmbeddedSystemPrompt)

시스템 프롬프트 = 기본 에이전트 지시 + Tool 스키마 + 사용자 설정

+----------------------------------+
|        System Prompt 구성         |
+----------------------------------+
| [에이전트 인격/역할 정의]         |
| [대화 규칙]                       |
| [Tool 사용 가이드라인]            |
| [사용 가능 Tool 목록 + 스키마]    |  <-- 이 부분이 LLM의 판단 근거
| [사용자 커스텀 지시]              |
+----------------------------------+
```

---

## 4. Tool 호출 실행 루프 (Agent Loop)

### 4.1 전체 실행 흐름 (아스키 시퀀스 다이어그램)

```
  사용자       OpenClaw         pi-agent-core        streamFn       OpenRouter/LLM
    |          (attempt.ts)       (SDK)             (pi-ai)           (API)
    |              |                |                  |                |
    |  메시지 전송  |                |                  |                |
    |------------->|                |                  |                |
    |              |                |                  |                |
    |              | prompt(text)   |                  |                |
    |              |--------------->|                  |                |
    |              |                |                  |                |
    |              |                | streamFn(ctx)    |                |
    |              |                |----------------->|                |
    |              |                |                  |                |
    |              |                |                  | POST /chat/    |
    |              |                |                  | completions    |
    |              |                |                  |--------------->|
    |              |                |                  |                |
    |              |                |                  |   스트리밍 응답 |
    |              |                |                  |<===============|
    |              |                |                  |                |
    |              |                |  message_start   |                |
    |              |<~~~~~~~~~~~~~~~|<-----------------+                |
    |              |                |                  |                |
    |              |                |  message_update  |  (텍스트 델타)  |
    |              |<~~~~~~~~~~~~~~~|<-----------------+                |
    |              |                |                  |                |
    |              |                |  tool_use 감지!  |                |
    |              |                |  (LLM이 tool     |                |
    |              |                |   호출을 결정)   |                |
    |              |                |                  |                |
    |              | tool_execution |                  |                |
    |              | _start 이벤트  |                  |                |
    |              |<~~~~~~~~~~~~~~~|                  |                |
    |              |                |                  |                |
    |              |                |  tool.execute()  |                |
    |              |                |  호출             |                |
    |              |                |-----+            |                |
    |              |                |     | (실제 tool  |                |
    |              |                |     |  실행)      |                |
    |              |                |<----+            |                |
    |              |                |                  |                |
    |              | tool_execution |                  |                |
    |              | _end 이벤트    |                  |                |
    |              |<~~~~~~~~~~~~~~~|                  |                |
    |              |                |                  |                |
    |              |                | tool_result를    |                |
    |              |                | 대화 이력에 추가  |                |
    |              |                |                  |                |
    |              |                |  +-- 자동 반복 --+                |
    |              |                |  | (tool 결과를  |                |
    |              |                |  |  LLM에 전달)  |                |
    |              |                |  v               |                |
    |              |                | streamFn(ctx)    |                |
    |              |                |----------------->|                |
    |              |                |                  | POST /chat/    |
    |              |                |                  | completions    |
    |              |                |                  |  (+ tool_result|
    |              |                |                  |   포함)        |
    |              |                |                  |--------------->|
    |              |                |                  |                |
    |              |                |                  |  최종 텍스트   |
    |              |                |                  |  응답          |
    |              |                |                  |<===============|
    |              |                |                  |                |
    |              |                | agent_end        |                |
    |              |<~~~~~~~~~~~~~~~| (stop_reason:    |                |
    |              |                |  "end_turn")     |                |
    |              |                |                  |                |
    |  최종 응답   |                |                  |                |
    |<-------------|                |                  |                |
    |              |                |                  |                |
```

### 4.2 외부 재시도 루프 (run.ts)

```
소스: src/agents/pi-embedded-runner/run.ts

+---------------------------------------------------------------+
|              runEmbeddedPiAgent() 외부 루프                     |
+---------------------------------------------------------------+
|                                                                 |
|   while (retryCount < MAX_RUN_LOOP_ITERATIONS) {               |
|     |                                                           |
|     v                                                           |
|   +-----------------------------+                               |
|   | runEmbeddedAttempt()        |                               |
|   | (단일 시도 실행)             |                               |
|   +-------------+---------------+                               |
|                 |                                                |
|                 v                                                |
|   +---------------------------+                                 |
|   | 결과 확인                  |                                 |
|   |  - promptError?           |                                 |
|   |  - timedOut?              |                                 |
|   |  - contextOverflow?       |                                 |
|   +--+--------+--------+-----+                                  |
|      |        |        |                                        |
|      v        v        v                                        |
|   성공     오류      오버플로우                                  |
|    |        |          |                                        |
|    |        v          v                                        |
|    |   인증 로테이션  세션 압축(compaction)                      |
|    |   또는 모델     + 재시도                                    |
|    |   폴백                                                     |
|    |        |          |                                        |
|    v        +----+-----+                                        |
|   return         |                                              |
|   response       v                                              |
|              continue (루프 반복)                                |
|   }                                                             |
+---------------------------------------------------------------+
```

### 4.3 내부 에이전트 루프 (SDK 내부)

```
소스: @mariozechner/pi-agent-core (SDK 내부)

+---------------------------------------------------------------+
|           pi-agent-core 내부 Agent Loop                        |
+---------------------------------------------------------------+
|                                                                 |
|   session.prompt(userMessage) 호출 시:                          |
|                                                                 |
|   1. 사용자 메시지를 messages[] 에 추가                         |
|      messages.push({ role: "user", content: userMessage })     |
|                                                                 |
|   2. LLM API 호출 (streamFn)                                   |
|      +-------------------------------------------------+       |
|      | streamFn({                                       |       |
|      |   model,                                        |       |
|      |   messages: [...대화이력...],                    |       |
|      |   tools: [...tool스키마...],                     |       |
|      |   systemPrompt: "..."                           |       |
|      | })                                              |       |
|      +-------------------------------------------------+       |
|                          |                                      |
|   3. LLM 응답 파싱       v                                      |
|      +------------------------+                                 |
|      | 응답 content 분석:      |                                 |
|      | - type: "text"  ?      |---> 텍스트 축적                 |
|      | - type: "tool_use" ?   |---> Tool 실행으로 분기           |
|      +------------------------+                                 |
|                          |                                      |
|   4. stopReason 확인      v                                      |
|      +----------------------------------+                       |
|      | stopReason == "end_turn"         |---> 루프 종료, 반환    |
|      | stopReason == "tool_use"         |---> 5단계로           |
|      | stopReason == "max_tokens"       |---> 에러 처리         |
|      +----------------------------------+                       |
|                          |                                      |
|   5. Tool 실행            v                                      |
|      +--------------------------------------------------+      |
|      | for (toolUse of response.toolUseBlocks) {         |      |
|      |   emit("tool_execution_start", toolUse)           |      |
|      |   result = await tool.execute(                    |      |
|      |     toolUse.id,      // "toolu_01ABC"             |      |
|      |     toolUse.input,   // { command: "ls -la" }     |      |
|      |     signal,          // AbortSignal               |      |
|      |     onUpdate         // 스트리밍 업데이트          |      |
|      |   )                                               |      |
|      |   emit("tool_execution_end", result)              |      |
|      | }                                                 |      |
|      +--------------------------------------------------+      |
|                          |                                      |
|   6. Tool 결과를 대화 이력에 추가                               |
|      messages.push({                                            |
|        role: "user",                                            |
|        content: [{                                              |
|          type: "tool_result",                                   |
|          tool_use_id: "toolu_01ABC",                            |
|          content: "{\"status\":\"success\", ...}"               |
|        }]                                                       |
|      })                                                         |
|                          |                                      |
|   7. 2단계로 돌아감 (LLM에 tool 결과 전달)                      |
|      goto Step 2  ----->  (반복)                                |
|                                                                 |
+---------------------------------------------------------------+
```

---

## 5. 주고받는 데이터 구조

### 5.1 LLM API 요청 형식

```
소스: streamFn → OpenRouter API

POST https://openrouter.ai/api/v1/chat/completions

{
  "model": "anthropic/claude-sonnet-4-20250514",
  "messages": [
    {
      "role": "system",
      "content": "당신은 AI 비서입니다. 사용 가능한 도구: ..."
    },
    {
      "role": "user",
      "content": "현재 디렉토리 파일 목록 보여줘"
    }
  ],
  "tools": [
    {
      "type": "function",
      "function": {
        "name": "exec",
        "description": "Execute shell commands in the workspace",
        "parameters": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "description": "The shell command to execute"
            }
          },
          "required": ["command"]
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "web_search",
        "description": "Search the web",
        "parameters": {
          "type": "object",
          "properties": {
            "query": { "type": "string" }
          },
          "required": ["query"]
        }
      }
    }
    // ... 더 많은 tool 정의
  ],
  "stream": true
}
```

### 5.2 LLM 응답: Tool 호출 결정

```
LLM이 tool 사용을 결정했을 때의 응답:

{
  "role": "assistant",
  "content": [
    {
      "type": "text",
      "text": "파일 목록을 확인하겠습니다."
    },
    {
      "type": "tool_use",             <-- Tool 호출 블록
      "id": "toolu_01HjK9mNpQ",      <-- 고유 호출 ID
      "name": "exec",                 <-- 호출할 tool 이름
      "input": {                      <-- Tool 파라미터
        "command": "ls -la"
      }
    }
  ],
  "stop_reason": "tool_use"           <-- 멈춤 이유: tool 사용
}


LLM이 tool 없이 텍스트만 응답할 때:

{
  "role": "assistant",
  "content": [
    {
      "type": "text",
      "text": "안녕하세요! 무엇을 도와드릴까요?"
    }
  ],
  "stop_reason": "end_turn"           <-- 멈춤 이유: 대화 종료
}
```

### 5.3 Tool 실행 결과 (AgentToolResult)

```
소스: src/agents/tools/common.ts (jsonResult 함수)

+----------------------------------------------+
|          AgentToolResult<T> 구조              |
+----------------------------------------------+
| content: [                                    |
|   {                                          |
|     type: "text",                            |
|     text: '{"status":"success",              |  <-- LLM이 읽는 텍스트
|             "output":"total 32\\n            |      (JSON 직렬화)
|             drwxr-xr-x 5 user ...",          |
|             "exitCode": 0}'                  |
|   }                                          |
| ]                                            |
| details: {                                   |  <-- OpenClaw 내부용
|   status: "success",                         |      구조화 데이터
|   output: "total 32\ndrwxr-xr-x 5 user ...",|
|   exitCode: 0                                |
| }                                            |
+----------------------------------------------+

에러 발생 시:

+----------------------------------------------+
| content: [                                    |
|   {                                          |
|     type: "text",                            |
|     text: '{"status":"error",                |
|             "tool":"exec",                   |
|             "error":"Permission denied"}'    |
|   }                                          |
| ]                                            |
| details: {                                   |
|   status: "error",                           |
|   tool: "exec",                              |
|   error: "Permission denied"                 |
| }                                            |
+----------------------------------------------+

이미지 결과 (예: 브라우저 스크린샷):

+----------------------------------------------+
| content: [                                    |
|   {                                          |
|     type: "text",                            |
|     text: "스크린샷 캡처 완료"                |
|   },                                         |
|   {                                          |
|     type: "image",                           |
|     data: "iVBORw0KGgo...",   // base64      |
|     mimeType: "image/png"                    |
|   }                                          |
| ]                                            |
+----------------------------------------------+
```

### 5.4 Tool 결과 → LLM 전달 형식

```
Tool 결과는 tool_result 블록으로 대화 이력에 추가됩니다:

{
  "role": "user",
  "content": [
    {
      "type": "tool_result",
      "tool_use_id": "toolu_01HjK9mNpQ",     <-- 원래 호출 ID와 매칭
      "content": "{\"status\":\"success\",
                   \"output\":\"total 32\\n...\",
                   \"exitCode\":0}"
    }
  ]
}
```

### 5.5 전체 대화 이력 구조 (Messages 배열)

```
+----------------------------------------------------------------------+
|  messages: AgentMessage[]  (시간순 대화 기록)                          |
+----------------------------------------------------------------------+
|                                                                        |
| [0] { role: "user",                                                   |
|        content: "현재 디렉토리 파일 목록 보여줘" }                     |
|                                                                        |
| [1] { role: "assistant",                                               |
|        content: [                                                      |
|          { type: "text", text: "파일 목록을 확인하겠습니다." },        |
|          { type: "tool_use",                                           |
|            id: "toolu_01HjK9mNpQ",                                    |
|            name: "exec",                                               |
|            input: { command: "ls -la" } }                              |
|        ],                                                              |
|        stop_reason: "tool_use" }                                       |
|                                                                        |
| [2] { role: "user",                                                   |
|        content: [                                                      |
|          { type: "tool_result",                                        |
|            tool_use_id: "toolu_01HjK9mNpQ",                           |
|            content: "{\"status\":\"success\",...}" }                   |
|        ] }                                                             |
|                                                                        |
| [3] { role: "assistant",                                               |
|        content: [                                                      |
|          { type: "text",                                               |
|            text: "현재 디렉토리에 다음 파일이 있습니다:\n..." }        |
|        ],                                                              |
|        stop_reason: "end_turn" }                                       |
|                                                                        |
+----------------------------------------------------------------------+
```

---

## 6. Tool 호출 결과 해석 과정

### 6.1 이벤트 기반 결과 처리

```
소스: src/agents/pi-embedded-subscribe.handlers.ts
      src/agents/pi-embedded-subscribe.handlers.tools.ts

+----------------------------------------------------------------+
|              이벤트 핸들러 라우팅                                  |
+----------------------------------------------------------------+
|                                                                  |
|  SDK 이벤트 발생                                                  |
|       |                                                          |
|       v                                                          |
|  createEmbeddedPiSessionEventHandler(ctx)                        |
|       |                                                          |
|       +---> "message_start"         --> handleMessageStart()     |
|       +---> "message_update"        --> handleMessageUpdate()    |
|       +---> "message_end"           --> handleMessageEnd()       |
|       +---> "tool_execution_start"  --> handleToolExecutionStart()|
|       +---> "tool_execution_update" --> handleToolExecutionUpdate()|
|       +---> "tool_execution_end"    --> handleToolExecutionEnd() |
|       +---> "agent_start"           --> handleAgentStart()       |
|       +---> "agent_end"             --> handleAgentEnd()         |
|       +---> "auto_compaction_start" --> handleAutoCompaction()   |
|                                                                  |
+----------------------------------------------------------------+
```

### 6.2 Tool 실행 이벤트 처리 상세

```
소스: src/agents/pi-embedded-subscribe.handlers.tools.ts

+------------------------------------------------------------------+
|  handleToolExecutionStart(ctx, evt)                                |
+------------------------------------------------------------------+
|  1. 보류 중인 블록 응답 플러시                                      |
|  2. tool 메타데이터 추적                                            |
|     ctx.state.toolMetaById.set(toolCallId, {                       |
|       toolName, args, startTime, ...                               |
|     })                                                             |
|  3. 에이전트 이벤트 발행                                            |
|     emitAgentEvent({ phase: "start", name, toolCallId, args })     |
|  4. before_tool_call 훅 실행                                       |
+------------------------------------------------------------------+
                          |
                          v
+------------------------------------------------------------------+
|  handleToolExecutionEnd(ctx, evt)                                  |
+------------------------------------------------------------------+
|  1. tool 결과 위생 처리 (민감 데이터 제거)                          |
|  2. 성공/실패 판별                                                  |
|     - 성공: 메시징 tool의 경우 전송 텍스트 커밋                    |
|     - 실패: 에러 상태 기록, 재시도 로직 트리거                     |
|  3. tool 메타데이터 업데이트                                        |
|     ctx.state.toolMetas.push({ toolName, meta })                   |
|  4. after_tool_call 훅 실행                                        |
|  5. 에이전트 이벤트 발행                                            |
|     emitAgentEvent({ phase: "end", name, toolCallId, result })     |
|  6. 구독자에게 결과 콜백                                            |
|     ctx.params.onToolResult?.(payload)                             |
+------------------------------------------------------------------+
```

### 6.3 LLM의 Tool 결과 해석

```
Tool 결과를 받은 LLM의 해석 과정:

+-------------------------------------------------------------------+
|                                                                     |
|  LLM이 받는 컨텍스트:                                               |
|                                                                     |
|  messages = [                                                       |
|    ...(이전 대화),                                                  |
|    { role: "assistant", content: [                                  |
|        { type: "tool_use", name: "exec",                           |
|          input: {command: "ls -la"} }                               |
|    ]},                                                              |
|    { role: "user", content: [                                       |
|        { type: "tool_result",                                       |
|          content: '{"status":"success",                             |
|                     "output":"README.md\nsrc/\npackage.json\n..."}'|
|    ]}                                                               |
|  ]                                                                  |
|                                                                     |
|  LLM은 이 tool_result의 JSON을 읽고:                               |
|  1. status 확인 → "success" → 결과 활용                             |
|  2. output 파싱 → 파일 목록 추출                                    |
|  3. 자연어 응답 생성:                                               |
|     "현재 디렉토리에 README.md, src/, package.json이 있습니다."     |
|                                                                     |
|  또는 추가 tool 호출 판단:                                          |
|  - output을 보고 추가 정보가 필요하면 → 또 다른 tool_use 생성      |
|  - 충분한 정보가 있으면 → 텍스트 응답 + stop_reason: "end_turn"    |
|                                                                     |
+-------------------------------------------------------------------+
```

---

## 7. 멀티 Tool 호출 (연쇄 호출) 과정

```
사용자: "프로젝트 구조를 파악하고 README 내용도 보여줘"

+------------------------------------------------------------------+
| 1회차 LLM 호출                                                     |
+------------------------------------------------------------------+
|  LLM 응답:                                                         |
|  [text] "프로젝트 구조와 README를 확인하겠습니다."                  |
|  [tool_use] exec { command: "ls -la" }        ← Tool 1            |
|  [tool_use] exec { command: "cat README.md" } ← Tool 2            |
|  stop_reason: "tool_use"                                           |
+------------------------------------------------------------------+
                          |
                          v (두 tool 모두 실행)
+------------------------------------------------------------------+
| Tool 실행 결과                                                      |
+------------------------------------------------------------------+
|  [tool_result] id=tool1 → "README.md\nsrc/\npackage.json\n..."    |
|  [tool_result] id=tool2 → "# OpenClaw\nAI assistant..."           |
+------------------------------------------------------------------+
                          |
                          v (결과를 대화이력에 추가 후 2회차 호출)
+------------------------------------------------------------------+
| 2회차 LLM 호출                                                     |
+------------------------------------------------------------------+
|  LLM이 두 tool 결과를 모두 읽고 최종 응답 생성:                     |
|  [text] "프로젝트 구조는 다음과 같습니다:                           |
|          - README.md: 프로젝트 소개...                              |
|          - src/: 소스코드 디렉토리...                               |
|          - package.json: 의존성 정의..."                            |
|  stop_reason: "end_turn"                                           |
+------------------------------------------------------------------+
```

---

## 8. Tool 호출 전체 생명주기 요약

```
+====================================================================+
||                   Tool 호출 완전한 생명주기                        ||
+====================================================================+
||                                                                    ||
||  [1단계] Tool 정의 및 등록                                         ||
||  ┌──────────────────────────────────────────────────────────┐      ||
||  │  팩토리 함수 → 정책 필터링 → 스키마 정규화 → Hook 래핑  │      ||
||  │  → toToolDefinitions() → createAgentSession()에 전달     │      ||
||  └──────────────────────────────────────────────────────────┘      ||
||                              |                                     ||
||  [2단계] LLM의 자율적 Tool 사용 판단                               ||
||  ┌──────────────────────────────────────────────────────────┐      ||
||  │  사용자 메시지 수신 → 시스템 프롬프트의 tool 목록 참조   │      ||
||  │  → LLM이 "이 작업에는 tool X가 필요하다" 판단           │      ||
||  │  → tool_use 블록 생성 (name, id, input 포함)            │      ||
||  └──────────────────────────────────────────────────────────┘      ||
||                              |                                     ||
||  [3단계] Tool 실행                                                 ||
||  ┌──────────────────────────────────────────────────────────┐      ||
||  │  SDK가 tool_use 블록 파싱 → tool.execute() 호출          │      ||
||  │  → before_tool_call 훅 → 실제 실행 → after_tool_call 훅 │      ||
||  │  → AgentToolResult 반환 (content + details)              │      ||
||  └──────────────────────────────────────────────────────────┘      ||
||                              |                                     ||
||  [4단계] 결과 전달 및 해석                                         ||
||  ┌──────────────────────────────────────────────────────────┐      ||
||  │  tool_result 메시지로 변환 → 대화 이력에 추가             │      ||
||  │  → LLM에 다시 전달 → LLM이 결과를 읽고:                  │      ||
||  │    - 추가 tool 필요? → [3단계]로 반복                    │      ||
||  │    - 충분? → 최종 텍스트 응답 생성 (end_turn)            │      ||
||  └──────────────────────────────────────────────────────────┘      ||
||                              |                                     ||
||  [5단계] 최종 응답 전달                                            ||
||  ┌──────────────────────────────────────────────────────────┐      ||
||  │  LLM 텍스트 응답 → 사용자/채널에 전달                    │      ||
||  └──────────────────────────────────────────────────────────┘      ||
||                                                                    ||
+====================================================================+
```

---

## 9. 핵심 소스 파일 참조

| 파일 경로 | 역할 |
|-----------|------|
| `src/agents/pi-embedded-runner/run.ts` | 외부 재시도 루프, 모델 선택, 인증 로테이션 |
| `src/agents/pi-embedded-runner/run/attempt.ts` | 단일 시도: 세션 설정, 프롬프트 호출, 결과 캡처 |
| `src/agents/pi-tool-definition-adapter.ts` | AgentTool → ToolDefinition 변환 어댑터 |
| `src/agents/pi-tools.ts` | Tool 생성 + 정책 적용 + 래핑 파이프라인 |
| `src/agents/pi-tools.policy.ts` | Tool 접근 제어 정책 |
| `src/agents/pi-tools.schema.ts` | 프로바이더별 스키마 정규화 |
| `src/agents/pi-embedded-subscribe.ts` | SDK 이벤트 구독 |
| `src/agents/pi-embedded-subscribe.handlers.ts` | 이벤트 라우팅 |
| `src/agents/pi-embedded-subscribe.handlers.tools.ts` | Tool 실행 이벤트 핸들러 |
| `src/agents/openclaw-tools.ts` | OpenClaw 전용 tool 조립 |
| `src/agents/tools/*.ts` | 개별 tool 구현체 |
| `src/agents/tools/common.ts` | jsonResult(), imageResult() 헬퍼 |
| `src/plugins/tools.ts` | 플러그인 tool 수집 및 등록 |
| `src/plugins/registry.ts` | 플러그인 레지스트리 자료구조 |

---

## 10. 핵심 결론

1. **Tool 사용 판단은 LLM이 수행**: OpenClaw 코드는 tool 사용 여부를 결정하지 않습니다. LLM(Claude, GPT 등)이 시스템 프롬프트에 포함된 tool 스키마를 보고 자율적으로 판단합니다.

2. **3중 루프 구조**: 외부 재시도 루프(run.ts) → 단일 시도(attempt.ts) → SDK 내부 Agent Loop(pi-agent-core)의 3중 구조로 안정성을 확보합니다.

3. **SDK가 실행 엔진**: `@mariozechner/pi-agent-core` SDK가 tool_use 파싱, tool 실행, tool_result 전달, 반복 호출을 모두 관리합니다. OpenClaw는 이벤트를 구독하여 모니터링합니다.

4. **이중 표현 결과**: Tool 결과는 `content`(LLM용 JSON 텍스트)와 `details`(내부용 구조화 데이터)의 이중 구조를 가집니다.

5. **다층 정책 시스템**: Tool 접근은 글로벌/프로바이더/에이전트/그룹/샌드박스 수준의 다층 정책으로 세밀하게 제어됩니다.
