# 핀볼 맵 전환 실행계획

## 요구사항 요약

**요구사항**: 핀볼 게임에서 다음 스테이지로 넘어가는 기능을 구현한다. 테스트용으로 키보드 'n' 키를 누르면 다음 스테이지로 전환한다.

**목적**: 사용자에게 다양한 스테이지를 제공해 반복적인 지루함을 줄인다.

## 현재상태 분석

- Pinball.jsx의 useEffect 내부에 모든 Bodies(벽, 장애물, 범퍼, 타겟, 플리퍼, 공)가 하드코딩되어 있다.
- 스테이지 개념이 없으며, 단일 맵 구성만 존재한다.
- 키보드 이벤트 핸들러(handleKeyDown/handleKeyUp)가 이미 구현되어 있어 'n' 키 추가가 용이하다.
- World.add/World.remove로 Bodies를 동적으로 추가/제거할 수 있다.
- 배경이미지는 CSS backgroundImage로 적용되어 있다.

## 구현 방법

스테이지별 맵 데이터를 배열로 정의하고, 스테이지 전환 시 기존 장애물/범퍼/타겟을 World에서 제거한 뒤 새로운 스테이지의 Bodies를 생성하여 추가한다. 벽, 플리퍼, 공, 죽음구역은 모든 스테이지에서 공통으로 유지한다. `currentStage` 상태를 React state가 아닌 useEffect 내부의 로컬 변수로 관리하여, Matter.js 이벤트 핸들러에서 클로저 문제 없이 접근할 수 있도록 한다.

## 구현 단계

### 1. 스테이지 맵 데이터 정의 파일 생성

```javascript
// react/main/src/stages.js

const stages = [
  {
    name: 'Stage 1',
    background: '/images/pinball_back.png',
    obstacles: [
      { type: 'circle', x: 300, y: 300, radius: 30, options: { isStatic: true, render: { fillStyle: '#0f3460' } } },
      { type: 'circle', x: 500, y: 300, radius: 30, options: { isStatic: true, render: { fillStyle: '#0f3460' } } },
    ],
    bumpers: [
      { x: 400, y: 600, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e74c3c' } } },
    ],
    targets: [
      { x: 500, y: 500, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#87CEEB' } } },
    ],
  },
  {
    name: 'Stage 2',
    background: '/images/pinball_back.png',
    obstacles: [
      { type: 'circle', x: 200, y: 400, radius: 25, options: { isStatic: true, render: { fillStyle: '#2ecc71' } } },
      { type: 'circle', x: 400, y: 250, radius: 35, options: { isStatic: true, render: { fillStyle: '#2ecc71' } } },
      { type: 'circle', x: 550, y: 450, radius: 25, options: { isStatic: true, render: { fillStyle: '#2ecc71' } } },
    ],
    bumpers: [
      { x: 300, y: 550, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e67e22' } } },
      { x: 500, y: 700, radius: 40, options: { isStatic: true, restitution: 1.5, label: 'bumper', render: { fillStyle: '#e67e22' } } },
    ],
    targets: [
      { x: 350, y: 400, radius: 35, options: { isStatic: true, restitution: 1.5, label: 'target', render: { fillStyle: '#9b59b6' } } },
    ],
  },
];

export default stages;
```
- 각 스테이지는 name, background, obstacles, bumpers, targets 배열을 가진다.
- 스테이지를 추가하려면 배열에 새 객체를 추가하면 된다.
- 벽, 플리퍼, 공, 죽음구역은 공통이므로 스테이지 데이터에 포함하지 않는다.

### 2. 스테이지 Bodies 생성 함수 작성

```javascript
// Pinball.jsx useEffect 내부에 추가

// 스테이지별 Bodies를 생성하는 함수
const createStageBodies = (stageData) => {
  const bodies = [];

  // 장애물 생성
  stageData.obstacles.forEach((obs) => {
    if (obs.type === 'circle') {
      bodies.push(Bodies.circle(obs.x, obs.y, obs.radius, obs.options));
    }
  });

  // 범퍼 생성
  stageData.bumpers.forEach((b) => {
    bodies.push(Bodies.circle(b.x, b.y, b.radius, b.options));
  });

  // 타겟 생성
  stageData.targets.forEach((t) => {
    bodies.push(Bodies.circle(t.x, t.y, t.radius, t.options));
  });

  return bodies;
};
```
- stages.js에서 가져온 스테이지 데이터를 받아 Matter.js Bodies 배열을 반환한다.
- 장애물, 범퍼, 타겟을 순서대로 생성한다.

### 3. 스테이지 전환 함수 작성

```javascript
// Pinball.jsx useEffect 내부에 추가

let currentStageIndex = 0;
let currentStageBodies = [];  // 현재 스테이지의 Bodies 추적용

// 스테이지 로드 함수
const loadStage = (stageIndex) => {
  // 1. 기존 스테이지 Bodies 제거
  if (currentStageBodies.length > 0) {
    World.remove(engine.world, currentStageBodies);
  }

  // 2. 새 스테이지 Bodies 생성 및 추가
  const stageData = stages[stageIndex];
  currentStageBodies = createStageBodies(stageData);
  World.add(engine.world, currentStageBodies);

  // 3. 공 위치/속도 초기화
  Body.setPosition(ball, { x: 250, y: 400 });
  Body.setVelocity(ball, { x: 0, y: 0 });
  Body.setAngularVelocity(ball, 0);

  // 4. 스테이지 인덱스 업데이트
  currentStageIndex = stageIndex;

  console.log(`Stage loaded: ${stageData.name}`);
};
```
- 기존 스테이지의 Bodies를 World에서 제거한 후, 새 스테이지의 Bodies를 생성하여 추가한다.
- 공의 위치와 속도를 초기화하여 새 스테이지에서 다시 시작한다.
- currentStageBodies 배열로 현재 스테이지의 Bodies를 추적한다.

### 4. 초기 로딩을 loadStage로 변경

```javascript
// 기존 코드: obstacle1, obstacle2, bumper, target을 개별 생성 후 World.add
// 변경 후:

// 공통 Bodies만 World에 추가 (벽, 플리퍼, 공, 죽음구역)
World.add(engine.world, [
  ground,
  leftWall,
  rightWall,
  upWall,
  deathZone,
  ball,
  leftFlipper,
  rightFlipper,
  leftFlipperConstraint,
  rightFlipperConstraint
]);

// 첫 번째 스테이지 로드
loadStage(0);
```
- 기존의 obstacle1, obstacle2, bumper, target 개별 생성 코드를 제거한다.
- 공통 Bodies(벽, 플리퍼, 공, 죽음구역)만 World.add로 추가한다.
- loadStage(0)으로 첫 번째 스테이지를 로드한다.

### 5. 'n' 키 이벤트 핸들러 추가

```javascript
// handleKeyDown 함수에 추가

const handleKeyDown = (event) => {
  if (event.key === 'ArrowLeft') {
    console.log('왼쪽 방향키 눌림');
    isLeftKeyPressed = true;
  }
  if (event.key === 'ArrowRight') {
    console.log('오른쪽 방향키 눌림');
    isRightKeyPressed = true;
  }
  // 'n' 키: 다음 스테이지로 전환
  if (event.key === 'n' || event.key === 'N') {
    const nextIndex = (currentStageIndex + 1) % stages.length;
    loadStage(nextIndex);
    console.log(`Stage changed to: ${stages[nextIndex].name}`);
  }
};
```
- 'n' 또는 'N' 키를 누르면 다음 스테이지로 전환한다.
- `% stages.length`로 마지막 스테이지 이후 첫 스테이지로 순환한다.

### 6. cleanup 함수에서 스테이지 Bodies 정리

```javascript
// 기존 cleanup에 추가

return () => {
  if (bgmRef.current) {
    bgmRef.current.pause();
    bgmRef.current.currentTime = 0;
  }
  Events.off(engine, 'beforeUpdate');
  Events.off(engine, 'collisionStart');
  window.removeEventListener('keydown', handleKeyDown);
  window.removeEventListener('keyup', handleKeyUp);
  if (sceneRef.current) {
    sceneRef.current.removeEventListener('touchstart', handleTouchStart);
    sceneRef.current.removeEventListener('touchend', handleTouchEnd);
  }
  Render.stop(render);
  Runner.stop(runner);
  Engine.clear(engine);
};
```
- Engine.clear(engine)이 모든 Bodies를 정리하므로 추가 정리 코드는 불필요하다.

## 수정/생성할 파일 목록

| 파일 경로 | 작업 유형 | 변경 내용 |
|-----------|-----------|-----------|
| react/main/src/stages.js | 생성 | 스테이지별 맵 데이터 배열 정의 |
| react/main/src/Pinball.jsx | 수정 | stages.js import, createStageBodies/loadStage 함수 추가, 초기 로딩 변경, 'n' 키 핸들러 추가, 개별 장애물 생성 코드 제거 |

## 완료 체크리스트

- [ ] 게임 시작 시 Stage 1의 장애물/범퍼/타겟이 화면에 표시된다
- [ ] 'n' 키를 누르면 장애물/범퍼/타겟 배치가 Stage 2로 변경된다
- [ ] 스테이지 전환 시 공이 초기 위치(250, 400)로 이동한다
- [ ] 스테이지 전환 시 기존 스테이지의 오브젝트가 완전히 사라진다
- [ ] 마지막 스테이지에서 'n' 키를 누르면 첫 스테이지로 순환한다
- [ ] 벽, 플리퍼, 죽음구역은 스테이지 전환 후에도 정상 동작한다
- [ ] 콘솔에 스테이지 전환 로그가 출력된다
- [ ] 브라우저 콘솔에 에러가 발생하지 않는다
