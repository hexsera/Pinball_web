# 핀볼게임 오브젝트 재배치 실행계획

## 요구사항 요약

**요구사항**: 핀볼 게임의 벽, 바닥, 플리퍼를 재배치하여 깔대기(funnel) 구조로 변경한다.

**목적**: 현재 바닥이 평탄하여 공이 떨어지면 바로 죽음구역에 진입한다. 깔대기 형태로 바닥을 구성하면 공이 중앙 구멍으로 모이고, 플리퍼가 그 구멍 앞에 위치하여 공을 쳐낼 수 있는 구조가 된다.

## 현재상태 분석

- 캔버스 크기: 700px(가로) × 1100px(높이) (Render options)
- 벽 두께: 왼쪽/오른쪽/천장/바닥 모두 **20px**
- 바닥: 단일 rectangle (x=350, y=1200, 가로700, 세로20) — 평탄
- 플리퍼: 왼쪽(x=200, y=1150), 오른쪽(x=550, y=1150) — 바닥 위에 수평 배치
- 회전축: 왼쪽 pointB {x:210, y:1150}, 오른쪽 pointB {x:540, y:1150}
- 죽음구역: 바닥과 동일한 위치 (x=350, y=1200)
- 공이 플리퍼를 피하면 바로 죽음구역에 진입 → 생존 시간이 짧음

## 구현 방법

Matter.js의 `Bodies.rectangle()`을 생성한 후 `Body.setAngle()`로 회전시켜 경사면 벽을 만든다. rectangle은 중심좌표가 정확하고 회전 후에도 중심 위치가 변하지 않아 좌표 계산이 안정적이다. 기존 평탄한 바닥 rectangle을 제거하고, 회전된 rectangle 2개로 깔대기를 구성한다. 경사면의 길이와 각도는 시작점과 끝점 사이의 수평·수직 거리로 계산한다. 벽 두께는 기존 20px에서 40px로 증가시킨다.

**깔대기 기하학 설계 (좌표 참고):**
```
왼쪽벽(40px)                                  오른쪽벽(40px)
|  40                                    660  |
|   \                                   /     |
|    \  경사면 시작 y=950               /      |
|     \                               /       |
|      \                             /        |
|       \  경사면 끝   y=1080       /         |
|        270 ___[플리퍼]___[플리퍼]___ 430    |
|            |   구멍(160px)   |              |
|            | deathZone y=1095|              |
```

## 구현 단계

### 1. 벽 두께 증가 (20px → 40px)
```javascript
// 왼쪽 벽 — 중심 x=20 (두께40의 절반), 높이 1100(캔버스 높이)
const leftWall = Bodies.rectangle(20, 550, 40, 1100, {
  isStatic: true,
  render: { fillStyle: '#16213e' }
});

// 오른쪽 벽 — 중심 x=680 (700 - 40/2)
const rightWall = Bodies.rectangle(680, 550, 40, 1100, {
  isStatic: true,
  render: { fillStyle: '#16213e' }
});

// 천장 — 중심 y=20 (두께40의 절반)
const upWall = Bodies.rectangle(350, 20, 700, 40, {
  isStatic: true,
  render: { fillStyle: '#16213e' }
});
```
- 왼쪽 벽 내면이 x=40, 오른쪽 벽 내면이 x=660이 되도록 중심좌표 계산
- 캔버스 높이 1100 기준으로 벽 높이도 맞춤
- 기존 바닥 rectangle(ground)은 제거한다 (깔대기 경사면으로 대체)

### 2. 깔대기 경사면 생성 (rectangle + Body.setAngle)
```javascript
// 경사면 공통 설정값 계산
// 왼쪽: (40, 950) → (270, 1080), 수평 230px, 수직 130px
const FUNNEL_LENGTH = Math.sqrt(230 * 230 + 130 * 130); // ≈ 264.2px
const FUNNEL_ANGLE = Math.atan2(130, 230);              // ≈ 0.515 rad (29.5°)
const FUNNEL_THICKNESS = 40;

// 왼쪽 경사면 — 중심: (40+270)/2=155, (950+1080)/2=1015
const leftFunnelWall = Bodies.rectangle(155, 1015, FUNNEL_LENGTH, FUNNEL_THICKNESS, {
  isStatic: true,
  render: { fillStyle: '#16213e' }
});
Body.setAngle(leftFunnelWall, FUNNEL_ANGLE);  // 오른쪽 아래 방향으로 회전

// 오른쪽 경사면 — 중심: (660+430)/2=545, y=1015
const rightFunnelWall = Bodies.rectangle(545, 1015, FUNNEL_LENGTH, FUNNEL_THICKNESS, {
  isStatic: true,
  render: { fillStyle: '#16213e' }
});
Body.setAngle(rightFunnelWall, -FUNNEL_ANGLE); // 왼쪽 아래 방향으로 회전 (대칭)
```
- `Bodies.rectangle`은 중심좌표가 정확하므로, 회전 후에도 중심 위치가 변하지 않는다
- `Body.setAngle()`은 rectangle의 중심을 축으로 회전시킨다
- `Math.atan2(수직거리, 수평거리)`로 경사면의 정확한 각도를 계산한다
- 오른쪽 경사면은 `-FUNNEL_ANGLE`로 왼쪽과 대칭 회전

### 3. 플리퍼 및 회전축 재배치
```javascript
// 왼쪽 플리퍼 — 회전축 x=270, 중심 = 회전축 + 길이절반(50) = x=320
const leftFlipper = Bodies.rectangle(320, 1090, 100, 20, { ... });

// 오른쪽 플리퍼 — 회전축 x=430, 중심 = 회전축 - 길이절반(50) = x=380
const rightFlipper = Bodies.rectangle(380, 1090, 100, 20, { ... });

// 왼쪽 회전축 — 경사면 끝점 왼쪽(x=270)
const leftFlipperConstraint = Constraint.create({
  bodyA: leftFlipper,
  pointA: { x: -40, y: 0 },
  pointB: { x: 270, y: 1090 },
  stiffness: 1, damping: 0, length: 0
});

// 오른쪽 회전축 — 경사면 끝점 오른쪽(x=430)
const rightFlipperConstraint = Constraint.create({
  bodyA: rightFlipper,
  pointA: { x: 40, y: 0 },
  pointB: { x: 430, y: 1090 },
  stiffness: 1, damping: 0, length: 0
});
```
- 왼쪽 플리퍼 중심 x=320: 회전축(x=270) + 플리퍼 길이절반(50px)
- 오른쪽 플리퍼 중심 x=380: 회전축(x=430) - 플리퍼 길이절반(50px)
- y=1090: 경사면 끝(y=1080) 아래에 배치하여 경사면과 겹치지 않음

### 5. 죽음구역 재배치
```javascript
// 죽음구역: 구멍(x=270~430) 아래에 배치
const deathZone = Bodies.rectangle(350, 1095, 160, 30, {
  isStatic: true,
  isSensor: true,
  label: 'deathZone',
  render: {
    fillStyle: '#8b0000',
    opacity: 0.3
  }
});
```
- 가로 160px: 깔대기 구멍 폭과 동일 (x=270~430)
- y=1095: 경사면 끝(y=1080) + 약간의 간격 아래
- 공이 플리퍼를 통과하면 여기서 감지 후 생명 감소 처리

### 6. World.add 목록에 새 오브젝트 추가
```javascript
World.add(engine.world, [
  leftWall,
  rightWall,
  upWall,
  leftFunnelWall,   // 새 추가: 왼쪽 경사면
  rightFunnelWall,  // 새 추가: 오른쪽 경사면
  deathZone,
  ball,
  obstacle1,
  obstacle2,
  bumper,
  target,
  leftFlipper,
  rightFlipper,
  leftFlipperConstraint,
  rightFlipperConstraint
]);
```
- 기존 `ground`는 제거 (깔대기 경사면으로 대체됨)
- 나머지 오브젝트(장애물, 범퍼, 목표)는 유지

## 수정/생성할 파일 목록

| 파일 경로 | 작업 유형 | 변경 내용 |
|-----------|-----------|-----------|
| react/main/src/Pinball.jsx | 수정 | 벽 두께 증가, ground 제거, 깔대기 경사면 2개 추가, 플리퍼+회전축 좌표 변경, deathZone 재배치, World.add 목록 수정 |

## 완료 체크리스트

- [ ] 왼쪽/오른쪽/천장 벽 두께가 40px로 증가됨
- [ ] 기존 평탄한 바닥(ground)이 제거됨
- [ ] 왼쪽/오른쪽 경사면이 깔대기 형태로 생성되어 공이 중앙 구멍으로 모임
- [ ] 경사면이 왼쪽/오른쪽 벽과 끊김 없이 연결됨
- [ ] 플리퍼가 깔대기 구멍 위에 배치되고, 공을 쳐낼 수 있음
- [ ] 죽음구역이 구멍 아래에 위치하여 공이 통과 시 감지됨
- [ ] 공이 경사면 사이 틈에 끼지 않음
- [ ] 게임 실행 시 에러 없이 동작
