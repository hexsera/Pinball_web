# 멀티플레이어 핀볼 — 구현 단계

**목적**: 기존 싱글플레이 핀볼에 WebSocket 기반 실시간 멀티플레이를 추가한다.
상대방 플립퍼를 내 화면에 렌더링하고, 양 플레이어의 조작이 실시간으로 동기화된다.

---

## Phase 1. 백엔드 — WebSocket 서버

1. FastAPI에 `/ws/game/{room_id}` WebSocket 엔드포인트를 추가한다.
2. 인메모리 룸 매니저를 구현해 최대 2명의 플레이어를 하나의 룸으로 관리한다.
3. 플레이어가 접속·퇴장할 때 상대방에게 상태 변경 이벤트를 브로드캐스트한다.

## Phase 2. 백엔드 — 메시지 프로토콜 정의

1. 클라이언트↔서버 간 JSON 메시지 스키마를 정의한다 (`type`, `payload` 구조).
2. 플리퍼 입력(`flipper_press`, `flipper_release`)과 공 위치(`ball_sync`) 메시지 타입을 확정한다.
3. 룸 생성·참가·준비 완료 흐름(로비 프로토콜)을 정의한다.

## Phase 3. 프론트엔드 — WebSocket 연결 관리

1. WebSocket 연결·재연결·해제를 담당하는 커스텀 훅(`useGameSocket`)을 만든다.
2. 연결 상태(대기 중, 상대 입장, 게임 중, 종료)를 전역 상태로 관리한다.
3. 서버로부터 수신한 메시지를 이벤트 큐에 쌓고 게임 루프에서 소비하는 구조를 만든다.

## Phase 4. 프론트엔드 — 상대방 플립퍼 렌더링

1. 현재 `Pinball.jsx`의 플립퍼 Matter.js 바디를 좌·우 분리해 독립 제어가 가능하게 한다.
2. 상대방 플립퍼 전용 바디를 씬에 추가하고, 로컬 입력과 분리된 별도 상태로 구동한다.
3. 수신된 `flipper_press/release` 메시지를 받아 상대방 플립퍼 각도를 업데이트한다.

## Phase 5. 프론트엔드 — 로컬 입력 동기화 송신

1. 로컬 플리퍼 키 입력 발생 시 WebSocket으로 메시지를 즉시 전송한다.
2. 주기적으로(예: 50 ms) 공의 위치·속도를 `ball_sync` 메시지로 전송한다.
3. 과도한 메시지 전송을 막기 위해 입력 스로틀링/디바운싱을 적용한다.

## Phase 6. UI — 멀티플레이 로비

1. 룸 코드 생성 및 입력 화면을 만들어 친구와 같은 룸에 입장할 수 있도록 한다.
2. 상대방 닉네임·준비 상태를 표시하는 대기 화면을 구현한다.
3. 한 쪽이 퇴장하거나 연결이 끊어졌을 때 게임을 중단하고 알림을 표시한다.

## Phase 7. 통합 테스트 및 배포

1. 두 클라이언트를 로컬에서 실행해 입력 동기화 지연·오류를 검증한다.
2. Docker Compose에 WebSocket 라우팅이 정상 동작하도록 Traefik 설정을 확인한다.
3. 비정상 종료(탭 닫기, 네트워크 단절) 시 룸 정리 로직이 동작하는지 확인한다.
