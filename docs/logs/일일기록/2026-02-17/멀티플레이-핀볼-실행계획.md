# 멀티플레이 핀볼 실행계획

## 요구사항 요약

**요구사항**: 기존 싱글플레이 핀볼 게임에 멀티플레이 시나리오를 추가한다. "멀티플레이 시작" 버튼으로 진입하며, 내 플립퍼 / 상대 플립퍼 / 공 / 벽만 존재하는 단순한 구성으로 구현한다.

**목적**: 두 명의 플레이어가 같은 공을 두고 플립퍼로 경쟁하는 멀티플레이 경험을 제공한다. API/보안은 최소 수준으로 유지한다.

## 현재상태 분석

- `frontend/src/pages/Pinball/Pinball.jsx`: Matter.js 기반 싱글플레이 게임. 플립퍼 2개, 공 1개, 벽, 범퍼, 깔대기, 플런저로 구성됨.
- `frontend/src/pages/PinballPage/PinballPage.jsx`: 싱글플레이 게임을 표시하는 페이지. `<Pinball>` 컴포넌트를 렌더링.
- `frontend/src/pages/Pinball/stageConfigs.js`: 스테이지별 범퍼/타겟 설정. 멀티플레이에서는 사용하지 않음.
- `frontend/src/App.jsx`: 라우팅 설정 파일. 멀티플레이 라우트 추가 필요.
- 멀티플레이 전용 컴포넌트 없음 — 신규 생성 필요.

## 구현 방법

- 멀티플레이는 **동일한 Matter.js 엔진 위에 플립퍼를 4개(내 것 2개 + 상대방 2개)**로 구성한다.
- 상대방 플립퍼는 화면 상단에 **좌우 반전**되어 위치하고, 키보드 입력 대신 **자동 반응(간단한 규칙)**으로 동작하도록 한다.
- 실시간 네트워크 통신 없이 로컬 시뮬레이션으로 구현한다(간단한 수준).
- **`PinballPage.jsx` 안에 `mode` state를 추가해 싱글/멀티를 전환**하고, 새 파일은 `MultiPinball.jsx` 하나만 생성한다.

## 구현 단계

### 1. MultiPinball 컴포넌트 파일 생성

```javascript
// frontend/src/pages/Pinball/MultiPinball.jsx
function MultiPinball({ onReady }) {
  const sceneRef = useRef(null);
  const engineRef = useRef(null);

  useEffect(() => {
    // Matter.js 엔진, 렌더러 초기화
    // 벽(4면), 공, 내 플립퍼(하단), 상대 플립퍼(상단) 생성
  }, []);
}
```
- 싱글플레이 `Pinball.jsx`를 기반으로 범퍼/타겟/플런저를 제거한 단순 구성으로 시작.
- `useEffect` 안에서 Matter.js 엔진을 초기화하고 필요한 바디만 추가한다.

### 2. 기본 물리 객체 생성 (벽, 공)

```javascript
// MultiPinball.jsx 내부
const leftWall = Bodies.rectangle(20, 550, 40, 1100, { isStatic: true });
const rightWall = Bodies.rectangle(700, 550, 40, 1100, { isStatic: true });
const topWall = Bodies.rectangle(350, 20, 700, 40, { isStatic: true });
const bottomWall = Bodies.rectangle(350, 1190, 700, 40, { isStatic: true });
const ball = Bodies.circle(350, 550, 15, { restitution: 0.8, friction: 0, frictionAir: 0 });
```
- 4면 벽으로 공이 밖으로 나가지 않도록 막는다. 싱글플레이의 깔대기/죽음구역은 사용하지 않는다.
- 공은 화면 중앙에서 시작한다.

### 3. 내 플립퍼(하단) 생성 및 키보드 입력 연결

```javascript
// 하단 내 플립퍼 - 싱글플레이와 동일한 좌표/각도 로직 사용
const myLeftFlipper = Bodies.rectangle(265, 995, 100, 20, { chamfer: { radius: 10 } });
const myRightFlipper = Bodies.rectangle(400, 995, 100, 20, { chamfer: { radius: 10 } });
// Constraint로 회전축 고정, 키보드 좌/우 방향키로 조작
```
- 기존 싱글플레이 플립퍼 코드를 그대로 재사용한다.
- `pressFlipperKeyRef`, `releaseFlipperKeyRef` 패턴 유지.

### 4. 상대방 플립퍼(상단) 생성 및 자동 동작 구현

```javascript
// 상단 상대 플립퍼 - y 좌표를 상단(y=105)으로, 각도를 반전
const oppLeftFlipper = Bodies.rectangle(265, 105, 100, 20, { chamfer: { radius: 10 } });
const oppRightFlipper = Bodies.rectangle(400, 105, 100, 20, { chamfer: { radius: 10 } });
// Events.on(engine, 'beforeUpdate') 에서 공 y 위치가 300 이하일 때 플립퍼 작동
```
- 상대 플립퍼는 공이 상단 영역에 접근하면 자동으로 반응하도록 간단한 규칙을 사용한다.
- 네트워크 없이 로컬에서만 동작한다.

### 5. PinballPage에 mode state 및 모드 전환 버튼 추가

```javascript
// frontend/src/pages/PinballPage/PinballPage.jsx
const [mode, setMode] = useState('single'); // 'single' | 'multi'

// 헤더 영역에 버튼 추가
<Button onClick={() => setMode(mode === 'single' ? 'multi' : 'single')}>
  {mode === 'single' ? '멀티플레이 시작' : '싱글플레이 시작'}
</Button>

// 게임 영역에서 mode에 따라 컴포넌트 전환
{mode === 'single'
  ? <Pinball onReady={() => setIsReady(true)} />
  : <MultiPinball onReady={() => setIsReady(true)} />
}
```
- 별도 라우트 없이 `PinballPage` 안에서 state만으로 싱글/멀티를 전환한다.
- 모드가 바뀌면 `isReady`를 `false`로 초기화해 로딩 스피너가 다시 표시되도록 한다.

## 수정/생성할 파일 목록

| 파일 경로 | 작업 유형 | 변경 내용 |
|-----------|-----------|-----------|
| `frontend/src/pages/Pinball/MultiPinball.jsx` | 생성 | 멀티플레이 Matter.js 게임 컴포넌트 |
| `frontend/src/pages/PinballPage/PinballPage.jsx` | 수정 | mode state 추가, 모드 전환 버튼, 조건부 컴포넌트 렌더링 |

## 완료 체크리스트

- [ ] PinballPage 헤더에 모드 전환 버튼이 표시된다
- [ ] 버튼 클릭 시 싱글/멀티 게임이 전환된다
- [ ] 화면 하단에 내 플립퍼 2개(좌/우)가 표시되고 키보드로 조작된다
- [ ] 화면 상단에 상대 플립퍼 2개가 표시되고 자동으로 반응한다
- [ ] 공이 화면 밖으로 나가지 않고 4면 벽 안에서 움직인다
- [ ] 콘솔 에러 없이 게임이 실행된다
