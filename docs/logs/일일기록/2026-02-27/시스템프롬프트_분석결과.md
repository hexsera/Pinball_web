# OpenClaw 시스템 프롬프트 분석 결과

> 분석 대상: `/home/hexsera/snap/code/226/.local/share/Trash/files/openclaw-src/`
> 작성일: 2026-02-27

---

## 목차

1. [핵심 요약](#핵심-요약)
2. [전체 동작 흐름도](#전체-동작-흐름도)
3. [시스템 프롬프트에 포함되는 파일들](#시스템-프롬프트에-포함되는-파일들)
4. [코드 흐름 상세 설명](#코드-흐름-상세-설명)
5. [시스템 프롬프트 구성 섹션](#시스템-프롬프트-구성-섹션)
6. [핵심 소스파일 위치](#핵심-소스파일-위치)
7. [코드에서 오는 정보들 (하드코딩 섹션)](#코드에서-오는-정보들-하드코딩-섹션)
8. [도구 목록이 텍스트로 바뀌는 과정](#도구-목록이-텍스트로-바뀌는-과정)

---

## 핵심 요약

OpenClaw는 새 세션에서 사용자와 첫 대화할 때, **워크스페이스 디렉토리의 텍스트 파일들을 읽어서** 시스템 프롬프트를 조립합니다.

쉽게 말하면:
- "컨닝 페이퍼"처럼 미리 써둔 메모 파일들을 AI에게 주고, "이걸 읽고 나서 사용자와 대화해" 라고 지시하는 구조입니다.

---

## 전체 동작 흐름도

```
사용자가 메시지 보냄
        │
        ▼
runEmbeddedAttempt()
  [파일: src/agents/pi-embedded-runner/run/attempt.ts]
        │
        ▼
resolveBootstrapContextForRun()
  [파일: src/agents/bootstrap-files.ts]
  → 워크스페이스 폴더에서 텍스트 파일들 읽기
        │
        ├─ loadWorkspaceBootstrapFiles()
        │    [파일: src/agents/workspace.ts]
        │    → 실제로 파일을 하드디스크에서 읽음
        │
        ├─ filterBootstrapFilesForSession()
        │    → 서브에이전트면 일부 파일만 사용
        │
        ├─ applyBootstrapHookOverrides()
        │    [파일: src/agents/bootstrap-hooks.ts]
        │    → 플러그인이 파일 내용 수정 가능
        │
        └─ buildBootstrapContextFiles()
             [파일: src/agents/pi-embedded-helpers/bootstrap.ts]
             → 파일 크기 제한 적용 (파일당 20,000자)
             → 총 합계 제한 적용 (150,000자)
        │
        ▼
buildEmbeddedSystemPrompt()
  [파일: src/agents/pi-embedded-runner/system-prompt.ts]
        │
        ▼
buildAgentSystemPrompt()  ← 핵심 함수!
  [파일: src/agents/system-prompt.ts]
  → 여러 섹션을 하나의 긴 텍스트로 조립
  → 텍스트 파일 내용을 "# Project Context" 섹션에 삽입
        │
        ▼
   완성된 시스템 프롬프트
        │
        ▼
       AI (LLM) 에게 전달
        │
        ▼
    AI가 응답 생성
```

---

## 시스템 프롬프트에 포함되는 파일들

### 파일 저장 위치

실제 파일들은 **워크스페이스 디렉토리**에 있습니다:

```
~/.openclaw/workspace/    ← 기본 경로 (사용자 홈 폴더)
│
├── AGENTS.md    ← 에이전트 역할 및 역량 정의
├── SOUL.md      ← AI의 성격/말투 설정 (있으면 적용)
├── TOOLS.md     ← 사용 가능한 도구 설명
├── IDENTITY.md  ← AI 신원 정보
├── USER.md      ← 사용자 선호도 및 배경 정보
├── HEARTBEAT.md ← 주기적 상태 확인용 프롬프트
├── BOOTSTRAP.md ← 신규 사용자 온보딩 지시사항
└── MEMORY.md    ← 이전 대화 기억 (또는 memory.md)
```

### 각 파일의 역할 설명

| 파일 | 역할 | 쉬운 설명 |
|------|------|-----------|
| `AGENTS.md` | 에이전트 정의 | "나는 이런 역할을 하는 AI야" |
| `SOUL.md` | 성격/톤 설정 | "나는 이런 말투로 말해야 해" |
| `TOOLS.md` | 도구 문서 | "이런 기능들을 사용할 수 있어" |
| `IDENTITY.md` | 신원 정보 | "내 이름은 OO이고, OO 서비스야" |
| `USER.md` | 사용자 정보 | "이 사용자는 이런 사람이야" |
| `HEARTBEAT.md` | 상태 확인 | "주기적으로 이걸 체크해" |
| `BOOTSTRAP.md` | 온보딩 | "처음 만난 사용자에게 이렇게 해" |
| `MEMORY.md` | 기억 | "이전에 이런 대화를 했었어" |

### 템플릿 파일 위치 (기본 예시)

```
openclaw/docs/reference/templates/
├── AGENTS.md
├── SOUL.md
├── TOOLS.md
├── IDENTITY.md
├── USER.md
├── HEARTBEAT.md
├── BOOTSTRAP.md
├── SOUL.dev.md      (개발자용 버전)
├── TOOLS.dev.md
├── IDENTITY.dev.md
├── USER.dev.md
└── AGENTS.dev.md
```

---

## 코드 흐름 상세 설명

### 1단계: 파일 읽기

**파일:** `src/agents/workspace.ts` (약 441~495번째 줄)

```
하드디스크에서 파일을 읽는 단계

읽는 파일 목록:
  1. AGENTS.md
  2. SOUL.md
  3. TOOLS.md
  4. IDENTITY.md
  5. USER.md
  6. HEARTBEAT.md
  7. BOOTSTRAP.md
  8. MEMORY.md (또는 memory.md)

성능 최적화:
  - 파일이 변경되지 않으면 메모리에서 재사용 (캐싱)
  - 파일 수정 시간(mtime)을 확인해서 변경 여부 판단
```

### 2단계: 서브에이전트 필터링

**파일:** `src/agents/workspace.ts` (약 499~507번째 줄)

```
일반 사용자 세션: 모든 파일 사용
서브에이전트 세션: 2개만 사용
  - AGENTS.md
  - TOOLS.md

이유: 서브에이전트는 작업 실행만 하므로
     성격(SOUL), 사용자 정보(USER) 등은 불필요
```

### 3단계: 크기 제한 적용

**파일:** `src/agents/pi-embedded-helpers/bootstrap.ts` (약 187~246번째 줄)

```
파일 1개당 최대: 20,000자 (약 A4 10장 분량)
전체 합계 최대: 150,000자 (약 A4 75장 분량)

파일이 너무 크면 잘라내기:
  - 앞부분 70% 유지
  - 뒷부분 20% 유지
  - 중간 부분: "[...잘림, 전체 내용은 파일을 직접 읽으세요...]"
```

### 4단계: 시스템 프롬프트 조립

**파일:** `src/agents/system-prompt.ts` (약 196~695번째 줄)

```
여러 섹션을 하나의 텍스트로 합치는 단계

최종 시스템 프롬프트 구조:
  [AI 기본 신원]
  + [사용 가능한 도구 목록]
  + [안전 규칙]
  + [스킬 정보]
  + [사용자 시간대]
  + [# Project Context]  ← 여기에 텍스트 파일들 삽입!
     ## AGENTS.md
     (파일 내용)
     ## SOUL.md
     (파일 내용)
     ...
  + [런타임 정보]
```

---

## 시스템 프롬프트 구성 섹션

최종 시스템 프롬프트는 다음 섹션들로 구성됩니다:

```
┌─────────────────────────────────────────┐
│  1. 기본 신원                            │
│     "You are a personal assistant..."   │
├─────────────────────────────────────────┤
│  2. 도구 목록                            │
│     read, write, exec, web_search...    │
├─────────────────────────────────────────┤
│  3. 안전 규칙                            │
│     자기보존 금지, 사용자 감독 우선...    │
├─────────────────────────────────────────┤
│  4. 스킬 정보 (있을 때만)               │
│     커스텀 스킬 목록                     │
├─────────────────────────────────────────┤
│  5. 메모리 기능 (있을 때만)             │
│     memory_search, memory_get 안내      │
├─────────────────────────────────────────┤
│  6. 사용자 정보 (있을 때만)             │
│     승인된 사용자 목록, 시간대           │
├─────────────────────────────────────────┤
│  7. 메시징 채널 정보 (있을 때만)        │
│     Telegram/Slack/Discord 힌트         │
├─────────────────────────────────────────┤
│  8. 음성 TTS 정보 (있을 때만)          │
│     텍스트→음성 변환 지침               │
├─────────────────────────────────────────┤
│  9. 샌드박스 정보 (있을 때만)          │
│     컨테이너 환경, 경로 정보            │
├─────────────────────────────────────────┤
│ 10. 프로젝트 컨텍스트 ← 핵심!          │
│     # Project Context                   │
│     ## AGENTS.md                        │
│     (파일 내용)                         │
│     ## SOUL.md                          │
│     (파일 내용)                         │
│     ... 나머지 파일들 ...               │
├─────────────────────────────────────────┤
│ 11. 런타임 정보                         │
│     모델명, OS, 채널, 생각 모드 등      │
└─────────────────────────────────────────┘
```

### SOUL.md의 특별 처리

SOUL.md 파일이 있으면, AI에게 추가 지시가 붙습니다:

```
"SOUL.md가 있으면, 그 파일의 성격과 말투를 따르세요.
딱딱하고 일반적인 답변은 피하고, SOUL.md의 지침을 따르세요.
단, 더 높은 우선순위의 지시사항이 있으면 그것을 우선합니다."
```

---

## 핵심 소스파일 위치

| 역할 | 파일 경로 |
|------|-----------|
| 전체 실행 시작점 | `src/agents/pi-embedded-runner/run/attempt.ts` |
| 부트스트랩 파일 조율 | `src/agents/bootstrap-files.ts` |
| 실제 파일 읽기 | `src/agents/workspace.ts` |
| 훅 처리 | `src/agents/bootstrap-hooks.ts` |
| 크기 제한 적용 | `src/agents/pi-embedded-helpers/bootstrap.ts` |
| 시스템 프롬프트 래퍼 | `src/agents/pi-embedded-runner/system-prompt.ts` |
| **시스템 프롬프트 핵심 조립** | **`src/agents/system-prompt.ts`** |
| 파라미터 빌드 | `src/agents/system-prompt-params.ts` |
| 리포트/디버그 | `src/agents/system-prompt-report.ts` |

---

## 설정으로 변경 가능한 값들

| 설정 | 기본값 | 의미 |
|------|--------|------|
| `bootstrapMaxChars` | 20,000자 | 파일 1개당 최대 크기 |
| `bootstrapTotalMaxChars` | 150,000자 | 전체 파일 합계 최대 크기 |
| `userTimezone` | "UTC" | 사용자 시간대 |
| `timeFormat` | "auto" | 시간 표시 형식 |
| `repoRoot` | (자동감지) | git 저장소 루트 경로 |
| `ownerDisplay` | "raw" | 사용자 식별자 표시 방식 |

---

## 플러그인 확장 포인트

플러그인(확장 기능)은 `agent.bootstrap` 훅을 통해 파일 내용을 동적으로 수정할 수 있습니다:

```
수정 가능한 항목:
  - 워크스페이스 경로
  - 부트스트랩 파일 내용
  - 설정(config) 값
  - 세션 정보

활용 예시:
  - 특정 사용자에게만 다른 SOUL.md 적용
  - 날짜/시간에 따라 다른 지시사항 추가
  - 외부 서비스에서 동적으로 내용 가져오기
```

---

---

## 코드에서 오는 정보들 (하드코딩 섹션)

텍스트 파일(SOUL.md 등)에서 오는 내용 외에, 코드 자체에 고정으로 적혀 있어서 항상 시스템 프롬프트에 포함되는 내용들이 있습니다.

**파일:** `src/agents/system-prompt.ts`

아래 표는 각 섹션이 어디서 오는지 정리한 것입니다:

| 섹션 이름 | 출처 | 항상 포함? | 설명 |
|-----------|------|-----------|------|
| 기본 신원 | 코드 하드코딩 | ✅ 항상 | `"You are a personal assistant running inside OpenClaw."` (1줄, 고정) |
| `## Tooling` | 코드 하드코딩 + 런타임 도구 목록 | ✅ 항상 | 도구 이름과 설명 목록. 아래 섹션에서 상세 설명 |
| `## Tool Call Style` | 코드 하드코딩 | ✅ 항상 | "도구를 쓸 때 일일이 말하지 말고 그냥 써라" |
| `## Safety` | 코드 하드코딩 | ✅ 항상 | 자기보존 금지, 사용자 감독 우선 등 안전 수칙 |
| `## OpenClaw CLI Quick Reference` | 코드 하드코딩 | ✅ 항상 | `openclaw gateway start/stop/restart` 등 CLI 명령어 |
| `## Skills (mandatory)` | 코드 하드코딩 + `skillsPrompt` 변수 | 스킬 있을 때만 | 워크스페이스에 스킬이 있을 때만 포함됨 |
| `## Memory Recall` | 코드 하드코딩 | `memory_search` 도구 있을 때만 | 메모리 기능 사용법 안내 |
| `## OpenClaw Self-Update` | 코드 하드코딩 | `gateway` 도구 있을 때만 | 자동업데이트 허용 조건 안내 |
| `## Model Aliases` | 런타임 설정값 | 별칭 설정 있을 때만 | 모델 이름 별칭 목록 |
| `## Workspace` | 런타임 값 (워크스페이스 경로) | ✅ 항상 | `"Your working directory is: /home/user/..."` |
| `## Documentation` | 코드 하드코딩 + `docsPath` 변수 | docsPath 설정 시 | openclaw 공식 문서 경로 안내 |
| `## Sandbox` | 런타임 값 | 샌드박스 모드일 때만 | Docker 컨테이너 경로, 권한 정보 |
| `## Authorized Senders` | 설정값 (ownerNumbers) | 설정 시 | 허가된 사용자 ID 목록 |
| `## Current Date & Time` | 설정값 (userTimezone) | 시간대 설정 시 | 사용자 시간대 정보 |
| `## Workspace Files (injected)` | 코드 하드코딩 | ✅ 항상 | "아래에 파일들이 로드되어 있다"는 안내 |
| `## Reply Tags` | 코드 하드코딩 | 서브에이전트 아닐 때 | `[[reply_to_current]]` 태그 사용법 |
| `## Messaging` | 코드 하드코딩 + 런타임 채널 정보 | 서브에이전트 아닐 때 | Telegram/Slack 등 메시징 사용법 |
| `## Voice (TTS)` | 런타임 값 (ttsHint) | TTS 설정 시 | 텍스트→음성 변환 안내 |
| `## Group Chat Context` | 런타임 값 (extraSystemPrompt) | 그룹채팅/서브에이전트일 때 | 플러그인/설정이 추가한 커스텀 프롬프트 |
| `## Reactions` | 런타임 값 | 리액션 기능 설정 시 | 이모지 리액션 사용 가이드 |
| `## Reasoning Format` | 런타임 값 (reasoningTagHint) | think 태그 모드일 때 | `<think>...</think><final>...</final>` 형식 안내 |
| `# Project Context` | **파일 시스템 (SOUL.md 등)** | contextFiles 있을 때 | 워크스페이스 텍스트 파일들의 내용 |
| `## Silent Replies` | 코드 하드코딩 | 서브에이전트 아닐 때 | 할 말 없을 때 `•` 만 응답하라는 규칙 |
| `## Heartbeats` | 코드 하드코딩 + heartbeatPrompt 설정 | 서브에이전트 아닐 때 | 주기적 상태 확인 응답 규칙 |
| `## Runtime` | 런타임 값 | ✅ 항상 | 모델명, OS, 채널, 생각 모드 등 실행 환경 정보 |

### 항상 포함되는 코드 하드코딩 내용 예시

실제로 `system-prompt.ts` 코드에서 문자열로 직접 써진 내용들:

```
## Safety
You have no independent goals: do not pursue self-preservation, replication,
resource acquisition, or power-seeking...
Prioritize safety and human oversight over completion...

## Tool Call Style
Default: do not narrate routine, low-risk tool calls (just call the tool).
Narrate only when it helps...

## OpenClaw CLI Quick Reference
OpenClaw is controlled via subcommands. Do not invent commands.
- openclaw gateway status
- openclaw gateway start
...

## Workspace Files (injected)
These user-editable files are loaded by OpenClaw and included below in Project Context.

## Silent Replies
When you have nothing to say, respond with ONLY: •

## Heartbeats
If you receive a heartbeat poll..., reply exactly: HEARTBEAT_OK
```

이 내용들은 어떤 설정을 해도 변하지 않고 항상 AI에게 전달됩니다.

---

## 도구 목록이 텍스트로 바뀌는 과정

`exec`, `read` 같은 도구가 어떻게 "- exec: Run shell commands" 라는 텍스트가 되는지 단계별로 설명합니다.

### 전체 흐름

```
[1단계] pi-tools.ts
  createOpenClawCodingTools() 함수 실행
  → exec, read, write, grep ... AgentTool 객체들 생성
  → 각 객체는 { name: "exec", description: "Run shell commands..." } 형태

        ↓

[2단계] tool-summaries.ts
  buildToolSummaryMap(tools) 함수 실행
  → 도구 배열을 { "exec": "Run shell commands...", "read": "Read file contents" ... }
    딕셔너리(key-value 쌍) 로 변환

        ↓

[3단계] pi-embedded-runner/system-prompt.ts
  buildEmbeddedSystemPrompt() 함수에서
  → toolNames  = tools.map(t => t.name)       // ["exec", "read", "write", ...]
  → toolSummaries = buildToolSummaryMap(tools) // {"exec": "Run shell...", ...}
  → buildAgentSystemPrompt({ toolNames, toolSummaries, ... }) 호출

        ↓

[4단계] system-prompt.ts
  buildAgentSystemPrompt() 함수 내부
  → coreToolSummaries 딕셔너리 (코드에 하드코딩된 설명들)
  → toolOrder 배열 (원하는 출력 순서 정의)
  → enabledTools = toolOrder 중 실제로 활성화된 것만 필터링
  → toolLines = enabledTools.map(tool =>
       `- ${tool이름}: ${tool설명}`
     )

        ↓

[5단계] lines 배열에 추가
  "## Tooling",
  "Tool availability (filtered by policy):",
  "- read: Read file contents",
  "- write: Create or overwrite files",
  "- exec: Run shell commands (pty available for TTY-required CLIs)",
  ...

        ↓

[6단계] lines.filter(Boolean).join("\n")
  모든 줄을 합쳐서 하나의 긴 문자열로 만듦
  → 완성된 시스템 프롬프트 텍스트
```

### 코드로 보는 핵심 변환 과정

#### Step 1: 도구 객체 생성 (`pi-tools.ts`)

```typescript
// @mariozechner/pi-coding-agent 라이브러리에서 가져온 도구들
import { codingTools, createExecTool, ... } from "@mariozechner/pi-coding-agent";

// 도구 객체의 구조 (AgentTool 인터페이스)
{
  name: "exec",
  description: "Run shell commands (pty available for TTY-required CLIs)",
  parameters: {   // JSON Schema - AI 모델이 Function Calling에 사용
    type: "object",
    properties: {
      command: { type: "string" },
      ...
    }
  }
}
```

#### Step 2: 딕셔너리로 변환 (`tool-summaries.ts`)

```typescript
export function buildToolSummaryMap(tools: AgentTool[]): Record<string, string> {
  const summaries: Record<string, string> = {};
  for (const tool of tools) {
    // 각 도구의 description(설명)을 꺼내서
    const summary = tool.description?.trim() || tool.label?.trim();
    if (!summary) continue;
    // "exec" → "Run shell commands..." 형태로 딕셔너리에 저장
    summaries[tool.name.toLowerCase()] = summary;
  }
  return summaries;
  // 결과: { "exec": "Run shell commands...", "read": "Read file contents", ... }
}
```

#### Step 3: 텍스트 줄 생성 (`system-prompt.ts`)

```typescript
// 코드에 미리 적혀있는 설명 (coreToolSummaries)
const coreToolSummaries = {
  read:    "Read file contents",
  write:   "Create or overwrite files",
  exec:    "Run shell commands (pty available for TTY-required CLIs)",
  grep:    "Search file contents for patterns",
  // ...
};

// 활성화된 도구만 필터링
const enabledTools = toolOrder.filter(tool => availableTools.has(tool));

// "- exec: Run shell commands..." 형태의 텍스트 줄 생성
const toolLines = enabledTools.map(tool => {
  const summary = coreToolSummaries[tool] ?? externalToolSummaries.get(tool);
  return summary ? `- ${tool}: ${summary}` : `- ${tool}`;
});
```

#### Step 4: 시스템 프롬프트에 합치기

```typescript
const lines = [
  "You are a personal assistant running inside OpenClaw.",
  "",
  "## Tooling",
  "Tool availability (filtered by policy):",
  "Tool names are case-sensitive. Call tools exactly as listed.",
  toolLines.join("\n"),  // ← 여기에 도구 목록 삽입
  "TOOLS.md does not control tool availability...",
  // ... 나머지 섹션들 ...
];

return lines.filter(Boolean).join("\n");  // ← 모든 줄을 합쳐서 하나의 문자열로
```

### 실제 결과물 (AI가 받는 텍스트)

위 과정을 거치면 AI에게 이런 텍스트가 전달됩니다:

```
You are a personal assistant running inside OpenClaw.

## Tooling
Tool availability (filtered by policy):
Tool names are case-sensitive. Call tools exactly as listed.
- read: Read file contents
- write: Create or overwrite files
- edit: Make precise edits to files
- grep: Search file contents for patterns
- find: Find files by glob pattern
- ls: List directory contents
- exec: Run shell commands (pty available for TTY-required CLIs)
- process: Manage background exec sessions
- web_search: Search the web (Brave API)
- cron: Manage cron jobs and wake events
- message: Send messages and channel actions
TOOLS.md does not control tool availability; it is user guidance for how to use external tools.

## Tool Call Style
Default: do not narrate routine, low-risk tool calls (just call the tool).
...
```

### 도구 목록의 두 가지 역할

AI가 도구를 알게 되는 경로는 실제로 **두 가지**가 있습니다:

```
경로 1: 시스템 프롬프트 (텍스트)
  "- exec: Run shell commands..." 라는 텍스트로
  → AI가 어떤 도구가 있는지, 어떤 용도인지 이해

경로 2: Function Calling 스펙 (JSON Schema)
  { name: "exec", parameters: { command: "string", ... } }
  → AI 모델이 실제로 도구를 호출할 때 사용하는 구조 정보
  → 이것은 시스템 프롬프트와 별도로 LLM API에 전달됨

두 경로 모두 코드(pi-tools.ts)에서 생성되며, TOOLS.md와는 무관합니다.
```

*이 문서는 openclaw 소스코드 분석을 기반으로 작성되었습니다.*
