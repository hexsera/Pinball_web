# 핀볼 맵 꾸미기 실행계획

## 요구사항 요약

**요구사항**: 핀볼 게임의 벽(wall) 오브젝트들을 HTML/CSS div 오버레이 방식으로 시각적으로 꾸민다.

**목적**: 현재 단색으로만 표현된 벽들을 CSS의 gradient, border, box-shadow 등을 활용하여 시각적으로 매력적으로 개선한다.

## 현재상태 분석

- Matter.js Canvas 렌더러가 게임 영역(`700px × 1100px`)을 그리고 있음
- 모든 벽은 Matter.js `render.fillStyle: '#16213e'` 단색으로만 표현됨
- 게임 영역 Box가 `position: relative`이고 canvas가 그 안에 있음
- 범퍼는 `afterRender` Canvas API로 네온 효과 적용 중
- CSS div 오버레이는 `position: absolute`로 Canvas 위에 올릴 수 있음

## 구현 방법

게임 영역 Box(`position: relative`) 안에 `position: absolute`인 HTML div를 배치하여 Matter.js 벽 위치에 정확히 겹치도록 한다.
- Matter.js 벽의 좌표/크기를 기준으로 div의 `top`, `left`, `width`, `height`를 계산
- CSS `background`, `border`, `box-shadow`, `transform`으로 시각 효과 적용
- Matter.js 벽은 그대로 표시 유지 — CSS div는 Canvas 아래(z-index 낮게) 배치하여 물리 충돌 경계와 비교 가능

## 구현 단계

### 1. Matter.js 벽 render 유지 (변경 없음)

```javascript
// 기존 코드 그대로 유지
const leftWall = Bodies.rectangle(20, 550, 40, 1100, {
  isStatic: true,
  render: { fillStyle: '#16213e' }
});
```
- **무엇을 하는가**: Matter.js 벽을 그대로 표시하여 CSS div와 물리 충돌 경계를 육안으로 비교 가능하게 유지
- CSS div가 Canvas 아래(z-index 낮게)에 배치되므로 Matter.js 렌더 결과가 위에 표시됨

### 2. WallOverlay 컴포넌트 생성

```jsx
// frontend/src/WallOverlay.jsx
function WallOverlay() {
  return (
    <>
      {/* 왼쪽 벽: x=0~40, y=0~1100 */}
      <div style={{
        position: 'absolute', top: 0, left: 0,
        width: '40px', height: '1100px',
        background: 'linear-gradient(to right, #0a0a1a, #1a1a3e)',
        borderRight: '3px solid #00d4ff',
        boxShadow: 'inset -4px 0 12px rgba(0,212,255,0.3), 4px 0 15px rgba(0,212,255,0.4)'
      }} />
      {/* 오른쪽 벽, 천장, 깔대기 등 동일 패턴 */}
    </>
  );
}
```
- **무엇을 하는가**: 각 벽의 Matter.js 좌표와 동일한 위치/크기의 div를 배치하여 CSS 효과 적용
- `position: absolute`로 Canvas 위에 오버레이
- `linear-gradient`, `boxShadow`, `borderRight`로 네온 사이버펑크 느낌 구현

### 3. 깔대기 경사면 CSS transform 적용

```jsx
{/* 왼쪽 깔대기: 중심 x=105, y=915, 너비 260px, 각도 35도 */}
<div style={{
  position: 'absolute',
  top: '905px', left: '-25px',
  width: '260px', height: '20px',
  background: 'linear-gradient(to right, #1a1a3e, #0f3460)',
  border: '2px solid #e94560',
  boxShadow: '0 0 10px rgba(233,69,96,0.6)',
  transform: 'rotate(35deg)',
  transformOrigin: 'left center'
}} />
```
- **무엇을 하는가**: 경사진 벽을 CSS `rotate`로 표현, Matter.js와 동일한 각도(35도) 적용
- `transformOrigin`을 맞춰 Matter.js 좌표계와 시각적으로 정렬

### 4. Pinball.jsx 게임 영역 Box에 WallOverlay 삽입

```jsx
{/* 게임 영역 (하단 1100px) */}
<Box sx={{
  position: 'relative',
  width: '700px', height: '1100px',
  backgroundImage: 'url(/images/pinball_back.png)',
  backgroundSize: '100% 100%',
}}>
  <WallOverlay />   {/* CSS div 벽 오버레이 추가 */}
  <div ref={sceneRef} />
  {/* 점수, 오버레이 등 기존 코드 */}
</Box>
```
- **무엇을 하는가**: 게임 영역 Box 안에 WallOverlay를 삽입하여 Canvas와 같은 좌표계 공유
- `position: relative` Box 안이므로 absolute 좌표가 게임 영역 기준으로 계산됨

### 5. z-index 계층 정리

```jsx
<WallOverlay zIndex={1} />       {/* Canvas 아래 — Matter.js 벽과 비교 가능 */}
<div ref={sceneRef} style={{ zIndex: 2 }} />   {/* Matter.js Canvas (벽 표시 유지) */}
{/* 점수 표시: zIndex 5 (기존 유지) */}
{/* 게임오버 오버레이: zIndex 10 (기존 유지) */}
```
- **무엇을 하는가**: CSS div 벽을 Canvas 아래에 배치하여 Matter.js 물리 충돌 경계(단색 벽)가 위에 보이도록 계층 설정
- CSS 효과(글로우, 그라디언트)는 Matter.js 벽 뒤에서 번져 나오는 방식으로 표현됨
- 위치가 맞지 않는 경우 Matter.js 벽과 CSS div의 불일치를 즉시 육안으로 확인 가능

## 수정/생성할 파일 목록

| 파일 경로 | 작업 유형 | 변경 내용 |
|-----------|-----------|-----------|
| `frontend/src/WallOverlay.jsx` | 생성 | CSS div 벽 오버레이 컴포넌트 |
| `frontend/src/Pinball.jsx` | 수정 | 벽 Bodies render opacity:0 처리, WallOverlay import 및 삽입 |

## 완료 체크리스트

- [ ] 게임 실행 시 외벽(좌/우/천장)이 CSS gradient와 네온 테두리로 표시된다
- [ ] 깔대기 경사면이 Matter.js 물리 벽 위치와 시각적으로 일치한다
- [ ] 플리퍼, 공, 범퍼 등 기존 물체들이 정상적으로 표시된다
- [ ] 범퍼의 기존 네온 글로우 효과가 그대로 유지된다
- [ ] 물리 충돌(벽 튕김, 깔대기 유도)이 정상 작동한다
- [ ] 게임오버 오버레이가 벽 위에 정상적으로 표시된다
- [ ] 브라우저 콘솔에 에러가 없다
