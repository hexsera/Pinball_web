# 업무일지

## 기본 정보
- 날짜: 2026-01-31 (토) 1:00~1:26 2:02~2:30
- 작성자: hexsera

## 진행 목표
월간 랭킹 엔드포인트 5개(POST, GET 전체, GET 개별, PUT, DELETE)를 메모리 저장소에서 DB로 연결하여 앱 재시작 시 데이터가 초기화되지 않도록 영속성 확보

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| MonthlyScore 모델 import 추가 | backend/main.py | models.py에 모델은 이미 존재 |
| POST 엔드포인트 DB 연결 | backend/main.py | Upsert 로직: 기존 레코드 있으면 최고 점수만 갱신 |
| DELETE 엔드포인트 DB 연결 | backend/main.py | DB에서 레코드 검색 후 삭제, 없으면 404 |
| GET 전체 조회 엔드포인트 DB 연결 | backend/main.py | score 내림차순 정렬, 기존 쿼리 파라미터 제거 |
| GET 개별 조회 엔드포인트 DB 연결 | backend/main.py | user_id로 레코드 검색, 없으면 404 |
| PUT 엔드포인트 DB 연결 | backend/main.py | DB에서 레코드 검색 후 score 수정 |
| 메모리 저장소 제거 | backend/main.py | `monthly_scores: List[dict] = []` 및 주석 삭제 |

## 주요 변경 사항

### 1. backend/main.py 수정

#### import 추가

**변경 전:**
```python
from models import User, Score, Friendship
```

**변경 후:**
```python
from models import User, Score, Friendship, MonthlyScore
```

---

#### 메모리 저장소 제거

**변경 전:**
```python
app = FastAPI(title="Hexsera API", version="1.0.0")

# 월간 점수 메모리 저장소 (임시)
monthly_scores: List[dict] = []


# Pydantic 스키마
```

**변경 후:**
```python
app = FastAPI(title="Hexsera API", version="1.0.0")


# Pydantic 스키마
```

---

#### POST /api/v1/monthly-scores — DB 연결

**변경 전:**
```python
@app.post("/api/v1/monthly-scores", response_model=MonthlyScoreResponse)
def create_or_update_monthly_score(score_data: MonthlyScoreCreateRequest):
    """월간 점수 생성 또는 수정 (최고 점수만 저장)"""
    existing_score = next(
        (s for s in monthly_scores if s["user_id"] == score_data.user_id),
        None
    )

    if existing_score:
        if score_data.score > existing_score["score"]:
            existing_score["score"] = score_data.score
        return existing_score
    else:
        new_score = {
            "user_id": score_data.user_id,
            "score": score_data.score,
            "created_at": datetime.now()
        }
        monthly_scores.append(new_score)
        return new_score
```

**변경 후:**
```python
@app.post("/api/v1/monthly-scores", response_model=MonthlyScoreResponse)
def create_or_update_monthly_score(
    score_data: MonthlyScoreCreateRequest,
    db: Session = Depends(get_db)
):
    """월간 점수 생성 또는 수정 (최고 점수만 저장)"""
    existing_score = db.query(MonthlyScore).filter(
        MonthlyScore.user_id == score_data.user_id
    ).first()

    if existing_score:
        if score_data.score > existing_score.score:
            existing_score.score = score_data.score
            db.commit()
            db.refresh(existing_score)
        return existing_score
    else:
        new_score = MonthlyScore(
            user_id=score_data.user_id,
            score=score_data.score
        )
        db.add(new_score)
        db.commit()
        db.refresh(new_score)
        return new_score
```

**특징:**
- `db.query(MonthlyScore).filter().first()`로 기존 레코드 검색
- 기존 레코드가 있고 새 점수가 더 높으면 score만 UPDATE
- 기존 레코드가 없으면 INSERT
- `created_at`은 모델의 `server_default=func.now()`로 자동 생성

---

#### GET /api/v1/monthly-scores — DB 연결

**변경 전:**
```python
@app.get("/api/v1/monthly-scores", response_model=MonthlyScoreListResponse)
def get_monthly_scores(
    order_by: str = "score",
    order: str = "desc"
):
    """전체 월간 점수 조회 (정렬)"""
    sorted_scores = monthly_scores.copy()

    reverse = (order == "desc")
    if order_by == "score":
        sorted_scores.sort(key=lambda x: x["score"], reverse=reverse)
    elif order_by == "created_at":
        sorted_scores.sort(key=lambda x: x["created_at"], reverse=reverse)
    elif order_by == "user_id":
        sorted_scores.sort(key=lambda x: x["user_id"], reverse=reverse)

    return MonthlyScoreListResponse(
        scores=sorted_scores,
        total=len(sorted_scores)
    )
```

**변경 후:**
```python
@app.get("/api/v1/monthly-scores", response_model=MonthlyScoreListResponse)
def get_monthly_scores(
    db: Session = Depends(get_db)
):
    """전체 월간 점수 조회 (score 내림차순)"""
    scores = db.query(MonthlyScore).order_by(
        MonthlyScore.score.desc()
    ).all()

    return MonthlyScoreListResponse(
        scores=scores,
        total=len(scores)
    )
```

**특징:**
- SQLAlchemy의 `.order_by(MonthlyScore.score.desc())`로 정렬 처리
- 기존 `order_by`, `order` 쿼리 파라미터와 메모리 기반 정렬 로직 제거

---

#### GET /api/v1/monthly-scores/{user_id} — DB 연결

**변경 전:**
```python
@app.get("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreResponse)
def get_monthly_score(user_id: int):
    """특정 사용자 월간 점수 조회"""
    score = next(
        (s for s in monthly_scores if s["user_id"] == user_id),
        None
    )

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    return score
```

**변경 후:**
```python
@app.get("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreResponse)
def get_monthly_score(
    user_id: int,
    db: Session = Depends(get_db)
):
    """특정 사용자 월간 점수 조회"""
    score = db.query(MonthlyScore).filter(
        MonthlyScore.user_id == user_id
    ).first()

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    return score
```

**특징:**
- `db.query(MonthlyScore).filter().first()`로 user_id 기준 조회
- 레코드가 없으면 404 반환

---

#### PUT /api/v1/monthly-scores/{user_id} — DB 연결

**변경 전:**
```python
@app.put("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreResponse)
def update_monthly_score(user_id: int, score_data: MonthlyScoreUpdateRequest):
    """특정 사용자 월간 점수 수정"""
    score = next(
        (s for s in monthly_scores if s["user_id"] == user_id),
        None
    )

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    score["score"] = score_data.score
    return score
```

**변경 후:**
```python
@app.put("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreResponse)
def update_monthly_score(
    user_id: int,
    score_data: MonthlyScoreUpdateRequest,
    db: Session = Depends(get_db)
):
    """특정 사용자 월간 점수 수정"""
    score = db.query(MonthlyScore).filter(
        MonthlyScore.user_id == user_id
    ).first()

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    score.score = score_data.score
    db.commit()
    db.refresh(score)
    return score
```

**특징:**
- DB에서 레코드를 검색한 후 score를 직접 수정
- `db.commit()` + `db.refresh()`로 변경사항 반영
- 레코드가 없으면 404 반환

---

#### DELETE /api/v1/monthly-scores/{user_id} — DB 연결

**변경 전:**
```python
@app.delete("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreDeleteResponse)
def delete_monthly_score(user_id: int):
    """특정 사용자 월간 점수 삭제"""
    global monthly_scores

    score = next(
        (s for s in monthly_scores if s["user_id"] == user_id),
        None
    )

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    monthly_scores = [s for s in monthly_scores if s["user_id"] != user_id]

    return MonthlyScoreDeleteResponse(
        message="Monthly score deleted successfully",
        deleted_user_id=user_id
    )
```

**변경 후:**
```python
@app.delete("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreDeleteResponse)
def delete_monthly_score(
    user_id: int,
    db: Session = Depends(get_db)
):
    """특정 사용자 월간 점수 삭제"""
    score = db.query(MonthlyScore).filter(
        MonthlyScore.user_id == user_id
    ).first()

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    db.delete(score)
    db.commit()

    return MonthlyScoreDeleteResponse(
        message="Monthly score deleted successfully",
        deleted_user_id=user_id
    )
```

**특징:**
- `global monthly_scores`와 리스트 필터링 제거
- `db.delete()` + `db.commit()`으로 DB에서 직접 삭제
- 레코드가 없으면 404 반환

---

### 변경된 데이터 흐름

**변경 전 (메모리 저장소):**
```
Request → monthly_scores (List[dict]) → Response
                    │
                    ▼
          앱 재시작 시 초기화됨
```

**변경 후 (DB 연결):**
```
Request → db.query(MonthlyScore) → MySQL (monthly_scores 테이블) → Response
                                           │
                                           ▼
                                  앱 재시작 후도 데이터 유지
```

## 결과
- 상태: 완료
- PHASE 1 (POST, DELETE → DB 연결): 완료
- PHASE 2 (GET 전체, GET 개별, PUT → DB 연결 + 메모리 저장소 제거): 완료

## 배운내용
SQLAlchemy 의 refresh

## 다음 작업
- id 필드 제거 및 nickname 필드 추가
