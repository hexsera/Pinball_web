# 업무일지

## 기본 정보
- 날짜: 2026-01-31 (토) 1:00~1:26 2:02~2:30
- 작성자: hexsera

## 진행 목표
월간 랭킹 엔드포인트 5개(POST, GET 전체, GET 개별, PUT, DELETE)를 메모리 저장소에서 DB로 연결하여 앱 재시작 시 데이터가 초기화되지 않도록 영속성 확보

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| MonthlyScore 모델 import 추가 | backend/main.py | models.py에 모델은 이미 존재 |
| POST 엔드포인트 DB 연결 | backend/main.py | Upsert 로직: 기존 레코드 있으면 최고 점수만 갱신 |
| DELETE 엔드포인트 DB 연결 | backend/main.py | DB에서 레코드 검색 후 삭제, 없으면 404 |
| GET 전체 조회 엔드포인트 DB 연결 | backend/main.py | score 내림차순 정렬, 기존 쿼리 파라미터 제거 |
| GET 개별 조회 엔드포인트 DB 연결 | backend/main.py | user_id로 레코드 검색, 없으면 404 |
| PUT 엔드포인트 DB 연결 | backend/main.py | DB에서 레코드 검색 후 score 수정 |
| 메모리 저장소 제거 | backend/main.py | `monthly_scores: List[dict] = []` 및 주석 삭제 |

## 주요 변경 사항

### 1. backend/main.py 수정

#### import 추가

**변경 전:**
```python
from models import User, Score, Friendship
```

**변경 후:**
```python
from models import User, Score, Friendship, MonthlyScore
```

---

#### 메모리 저장소 제거

**변경 전:**
```python
app = FastAPI(title="Hexsera API", version="1.0.0")

# 월간 점수 메모리 저장소 (임시)
monthly_scores: List[dict] = []


# Pydantic 스키마
```

**변경 후:**
```python
app = FastAPI(title="Hexsera API", version="1.0.0")


# Pydantic 스키마
```

---

#### POST /api/v1/monthly-scores — DB 연결

**변경 전:**
```python
@app.post("/api/v1/monthly-scores", response_model=MonthlyScoreResponse)
def create_or_update_monthly_score(score_data: MonthlyScoreCreateRequest):
    """월간 점수 생성 또는 수정 (최고 점수만 저장)"""
    existing_score = next(
        (s for s in monthly_scores if s["user_id"] == score_data.user_id),
        None
    )

    if existing_score:
        if score_data.score > existing_score["score"]:
            existing_score["score"] = score_data.score
        return existing_score
    else:
        new_score = {
            "user_id": score_data.user_id,
            "score": score_data.score,
            "created_at": datetime.now()
        }
        monthly_scores.append(new_score)
        return new_score
```

**변경 후:**
```python
@app.post("/api/v1/monthly-scores", response_model=MonthlyScoreResponse)
def create_or_update_monthly_score(
    score_data: MonthlyScoreCreateRequest,
    db: Session = Depends(get_db)
):
    """월간 점수 생성 또는 수정 (최고 점수만 저장)"""
    existing_score = db.query(MonthlyScore).filter(
        MonthlyScore.user_id == score_data.user_id
    ).first()

    if existing_score:
        if score_data.score > existing_score.score:
            existing_score.score = score_data.score
            db.commit()
            db.refresh(existing_score)
        return existing_score
    else:
        new_score = MonthlyScore(
            user_id=score_data.user_id,
            score=score_data.score
        )
        db.add(new_score)
        db.commit()
        db.refresh(new_score)
        return new_score
```

**특징:**
- `db.query(MonthlyScore).filter().first()`로 기존 레코드 검색
- 기존 레코드가 있고 새 점수가 더 높으면 score만 UPDATE
- 기존 레코드가 없으면 INSERT
- `created_at`은 모델의 `server_default=func.now()`로 자동 생성

---

#### GET /api/v1/monthly-scores — DB 연결

**변경 전:**
```python
@app.get("/api/v1/monthly-scores", response_model=MonthlyScoreListResponse)
def get_monthly_scores(
    order_by: str = "score",
    order: str = "desc"
):
    """전체 월간 점수 조회 (정렬)"""
    sorted_scores = monthly_scores.copy()

    reverse = (order == "desc")
    if order_by == "score":
        sorted_scores.sort(key=lambda x: x["score"], reverse=reverse)
    elif order_by == "created_at":
        sorted_scores.sort(key=lambda x: x["created_at"], reverse=reverse)
    elif order_by == "user_id":
        sorted_scores.sort(key=lambda x: x["user_id"], reverse=reverse)

    return MonthlyScoreListResponse(
        scores=sorted_scores,
        total=len(sorted_scores)
    )
```

**변경 후:**
```python
@app.get("/api/v1/monthly-scores", response_model=MonthlyScoreListResponse)
def get_monthly_scores(
    db: Session = Depends(get_db)
):
    """전체 월간 점수 조회 (score 내림차순)"""
    scores = db.query(MonthlyScore).order_by(
        MonthlyScore.score.desc()
    ).all()

    return MonthlyScoreListResponse(
        scores=scores,
        total=len(scores)
    )
```

**특징:**
- SQLAlchemy의 `.order_by(MonthlyScore.score.desc())`로 정렬 처리
- 기존 `order_by`, `order` 쿼리 파라미터와 메모리 기반 정렬 로직 제거

---

#### GET /api/v1/monthly-scores/{user_id} — DB 연결

**변경 전:**
```python
@app.get("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreResponse)
def get_monthly_score(user_id: int):
    """특정 사용자 월간 점수 조회"""
    score = next(
        (s for s in monthly_scores if s["user_id"] == user_id),
        None
    )

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    return score
```

**변경 후:**
```python
@app.get("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreResponse)
def get_monthly_score(
    user_id: int,
    db: Session = Depends(get_db)
):
    """특정 사용자 월간 점수 조회"""
    score = db.query(MonthlyScore).filter(
        MonthlyScore.user_id == user_id
    ).first()

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    return score
```

**특징:**
- `db.query(MonthlyScore).filter().first()`로 user_id 기준 조회
- 레코드가 없으면 404 반환

---

#### PUT /api/v1/monthly-scores/{user_id} — DB 연결

**변경 전:**
```python
@app.put("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreResponse)
def update_monthly_score(user_id: int, score_data: MonthlyScoreUpdateRequest):
    """특정 사용자 월간 점수 수정"""
    score = next(
        (s for s in monthly_scores if s["user_id"] == user_id),
        None
    )

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    score["score"] = score_data.score
    return score
```

**변경 후:**
```python
@app.put("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreResponse)
def update_monthly_score(
    user_id: int,
    score_data: MonthlyScoreUpdateRequest,
    db: Session = Depends(get_db)
):
    """특정 사용자 월간 점수 수정"""
    score = db.query(MonthlyScore).filter(
        MonthlyScore.user_id == user_id
    ).first()

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    score.score = score_data.score
    db.commit()
    db.refresh(score)
    return score
```

**특징:**
- DB에서 레코드를 검색한 후 score를 직접 수정
- `db.commit()` + `db.refresh()`로 변경사항 반영
- 레코드가 없으면 404 반환

---

#### DELETE /api/v1/monthly-scores/{user_id} — DB 연결

**변경 전:**
```python
@app.delete("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreDeleteResponse)
def delete_monthly_score(user_id: int):
    """특정 사용자 월간 점수 삭제"""
    global monthly_scores

    score = next(
        (s for s in monthly_scores if s["user_id"] == user_id),
        None
    )

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    monthly_scores = [s for s in monthly_scores if s["user_id"] != user_id]

    return MonthlyScoreDeleteResponse(
        message="Monthly score deleted successfully",
        deleted_user_id=user_id
    )
```

**변경 후:**
```python
@app.delete("/api/v1/monthly-scores/{user_id}", response_model=MonthlyScoreDeleteResponse)
def delete_monthly_score(
    user_id: int,
    db: Session = Depends(get_db)
):
    """특정 사용자 월간 점수 삭제"""
    score = db.query(MonthlyScore).filter(
        MonthlyScore.user_id == user_id
    ).first()

    if score is None:
        raise HTTPException(
            status_code=404,
            detail=f"Monthly score for user {user_id} not found"
        )

    db.delete(score)
    db.commit()

    return MonthlyScoreDeleteResponse(
        message="Monthly score deleted successfully",
        deleted_user_id=user_id
    )
```

**특징:**
- `global monthly_scores`와 리스트 필터링 제거
- `db.delete()` + `db.commit()`으로 DB에서 직접 삭제
- 레코드가 없으면 404 반환

---

### 변경된 데이터 흐름

**변경 전 (메모리 저장소):**
```
Request → monthly_scores (List[dict]) → Response
                    │
                    ▼
          앱 재시작 시 초기화됨
```

**변경 후 (DB 연결):**
```
Request → db.query(MonthlyScore) → MySQL (monthly_scores 테이블) → Response
                                           │
                                           ▼
                                  앱 재시작 후도 데이터 유지
```

## 결과
- 상태: 완료
- PHASE 1 (POST, DELETE → DB 연결): 완료
- PHASE 2 (GET 전체, GET 개별, PUT → DB 연결 + 메모리 저장소 제거): 완료

## 배운내용
SQLAlchemy 의 refresh

## 다음 작업
- id 필드 제거 및 nickname 필드 추가

---

# 업무일지

## 기본 정보
- 날짜: 2026-01-31 (토) 16:20~17:20
- 작성자: hexsera

## 진행 목표
GET /api/friend-requests 엔드포인트를 단일 방향(receiver만) + pending 하드코딩에서, 양방향 검색과 status 필터로 확장하여 친구 관계 전체를 조회할 수 있게 수정

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| or_ 임포트 추가 | backend/main.py | SQLAlchemy OR 조건 생성용 |
| FriendRequestData 스키마에 receiver_id 추가 | backend/main.py | 양방향 조회 시 상대방 식별용 |
| GET 엔드포인트 양방향 검색 수정 | backend/main.py | or_()로 requester_id/receiver_id 모두 검색 |
| GET 엔드포인트 friend_status 파라미터 추가 | backend/main.py | 기본값 pending, all 전달 시 전체 반환 |
| 유효하지 않은 status 값 검증 추가 | backend/main.py | 400 Bad Request 반환 |

## 주요 변경 사항

### 1. backend/main.py 수정

#### import 추가

**변경 전:**
```python
from sqlalchemy.orm import Session
```

**변경 후:**
```python
from sqlalchemy.orm import Session
from sqlalchemy import or_
```

---

#### FriendRequestData 스키마에 receiver_id 추가

**변경 전:**
```python
class FriendRequestData(BaseModel):
    """친구 요청 데이터 (조회용)"""
    id: int
    requester_id: int
    status: str
```

**변경 후:**
```python
class FriendRequestData(BaseModel):
    """친구 요청 데이터 (조회용)"""
    id: int
    requester_id: int
    receiver_id: int
    status: str
```

**특징:**
- `receiver_id` 추가로 클라이언트에서 요청자와 수신자를 모두 확인할 수 있음
- user_id가 requester_id일 때 상대방(receiver)을 식별할 수 있게 됨

---

#### GET /api/friend-requests 엔드포인트 수정

**변경 전:**
```python
@app.get("/api/friend-requests", response_model=FriendRequestListResponse)
def get_friend_requests(user_id: int, db: Session = Depends(get_db)):
    """특정 사용자가 받은 친구 요청 조회 (DB 연동)"""
    requests = db.query(Friendship).filter(
        Friendship.receiver_id == user_id,
        Friendship.status == "pending"
    ).all()

    request_data = [
        FriendRequestData(
            id=req.id,
            requester_id=req.requester_id,
            status=req.status
        )
        for req in requests
    ]

    return FriendRequestListResponse(requests=request_data)
```

**변경 후:**
```python
VALID_FRIEND_STATUSES = {"pending", "accepted", "rejected", "all"}

@app.get("/api/friend-requests", response_model=FriendRequestListResponse)
def get_friend_requests(user_id: int, friend_status: str = "pending", db: Session = Depends(get_db)):
    """특정 사용자의 친구 요청 조회 (양방향, status 필터)"""
    if friend_status not in VALID_FRIEND_STATUSES:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid status. Allowed values: {sorted(VALID_FRIEND_STATUSES)}"
        )

    direction_filter = or_(
        Friendship.requester_id == user_id,
        Friendship.receiver_id == user_id
    )

    if friend_status == "all":
        query = db.query(Friendship).filter(direction_filter)
    else:
        query = db.query(Friendship).filter(
            direction_filter,
            Friendship.status == friend_status
        )

    requests = query.all()

    request_data = [
        FriendRequestData(
            id=req.id,
            requester_id=req.requester_id,
            receiver_id=req.receiver_id,
            status=req.status
        )
        for req in requests
    ]

    return FriendRequestListResponse(requests=request_data)
```

**특징:**
- `or_()`: requester_id == user_id OR receiver_id == user_id로 양방향 검색
- `friend_status` 기본값이 `"pending"`이므로 기존 호출 방식과 동일하게 동작 (하위 호환성 유지)
- 파라미터 이름을 `friend_status`로 사용하여 FastAPI의 `status` 모듈과 충돌 회피
- `"all"` 전달 시 status 필터를 조건에 추가하지 않아 모든 상태의 레코드 반환

### 변경된 조회 흐름

**변경 전:**
```
GET ?user_id=1
        │
        ▼
  receiver_id == 1
  AND status == "pending"   ← 하드코딩
        │
        ▼
  단일 방향 결과 반환
```

**변경 후:**
```
GET ?user_id=1&friend_status=all
        │
        ▼
  requester_id == 1
  OR receiver_id == 1       ← 양방향 검색
        │
        ▼
  friend_status == "all"?
  ├── Yes → status 필터 미적용
  └── No  → status == friend_status 필터 적용
        │
        ▼
  양방향 + 필터 결과 반환
```

## 결과
- 상태: 완료

## 배운내용

## 다음 작업
- 프론트엔드 친구 관계 조회 화면 연동
