# 업무일지

## 기본 정보
- 날짜: 2026-02-04 (화) 9:08~9:31 11:10~12:00
- 작성자: hexsera

## 진행 목표
FastAPI에 게임 일일 접속자 수 집계를 위한 PUT/POST 엔드포인트를 구현한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| GameVisit 모델 생성 | backend/models.py | user_id, ip_address, is_visits 필드 추가 |
| PUT 엔드포인트용 스키마 생성 | backend/main.py | GameVisitUpdateRequest, GameVisitUpdateResponse |
| PUT /api/v1/game_visits 구현 | backend/main.py | IP 기반 접속 기록 업데이트 |
| POST 엔드포인트용 스키마 생성 | backend/main.py | GameVisitCreateRequest, GameVisitCreateResponse |
| get_client_ip 함수 구현 | backend/main.py | 프록시 환경 고려한 IP 추출 |
| POST /api/v1/game_visits 구현 | backend/main.py | 오늘 날짜 + IP 기준 중복 방지 로직 |
| Request, and_ import 추가 | backend/main.py | FastAPI Request, SQLAlchemy and_ |

## 주요 변경 사항

### 1. backend/models.py 수정

**추가: GameVisit 모델**
```python
from sqlalchemy import Column, Integer, String, Date, DateTime, Boolean, UniqueConstraint, CheckConstraint

class GameVisit(Base):
    __tablename__ = "game_visits"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=True, index=True)
    ip_address = Column(String(45), nullable=False, index=True)
    is_visits = Column(Boolean, nullable=False, default=False)
    created_at = Column(DateTime, nullable=False, server_default=func.now(), index=True)
    updated_at = Column(DateTime, nullable=False, server_default=func.now(), onupdate=func.now())
```

**특징:**
- user_id는 nullable로 설정하여 비회원 접속도 기록 가능
- ip_address는 String(45)로 IPv6 지원 (IPv4: 15자, IPv6: 45자)
- is_visits는 방문 여부를 나타내는 boolean 필드
- created_at과 updated_at으로 생성/수정 시각 자동 기록
- 모든 조회 필드에 인덱스 추가 (성능 최적화)

### 2. backend/main.py - Import 수정

**변경 전:**
```python
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy import or_
from models import User, Score, Friendship, MonthlyScore
```

**변경 후:**
```python
from fastapi import FastAPI, Depends, HTTPException, status, Request
from sqlalchemy import or_, and_
from models import User, Score, Friendship, MonthlyScore, GameVisit
```

**특징:**
- Request: HTTP 요청 정보(헤더, IP 등)에 접근하기 위해 추가
- and_: 여러 조건을 AND로 결합하기 위해 추가
- GameVisit: 새로 생성한 모델 import

### 3. backend/main.py - Helper 함수 추가

**추가: get_client_ip 함수**
```python
def get_client_ip(request: Request) -> str:
    """클라이언트 IP 주소 추출 (프록시 고려)"""
    # X-Forwarded-For 헤더 확인 (프록시/로드밸런서 뒤에 있는 경우)
    forwarded_for = request.headers.get("X-Forwarded-For")
    if forwarded_for:
        # 첫 번째 IP가 실제 클라이언트 IP
        return forwarded_for.split(",")[0].strip()

    # X-Real-IP 헤더 확인 (Nginx 등에서 사용)
    real_ip = request.headers.get("X-Real-IP")
    if real_ip:
        return real_ip

    # 직접 연결된 클라이언트 IP
    return request.client.host
```

**특징:**
- 프록시/로드밸런서 환경을 고려한 IP 추출
- X-Forwarded-For 헤더 우선 확인 (프록시 체인의 첫 번째 IP)
- X-Real-IP 헤더 차순위 확인 (Nginx 등)
- 직접 연결 시 request.client.host 사용

### 4. backend/main.py - Pydantic 스키마 추가

**추가: PUT 엔드포인트용 스키마**
```python
class GameVisitUpdateRequest(BaseModel):
    """게임 접속 기록 수정 요청"""
    user_id: Optional[int] = None
    ip_address: str

class GameVisitUpdateResponse(BaseModel):
    """게임 접속 기록 수정 응답"""
    message: str
    user_id: Optional[int]
    ip_address: str
    is_visits: bool
    updated_at: datetime
```

**추가: POST 엔드포인트용 스키마**
```python
class GameVisitCreateRequest(BaseModel):
    """게임 접속 기록 생성 요청"""
    user_id: Optional[int] = None

class GameVisitCreateResponse(BaseModel):
    """게임 접속 기록 생성 응답"""
    message: str
    user_id: Optional[int]
    ip_address: str
    created_at: datetime
    is_new_record: bool
```

**특징:**
- PUT용: ip_address를 요청에서 받음 (테스트/관리 목적)
- POST용: ip_address는 서버에서 자동 추출 (실제 사용)
- is_new_record: 새 레코드 생성 여부를 응답에 포함

### 5. backend/main.py - POST 엔드포인트 구현

**추가: POST /api/v1/game_visits**
```python
@app.post("/api/v1/game_visits", response_model=GameVisitCreateResponse, status_code=201)
def create_game_visit(
    visit_data: GameVisitCreateRequest,
    request: Request,
    db: Session = Depends(get_db)
):
    """게임 접속 기록 생성 (오늘 날짜 + IP 기준 중복 방지)"""
    from sqlalchemy import func

    # 클라이언트 IP 추출
    client_ip = get_client_ip(request)

    # 오늘 날짜와 IP로 레코드 조회
    today = func.date(func.now())
    existing_visit = db.query(GameVisit).filter(
        and_(
            func.date(GameVisit.created_at) == today,
            GameVisit.ip_address == client_ip
        )
    ).first()

    if existing_visit:
        # 레코드가 존재하면 user_id가 null인 경우에만 업데이트
        if existing_visit.user_id is None and visit_data.user_id is not None:
            existing_visit.user_id = visit_data.user_id
            db.commit()
            db.refresh(existing_visit)

        return GameVisitCreateResponse(
            message="Game visit record updated",
            user_id=existing_visit.user_id,
            ip_address=existing_visit.ip_address,
            created_at=existing_visit.created_at,
            is_new_record=False
        )
    else:
        # 레코드가 없으면 새로 생성
        new_visit = GameVisit(
            user_id=visit_data.user_id,
            ip_address=client_ip,
            is_visits=True
        )
        db.add(new_visit)
        db.commit()
        db.refresh(new_visit)

        return GameVisitCreateResponse(
            message="Game visit record created",
            user_id=new_visit.user_id,
            ip_address=new_visit.ip_address,
            created_at=new_visit.created_at,
            is_new_record=True
        )
```

**특징:**
- func.date()로 시간을 제외한 날짜만 비교 (오늘 접속 기록 조회)
- 오늘 같은 IP 접속이 있으면: user_id가 null이고 요청의 user_id가 null이 아닐 때만 업데이트
- 오늘 같은 IP 접속이 없으면: 새 레코드 생성 (is_visits=True)
- is_new_record로 생성/업데이트 구분
- 201 Created 상태 코드 반환

### 6. backend/main.py - PUT 엔드포인트 구현

**추가: PUT /api/v1/game_visits**
```python
@app.put("/api/v1/game_visits", response_model=GameVisitUpdateResponse)
def update_game_visit(
    visit_data: GameVisitUpdateRequest,
    db: Session = Depends(get_db)
):
    """IP 주소 기반 게임 접속 기록 업데이트 (is_visits = True)"""
    # IP 주소로 레코드 조회
    game_visit = db.query(GameVisit).filter(
        GameVisit.ip_address == visit_data.ip_address
    ).first()

    if game_visit is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Game visit record for IP {visit_data.ip_address} not found"
        )

    # user_id와 is_visits 필드 업데이트
    if visit_data.user_id is not None:
        game_visit.user_id = visit_data.user_id
    game_visit.is_visits = True
    db.commit()
    db.refresh(game_visit)

    return GameVisitUpdateResponse(
        message="Game visit updated successfully",
        user_id=game_visit.user_id,
        ip_address=game_visit.ip_address,
        is_visits=game_visit.is_visits,
        updated_at=game_visit.updated_at
    )
```

**특징:**
- IP 주소로 레코드 조회 (날짜 필터링 없음)
- 레코드가 없으면 404 에러 반환
- user_id가 제공되면 함께 업데이트
- is_visits를 True로 설정
- updated_at은 onupdate=func.now()에 의해 자동 갱신

## 아키텍처 구조

### API 엔드포인트 구조
```
Game Visit API
├── POST /api/v1/game_visits (실제 사용)
│   ├── Request: user_id (Optional)
│   ├── IP 자동 추출: get_client_ip()
│   ├── 오늘 날짜 + IP 조회
│   │   ├── 존재 O → user_id null일 때만 업데이트
│   │   └── 존재 X → 새 레코드 생성
│   └── Response: message, user_id, ip_address, created_at, is_new_record
│
└── PUT /api/v1/game_visits (테스트/관리용)
    ├── Request: user_id, ip_address
    ├── IP로 레코드 조회
    │   ├── 존재 O → user_id, is_visits 업데이트
    │   └── 존재 X → 404 에러
    └── Response: message, user_id, ip_address, is_visits, updated_at
```

### 데이터 흐름
```
Client Request
     │
     ▼
FastAPI Endpoint (POST /api/v1/game_visits)
     │
     ├─→ get_client_ip() → Extract IP from Headers
     │                      (X-Forwarded-For → X-Real-IP → client.host)
     │
     ├─→ Query DB (today + IP)
     │        │
     │        ├─→ Record exists?
     │        │        ├─→ Yes: user_id null? → Update user_id
     │        │        └─→ No: Create new record
     │        │
     ▼        ▼
    DB: game_visits
        ├── id (PK)
        ├── user_id (nullable, indexed)
        ├── ip_address (indexed)
        ├── is_visits (bool)
        ├── created_at (indexed)
        └── updated_at
```

### 비회원 → 회원 전환 시나리오
```
Step 1: 비회원 접속
    POST /api/v1/game_visits { user_id: null }
    → IP: 192.168.1.100 추출
    → DB 저장: { user_id: null, ip: 192.168.1.100, is_visits: true }

Step 2: 동일 IP에서 회원 로그인
    POST /api/v1/game_visits { user_id: 123 }
    → IP: 192.168.1.100 추출
    → 오늘 레코드 조회 (IP 일치)
    → user_id가 null이고 요청의 user_id가 123
    → DB 업데이트: { user_id: 123, ip: 192.168.1.100, is_visits: true }

Step 3: 동일 IP에서 재접속
    POST /api/v1/game_visits { user_id: 456 }
    → IP: 192.168.1.100 추출
    → 오늘 레코드 조회 (IP 일치)
    → user_id가 123 (not null)
    → 업데이트 하지 않음 (기존 레코드 반환)
```

## 결과
- 상태: 완료
- 완벽한 테스트 못함 (여러 ip, 여러 날짜에서 테스트 못함)
- 학습 못함

## 배운내용
정교하게 설계하려 할 수록 시간이 많이걸린다.
ip 로 사용자를 구분하는것은 한계가 있다.

## 다음 작업
- 프론트엔드에서 게임 접속 시 POST /api/v1/game_visits 호출 구현

---

# 업무일지 (2차)

## 기본 정보
- 날짜: 2026-02-04 (화) 13:00~14:00
- 작성자: hexsera

## 진행 목표
FastAPI에 게임 일일 접속자 수 집계를 위한 GET 엔드포인트를 구현하고, 테스트용 Mock 데이터 생성 스크립트를 작성한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| DailyVisitStats 스키마 추가 | backend/main.py | 일별 통계 응답 스키마 |
| DailyVisitStatsResponse 스키마 추가 | backend/main.py | 통계 목록 응답 스키마 |
| GET /api/v1/game_visits/ 구현 | backend/main.py | 날짜별 접속자 수 집계 |
| Mock 데이터 생성 스크립트 작성 | backend/create_mock_visits.py | 테스트용 데이터 생성 |

## 주요 변경 사항

### 1. backend/main.py 수정 - Pydantic 스키마 추가

**추가: 일별 접속자 수 통계 스키마**
```python
class DailyVisitStats(BaseModel):
    """일별 접속자 수 통계"""
    date: str  # YYYY-MM-DD 형식
    user_count: int


class DailyVisitStatsResponse(BaseModel):
    """일별 접속자 수 통계 응답"""
    stats: List[DailyVisitStats]
    total_days: int
    start_date: str
    end_date: str
```

**특징:**
- `DailyVisitStats`: 하루 단위 접속자 수를 담는 스키마
- `date`: YYYY-MM-DD 문자열 형식으로 반환 (프론트엔드 파싱 용이)
- `DailyVisitStatsResponse`: 통계 배열 + 메타 정보 (총 일수, 기간)
- 프론트엔드에서 차트/그래프로 시각화하기 적합한 구조

### 2. backend/main.py 수정 - GET 엔드포인트 구현

**추가: GET /api/v1/game_visits/**
```python
@app.get("/api/v1/game_visits/", response_model=DailyVisitStatsResponse)
def get_daily_visit_stats(
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """게임 일일 접속자 수 조회 (날짜 범위 필터)"""
    from datetime import timedelta
    from sqlalchemy import func

    # 기본값 설정: 최근 7일
    if not end_date:
        end_date_obj = date.today()
    else:
        end_date_obj = date.fromisoformat(end_date)

    if not start_date:
        start_date_obj = end_date_obj - timedelta(days=6)
    else:
        start_date_obj = date.fromisoformat(start_date)

    # 날짜별 접속자 수 집계 (POST에서 이미 일별 IP 중복 방지)
    stats = db.query(
        func.date(GameVisit.created_at).label('visit_date'),
        func.count(GameVisit.id).label('user_count')
    ).filter(
        func.date(GameVisit.created_at) >= start_date_obj,
        func.date(GameVisit.created_at) <= end_date_obj
    ).group_by(
        func.date(GameVisit.created_at)
    ).order_by(
        func.date(GameVisit.created_at)
    ).all()

    # 응답 형식으로 변환
    result = [
        DailyVisitStats(
            date=str(stat.visit_date),
            user_count=stat.user_count
        )
        for stat in stats
    ]

    return DailyVisitStatsResponse(
        stats=result,
        total_days=len(result),
        start_date=str(start_date_obj),
        end_date=str(end_date_obj)
    )
```

**특징:**
- 쿼리 파라미터: `start_date`, `end_date` (선택 사항)
- 기본값: 최근 7일 (end_date: 오늘, start_date: 7일 전)
- `func.date()`: created_at에서 날짜 부분만 추출하여 그룹화
- `func.count(GameVisit.id)`: 레코드 수 집계 (DISTINCT 불필요, POST에서 이미 중복 방지)
- `group_by()`: 날짜별로 그룹화하여 집계
- `order_by()`: 날짜 오름차순 정렬 (시계열 데이터)

### 3. backend/create_mock_visits.py 생성

**추가: Mock 데이터 생성 스크립트**
```python
import random
from datetime import datetime, timedelta
from database import SessionLocal
from models import GameVisit

def create_mock_game_visits(days: int = 30):
    """게임 접속 기록 Mock 데이터 생성"""
    db = SessionLocal()
    try:
        today = datetime.now()

        for day_offset in range(days):
            visit_date = today - timedelta(days=day_offset)
            # 하루에 랜덤하게 5~20명 접속
            num_visits = random.randint(5, 20)

            for i in range(num_visits):
                # 랜덤 IP 생성
                ip = f"192.168.{random.randint(1, 255)}.{random.randint(1, 255)}"
                # 50% 확률로 user_id 할당
                user_id = random.randint(1, 10) if random.random() > 0.5 else None

                # 랜덤 시간 설정 (0~23시)
                visit_time = visit_date.replace(
                    hour=random.randint(0, 23),
                    minute=random.randint(0, 59),
                    second=random.randint(0, 59)
                )

                visit = GameVisit(
                    user_id=user_id,
                    ip_address=ip,
                    is_visits=True,
                    created_at=visit_time
                )
                db.add(visit)

        db.commit()
        print(f"Mock data created: {days}일 동안 접속 기록 생성 완료")
    except Exception as e:
        db.rollback()
        print(f"Error creating mock data: {e}")
    finally:
        db.close()

if __name__ == "__main__":
    create_mock_game_visits(30)
```

**특징:**
- 최근 30일 동안 Mock 데이터 생성
- 하루 5~20명의 랜덤 접속자 (일별 변동성 시뮬레이션)
- 랜덤 IP 생성 (192.168.x.x 사설 IP 대역)
- 50% 확률로 user_id 할당 (회원/비회원 접속 구분)
- 랜덤 시간대 생성 (하루 24시간 분산)
- Docker 컨테이너 내부에서 실행: `docker exec fastapi-server python /code/create_mock_visits.py`

## 아키텍처 구조

### GET API 데이터 흐름
```
Client Request (GET /api/v1/game_visits/?start_date=2026-02-01&end_date=2026-02-07)
     │
     ▼
FastAPI Endpoint
     │
     ├─→ 쿼리 파라미터 파싱
     │   ├─→ start_date 있음? → date.fromisoformat()
     │   │                   → 없음? → 오늘 - 6일
     │   └─→ end_date 있음? → date.fromisoformat()
     │                     → 없음? → 오늘
     │
     ├─→ SQLAlchemy 쿼리 실행
     │   ├─→ SELECT DATE(created_at), COUNT(id)
     │   ├─→ FROM game_visits
     │   ├─→ WHERE DATE(created_at) BETWEEN start_date AND end_date
     │   ├─→ GROUP BY DATE(created_at)
     │   └─→ ORDER BY DATE(created_at) ASC
     │
     ├─→ 결과 변환
     │   └─→ List[DailyVisitStats]
     │
     ▼
Response: DailyVisitStatsResponse
{
  "stats": [
    {"date": "2026-02-01", "user_count": 15},
    {"date": "2026-02-02", "user_count": 20},
    {"date": "2026-02-03", "user_count": 8}
  ],
  "total_days": 3,
  "start_date": "2026-02-01",
  "end_date": "2026-02-03"
}
```

### 날짜별 집계 원리
```
game_visits 테이블 원본 데이터:
┌────┬─────────┬─────────────┬────────────────────┐
│ id │ user_id │ ip_address  │ created_at         │
├────┼─────────┼─────────────┼────────────────────┤
│  1 │    5    │ 192.168.1.1 │ 2026-02-01 10:30:00│
│  2 │   null  │ 192.168.1.2 │ 2026-02-01 14:20:00│
│  3 │    3    │ 192.168.1.3 │ 2026-02-02 09:15:00│
│  4 │    7    │ 192.168.1.4 │ 2026-02-02 15:45:00│
│  5 │   null  │ 192.168.1.5 │ 2026-02-02 18:00:00│
└────┴─────────┴─────────────┴────────────────────┘
                    │
                    ▼ GROUP BY DATE(created_at)
                    ▼ COUNT(id)
┌──────────────┬────────────┐
│ visit_date   │ user_count │
├──────────────┼────────────┤
│ 2026-02-01   │     2      │
│ 2026-02-02   │     3      │
└──────────────┴────────────┘
```

## 결과
- 상태: 완료
- 학습 못함

## 배운내용
ai 가 리스폰스 막 만드는거 같기도하고... 초보랑 고수가 만드는 방식이 달라서 그런가?

## 다음 작업
- fastapi Mock 데이터 삭제
- 프론트 mock 데이터 제거

---

# 업무일지 (3차)

## 기본 정보
- 날짜: 2026-02-04 (화) 15:08~15:55
- 작성자: hexsera

## 진행 목표
FastAPI에 게임 일일 접속자 수 삭제를 위한 DELETE 엔드포인트를 구현한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| GameVisitDeleteRequest 스키마 추가 | backend/main.py | 날짜 범위 삭제 요청 스키마 |
| GameVisitDeleteResponse 스키마 추가 | backend/main.py | 삭제 응답 스키마 |
| DELETE /api/v1/game_visits/ 구현 | backend/main.py | 날짜 범위 기반 삭제 엔드포인트 |

**총 30분**

## 주요 변경 사항

### 1. docs/prd/게임일일접속수DELETE-실행계획.md 생성

**추가: 실행계획 문서**
```markdown
# 게임 일일 접속수 DELETE 엔드포인트 실행계획

## 요구사항 요약
- 요구사항: FastAPI에 게임 일일 접속자 수 삭제 엔드포인트 생성 (날짜 범위 기반 삭제)
- 목적: 관리자가 테스트 데이터나 잘못된 통계 데이터를 날짜 범위로 일괄 삭제

## 구현 방법
- SQLAlchemy의 filter와 delete 메서드 사용
- start_date, end_date를 필수 입력으로 받음
- func.date()로 created_at 컬럼의 날짜만 비교
- 삭제 완료 메시지와 날짜 범위를 응답
```

**특징:**
- PRD 검토 후 실행계획 작성
- API Key 인증 제거 (사용자 요청)
- deleted_count 응답 제거 (사용자 요청)
- 날짜 유효성 검증 포함

### 2. backend/main.py 수정 - Pydantic 스키마 추가

**추가: DELETE 엔드포인트용 스키마**
```python
class GameVisitDeleteRequest(BaseModel):
    """게임 접속 기록 삭제 요청 (날짜 범위)"""
    start_date: date
    end_date: date


class GameVisitDeleteResponse(BaseModel):
    """게임 접속 기록 삭제 응답"""
    message: str
    start_date: str
    end_date: str
```

**특징:**
- start_date, end_date를 date 타입으로 필수 입력 (null 불가)
- Pydantic의 자동 타입 검증 활용
- 응답에 삭제된 레코드 수는 포함하지 않음 (심플한 설계)
- 날짜 범위를 문자열로 반환하여 프론트엔드에서 확인 가능

### 3. backend/main.py 수정 - DELETE 엔드포인트 구현

**추가: DELETE /api/v1/game_visits/**
```python
@app.delete("/api/v1/game_visits/", response_model=GameVisitDeleteResponse)
def delete_game_visits(
    delete_data: GameVisitDeleteRequest,
    db: Session = Depends(get_db)
):
    """게임 접속 기록 삭제 (날짜 범위 기반)"""
    from sqlalchemy import func

    # 날짜 유효성 검증
    if delete_data.start_date > delete_data.end_date:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="start_date must be less than or equal to end_date"
        )

    # 날짜 범위에 해당하는 레코드 삭제
    db.query(GameVisit).filter(
        func.date(GameVisit.created_at) >= delete_data.start_date,
        func.date(GameVisit.created_at) <= delete_data.end_date
    ).delete(synchronize_session=False)

    db.commit()

    return GameVisitDeleteResponse(
        message="Game visit records deleted successfully",
        start_date=str(delete_data.start_date),
        end_date=str(delete_data.end_date)
    )
```

**특징:**
- API Key 인증 없음 (간편한 사용)
- start_date > end_date 검증하여 400 에러 반환
- `func.date()`로 created_at의 날짜 부분만 비교 (시간 무시)
- `delete(synchronize_session=False)`: 일괄 삭제 수행 (성능 최적화)
- 삭제 후 commit하여 DB 반영
- 삭제된 레코드 수는 반환하지 않음 (요구사항)

## 아키텍처 구조

### DELETE API 데이터 흐름
```
Client Request
    DELETE /api/v1/game_visits/
    Body: { "start_date": "2026-01-01", "end_date": "2026-01-31" }
     │
     ▼
FastAPI Endpoint
     │
     ├─→ Pydantic 검증
     │   ├─→ start_date, end_date: date 타입?
     │   └─→ null 값 거부
     │
     ├─→ 날짜 유효성 검증
     │   └─→ start_date > end_date? → 400 에러
     │
     ├─→ SQLAlchemy DELETE 실행
     │   ├─→ DELETE FROM game_visits
     │   ├─→ WHERE DATE(created_at) >= start_date
     │   └─→ AND DATE(created_at) <= end_date
     │
     ├─→ db.commit()
     │
     ▼
Response: GameVisitDeleteResponse
{
  "message": "Game visit records deleted successfully",
  "start_date": "2026-01-01",
  "end_date": "2026-01-31"
}
```

### 날짜 범위 삭제 예시
```
game_visits 테이블 (삭제 전):
┌────┬─────────┬─────────────┬────────────────────┐
│ id │ user_id │ ip_address  │ created_at         │
├────┼─────────┼─────────────┼────────────────────┤
│  1 │    5    │ 192.168.1.1 │ 2026-01-15 10:30:00│ ← 삭제 대상
│  2 │   null  │ 192.168.1.2 │ 2026-01-20 14:20:00│ ← 삭제 대상
│  3 │    3    │ 192.168.1.3 │ 2026-02-01 09:15:00│
│  4 │    7    │ 192.168.1.4 │ 2026-02-05 15:45:00│
└────┴─────────┴─────────────┴────────────────────┘

DELETE 요청:
{
  "start_date": "2026-01-01",
  "end_date": "2026-01-31"
}

game_visits 테이블 (삭제 후):
┌────┬─────────┬─────────────┬────────────────────┐
│ id │ user_id │ ip_address  │ created_at         │
├────┼─────────┼─────────────┼────────────────────┤
│  3 │    3    │ 192.168.1.3 │ 2026-02-01 09:15:00│
│  4 │    7    │ 192.168.1.4 │ 2026-02-05 15:45:00│
└────┴─────────┴─────────────┴────────────────────┘

결과: 2건 삭제됨
```

## 결과
- 상태: 완료

## 배운내용
db 쿼리.

## 다음 작업
- 랭킹 테이블에 nickname 필드 추가

---

# 업무일지 (4차)

## 기본 정보
- 날짜: 2026-02-04 (화) 16:00~17:00
- 작성자: hexsera

## 진행 목표
monthly_scores 테이블에 nickname 필드를 추가하고, POST API에서 User 테이블의 nickname을 자동으로 가져와 저장하며, GET API 응답에서 user_id 대신 nickname을 반환한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| MonthlyScore 모델에 nickname 필드 추가 | backend/models.py | String(100), nullable=False |
| Alembic 마이그레이션 생성 및 적용 | - | e9059978e80e_add_nickname_to_monthly_scores.py |
| POST API에 nickname 조회 및 저장 로직 추가 | backend/main.py | User 테이블 조회 및 404 처리 |
| MonthlyScoreResponse 스키마 수정 | backend/main.py | user_id 제거, nickname 추가 |
| Mock 데이터 생성 스크립트 작성 | backend/seed_monthly_scores.py | users 테이블 기반 랜덤 점수 생성 |
| Mock 데이터 스크립트 실행 | - | 31명 사용자 점수 생성 완료 |

**총 30분**

## 주요 변경 사항

### 1. backend/models.py 수정

**변경 전:**
```python
class MonthlyScore(Base):
    __tablename__ = "monthly_scores"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)
    score = Column(Integer, nullable=False, index=True)
    created_at = Column(DateTime, nullable=False, server_default=func.now(), index=True)
```

**변경 후:**
```python
class MonthlyScore(Base):
    __tablename__ = "monthly_scores"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)
    nickname = Column(String(100), nullable=False)
    score = Column(Integer, nullable=False, index=True)
    created_at = Column(DateTime, nullable=False, server_default=func.now(), index=True)
```

**특징:**
- nickname 필드 추가: users 테이블의 nickname과 동일한 타입 (String(100))
- nullable=False: 필수 값 (User 테이블에서 항상 가져올 수 있음)
- 인덱스 미설정: 조회 조건으로 사용하지 않음

### 2. backend/main.py 수정 - POST API에 nickname 저장 로직 추가

**변경 전:**
```python
@app.post("/api/v1/monthly-scores", response_model=MonthlyScoreResponse)
def create_or_update_monthly_score(
    score_data: MonthlyScoreCreateRequest,
    db: Session = Depends(get_db)
):
    """월간 점수 생성 또는 수정 (최고 점수만 저장)"""
    existing_score = db.query(MonthlyScore).filter(
        MonthlyScore.user_id == score_data.user_id
    ).first()

    if existing_score:
        if score_data.score > existing_score.score:
            existing_score.score = score_data.score
            db.commit()
            db.refresh(existing_score)
        return existing_score
    else:
        new_score = MonthlyScore(
            user_id=score_data.user_id,
            score=score_data.score
        )
        db.add(new_score)
        db.commit()
        db.refresh(new_score)
        return new_score
```

**변경 후:**
```python
@app.post("/api/v1/monthly-scores", response_model=MonthlyScoreResponse)
def create_or_update_monthly_score(
    score_data: MonthlyScoreCreateRequest,
    db: Session = Depends(get_db)
):
    """월간 점수 생성 또는 수정 (최고 점수만 저장)"""
    # User 테이블에서 nickname 조회
    user = db.query(User).filter(User.id == score_data.user_id).first()
    if user is None:
        raise HTTPException(
            status_code=404,
            detail=f"User with id {score_data.user_id} not found"
        )

    existing_score = db.query(MonthlyScore).filter(
        MonthlyScore.user_id == score_data.user_id
    ).first()

    if existing_score:
        if score_data.score > existing_score.score:
            existing_score.score = score_data.score
            existing_score.nickname = user.nickname  # nickname 갱신
            db.commit()
            db.refresh(existing_score)
        return existing_score
    else:
        new_score = MonthlyScore(
            user_id=score_data.user_id,
            nickname=user.nickname,  # nickname 저장
            score=score_data.score
        )
        db.add(new_score)
        db.commit()
        db.refresh(new_score)
        return new_score
```

**특징:**
- User 테이블 조회: user_id로 User를 조회하여 nickname 가져오기
- 404 에러 처리: 존재하지 않는 user_id는 404 에러 반환
- nickname 갱신: 기존 점수 갱신 시에도 nickname 함께 갱신 (사용자가 닉네임 변경한 경우 대응)
- nickname 저장: 신규 점수 생성 시 nickname 포함

### 3. backend/main.py 수정 - MonthlyScoreResponse 스키마

**변경 전:**
```python
class MonthlyScoreResponse(BaseModel):
    """월간 점수 응답"""
    user_id: int
    score: int
    created_at: datetime

    class Config:
        from_attributes = True
```

**변경 후:**
```python
class MonthlyScoreResponse(BaseModel):
    """월간 점수 응답"""
    nickname: str
    score: int
    created_at: datetime

    class Config:
        from_attributes = True
```

**특징:**
- user_id 제거: 프론트엔드에서 user_id 대신 nickname 사용
- nickname 추가: User 테이블 조회 없이 바로 닉네임 표시 가능
- from_attributes = True: SQLAlchemy 모델을 Pydantic 모델로 자동 변환

### 4. backend/seed_monthly_scores.py 생성

**추가: Mock 데이터 생성 스크립트**
```python
import os
import random
from datetime import datetime
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv
from models import User, MonthlyScore

load_dotenv()

# DB 연결
DATABASE_URL = f"mysql+pymysql://{os.getenv('MYSQL_USER')}:{os.getenv('MYSQL_PASSWORD')}@{os.getenv('MYSQL_HOST')}:{os.getenv('MYSQL_PORT')}/{os.getenv('MYSQL_DATABASE')}"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def seed_monthly_scores():
    """users 테이블의 ID를 기반으로 MonthlyScore Mock 데이터 생성"""
    db = SessionLocal()
    try:
        users = db.query(User).all()
        if not users:
            print("No users found in the database")
            return

        print(f"Found {len(users)} users")

        for user in users:
            existing = db.query(MonthlyScore).filter(
                MonthlyScore.user_id == user.id
            ).first()

            if existing:
                print(f"User {user.id} ({user.nickname}) already has a score: {existing.score}")
                continue

            random_score = random.randint(1000, 50000)
            monthly_score = MonthlyScore(
                user_id=user.id,
                nickname=user.nickname,
                score=random_score
            )
            db.add(monthly_score)
            print(f"Created score for user {user.id} ({user.nickname}): {random_score}")

        db.commit()
        print("Monthly scores seeding completed")
    except Exception as e:
        print(f"Error during seeding: {e}")
        db.rollback()
    finally:
        db.close()
```

**특징:**
- users 테이블의 모든 사용자 ID를 조회하여 MonthlyScore 생성
- 각 사용자마다 1000~50000 사이의 랜덤 점수 생성
- 중복 방지: 이미 점수가 있는 사용자는 스킵
- nickname 저장: 실제 API 동작과 동일하게 테스트

## 아키텍처 구조

### POST API 데이터 흐름
```
Client Request
    POST /api/v1/monthly-scores
    Body: { "user_id": 5, "score": 42000 }
     │
     ▼
FastAPI Endpoint
     │
     ├─→ User 테이블 조회
     │   ├─→ SELECT * FROM users WHERE id = 5
     │   ├─→ 존재 O → nickname 추출
     │   └─→ 존재 X → 404 에러
     │
     ├─→ MonthlyScore 조회
     │   └─→ SELECT * FROM monthly_scores WHERE user_id = 5
     │
     ├─→ 기존 레코드 존재?
     │   ├─→ Yes: score 비교
     │   │        ├─→ 새 점수 > 기존 점수?
     │   │        │   ├─→ Yes: UPDATE (score, nickname)
     │   │        │   └─→ No: 기존 레코드 반환
     │   │
     │   └─→ No: INSERT (user_id, nickname, score)
     │
     ▼
Response: MonthlyScoreResponse
{
  "nickname": "정민호",
  "score": 42000,
  "created_at": "2026-02-04T16:45:00"
}
```

### GET API 응답 변경
```
변경 전 (user_id 포함):
{
  "scores": [
    {"user_id": 5, "score": 41380, "created_at": "..."},
    {"user_id": 12, "score": 48030, "created_at": "..."}
  ],
  "total": 2
}

변경 후 (nickname 포함):
{
  "scores": [
    {"nickname": "정민호", "score": 41380, "created_at": "..."},
    {"nickname": "최영아", "score": 48030, "created_at": "..."}
  ],
  "total": 2
}

프론트엔드 영향:
- User 테이블 조회 API 호출 불필요
- 닉네임을 바로 화면에 표시 가능
- API 호출 횟수 감소 (성능 향상)
```

### 데이터베이스 구조 변경
```
monthly_scores 테이블 (변경 전):
┌────┬─────────┬───────┬─────────────────────┐
│ id │ user_id │ score │ created_at          │
├────┼─────────┼───────┼─────────────────────┤
│  1 │    5    │ 41380 │ 2026-02-04 16:45:00 │
│  2 │   12    │ 48030 │ 2026-02-04 16:45:01 │
└────┴─────────┴───────┴─────────────────────┘

monthly_scores 테이블 (변경 후):
┌────┬─────────┬──────────┬───────┬─────────────────────┐
│ id │ user_id │ nickname │ score │ created_at          │
├────┼─────────┼──────────┼───────┼─────────────────────┤
│  1 │    5    │ 정민호   │ 41380 │ 2026-02-04 16:45:00 │
│  2 │   12    │ 최영아   │ 48030 │ 2026-02-04 16:45:01 │
└────┴─────────┴──────────┴───────┴─────────────────────┘
```

## 결과
- 상태: 완료


## 배운내용


## 다음 작업
- user 에서 nickname 수정시 랭킹 테이블에도 필드 수정.

---

# 업무일지 (5차)

## 기본 정보
- 날짜: 2026-02-04 (화) 17:08~17:40
- 작성자: hexsera

## 진행 목표
FastAPI 백엔드 구조 개선을 위한 Phase 2(핵심 설정 분리)를 실행한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| config.py 생성 | backend/app/core/config.py | 환경변수 중앙 관리 |
| security.py 생성 | backend/app/core/security.py | API Key 인증 로직 분리 |
| .env 파일 생성 | backend/.env | API_KEY 환경변수 추가 |
| __init__.py 생성 | backend/app/__init__.py, backend/app/core/__init__.py | Python 패키지 인식 |
| 모듈 import 테스트 | - | config.py, security.py 정상 동작 확인 |

## 주요 변경 사항

### 1. backend/app/core/config.py 생성

**추가: Settings 클래스**
```python
import os
from dotenv import load_dotenv

load_dotenv()

class Settings:
    """애플리케이션 설정"""
    # Database
    MYSQL_HOST: str = os.getenv("MYSQL_HOST")
    MYSQL_PORT: str = os.getenv("MYSQL_PORT")
    MYSQL_DATABASE: str = os.getenv("MYSQL_DATABASE")
    MYSQL_USER: str = os.getenv("MYSQL_USER")
    MYSQL_PASSWORD: str = os.getenv("MYSQL_PASSWORD")

    # API Key
    API_KEY: str = os.getenv("API_KEY")

    # Admin Seeding
    ADMIN_EMAIL: str = os.getenv("ADMIN_EMAIL")
    ADMIN_NICKNAME: str = os.getenv("ADMIN_NICKNAME")
    ADMIN_PASSWORD: str = os.getenv("ADMIN_PASSWORD")
    ADMIN_BIRTH_DATE: str = os.getenv("ADMIN_BIRTH_DATE")

    @property
    def DATABASE_URL(self) -> str:
        return f"mysql+pymysql://{self.MYSQL_USER}:{self.MYSQL_PASSWORD}@{self.MYSQL_HOST}:{self.MYSQL_PORT}/{self.MYSQL_DATABASE}"

settings = Settings()
```

**특징:**
- 환경변수를 중앙에서 관리하는 Settings 클래스
- DATABASE_URL 자동 생성 property
- 모든 설정을 한 곳에서 관리하여 변경 용이
- API_KEY를 환경변수로 이동 (보안 개선)

### 2. backend/app/core/security.py 생성

**추가: verify_api_key 함수**
```python
from fastapi import HTTPException, Depends
from fastapi.security import APIKeyHeader
from app.core.config import settings

API_KEY_HEADER = APIKeyHeader(name="X-API-Key", auto_error=False)

def verify_api_key(api_key: str = Depends(API_KEY_HEADER)) -> str:
    """API Key 검증 의존성"""
    if api_key is None:
        raise HTTPException(status_code=401, detail="API Key is missing")
    if api_key != settings.API_KEY:
        raise HTTPException(status_code=403, detail="Invalid API Key")
    return api_key
```

**특징:**
- 인증 로직을 core/로 통합
- 하드코딩된 API_KEY를 settings에서 가져옴
- 기존 auth.py와 동일한 기능, 구조만 개선

### 3. backend/.env 생성

**추가: 환경변수 파일**
```bash
# Database Configuration
MYSQL_HOST=mysql-server
MYSQL_PORT=3306
MYSQL_DATABASE=hexdb
MYSQL_USER=hexsera
MYSQL_PASSWORD=hexpoint

# API Key
API_KEY=hexsera-secret-api-key-2026

# Admin Account Seed Data
ADMIN_EMAIL=admin@hexsera.com
ADMIN_NICKNAME=admin
ADMIN_PASSWORD=admin_secure_password_2026
ADMIN_BIRTH_DATE=2000-01-01
```

**특징:**
- API Key를 환경변수로 이동
- 데이터베이스 설정, Admin 계정 정보 포함
- 코드에서 하드코딩 제거

## 아키텍처 구조

### 새로운 구조 (Phase 2)
```
backend/
├── app/
│   ├── __init__.py (생성)
│   └── core/
│       ├── __init__.py (생성)
│       ├── config.py (생성) ← 환경변수 중앙 관리
│       └── security.py (생성) ← API Key 인증
├── .env (생성) ← API_KEY 추가
├── main.py (유지) ← 아직 기존 auth.py 사용
└── auth.py (유지) ← 아직 사용 중
```

### 병행 구조 특징
```
현재 상태 (Phase 2 완료):
┌─────────────────────────────────┐
│      main.py                    │
│  - 기존 auth.py 사용           │ ← 실제 동작
│  - 기존 database.py 사용       │
└─────────────────────────────────┘

┌─────────────────────────────────┐
│   app/core/ (새 구조)           │
│  - config.py (준비 완료)        │ ← 파일로만 존재
│  - security.py (준비 완료)      │
└─────────────────────────────────┘

Phase 6에서 main.py를 리팩토링하면:
main.py → app/core/ 구조로 전환
```

### 환경변수 흐름
```
.env 파일
    │
    ├─→ os.getenv("API_KEY") → config.Settings.API_KEY
    │                                    │
    │                                    ▼
    │                         security.verify_api_key()
    │                                    │
    │                                    ▼
    │                         FastAPI Dependency
    │
    └─→ os.getenv("MYSQL_*") → config.Settings.DATABASE_URL
                                        │
                                        ▼
                                db/session.py (Phase 3)
```

## 결과
- 상태: 완료
- 기존 API 정상 동작 확인 (병행 구조, 영향 없음)
- Phase 3 준비 완료

## 배운내용


## 다음 작업
- Phase 3: 데이터베이스 레이어 분리 (db/)
