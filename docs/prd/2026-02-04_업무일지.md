# 업무일지

## 기본 정보
- 날짜: 2026-02-04 (화) 9:08~9:31 11:10~12:00
- 작성자: hexsera

## 진행 목표
FastAPI에 게임 일일 접속자 수 집계를 위한 PUT/POST 엔드포인트를 구현한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| GameVisit 모델 생성 | backend/models.py | user_id, ip_address, is_visits 필드 추가 |
| PUT 엔드포인트용 스키마 생성 | backend/main.py | GameVisitUpdateRequest, GameVisitUpdateResponse |
| PUT /api/v1/game_visits 구현 | backend/main.py | IP 기반 접속 기록 업데이트 |
| POST 엔드포인트용 스키마 생성 | backend/main.py | GameVisitCreateRequest, GameVisitCreateResponse |
| get_client_ip 함수 구현 | backend/main.py | 프록시 환경 고려한 IP 추출 |
| POST /api/v1/game_visits 구현 | backend/main.py | 오늘 날짜 + IP 기준 중복 방지 로직 |
| Request, and_ import 추가 | backend/main.py | FastAPI Request, SQLAlchemy and_ |

## 주요 변경 사항

### 1. backend/models.py 수정

**추가: GameVisit 모델**
```python
from sqlalchemy import Column, Integer, String, Date, DateTime, Boolean, UniqueConstraint, CheckConstraint

class GameVisit(Base):
    __tablename__ = "game_visits"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=True, index=True)
    ip_address = Column(String(45), nullable=False, index=True)
    is_visits = Column(Boolean, nullable=False, default=False)
    created_at = Column(DateTime, nullable=False, server_default=func.now(), index=True)
    updated_at = Column(DateTime, nullable=False, server_default=func.now(), onupdate=func.now())
```

**특징:**
- user_id는 nullable로 설정하여 비회원 접속도 기록 가능
- ip_address는 String(45)로 IPv6 지원 (IPv4: 15자, IPv6: 45자)
- is_visits는 방문 여부를 나타내는 boolean 필드
- created_at과 updated_at으로 생성/수정 시각 자동 기록
- 모든 조회 필드에 인덱스 추가 (성능 최적화)

### 2. backend/main.py - Import 수정

**변경 전:**
```python
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy import or_
from models import User, Score, Friendship, MonthlyScore
```

**변경 후:**
```python
from fastapi import FastAPI, Depends, HTTPException, status, Request
from sqlalchemy import or_, and_
from models import User, Score, Friendship, MonthlyScore, GameVisit
```

**특징:**
- Request: HTTP 요청 정보(헤더, IP 등)에 접근하기 위해 추가
- and_: 여러 조건을 AND로 결합하기 위해 추가
- GameVisit: 새로 생성한 모델 import

### 3. backend/main.py - Helper 함수 추가

**추가: get_client_ip 함수**
```python
def get_client_ip(request: Request) -> str:
    """클라이언트 IP 주소 추출 (프록시 고려)"""
    # X-Forwarded-For 헤더 확인 (프록시/로드밸런서 뒤에 있는 경우)
    forwarded_for = request.headers.get("X-Forwarded-For")
    if forwarded_for:
        # 첫 번째 IP가 실제 클라이언트 IP
        return forwarded_for.split(",")[0].strip()

    # X-Real-IP 헤더 확인 (Nginx 등에서 사용)
    real_ip = request.headers.get("X-Real-IP")
    if real_ip:
        return real_ip

    # 직접 연결된 클라이언트 IP
    return request.client.host
```

**특징:**
- 프록시/로드밸런서 환경을 고려한 IP 추출
- X-Forwarded-For 헤더 우선 확인 (프록시 체인의 첫 번째 IP)
- X-Real-IP 헤더 차순위 확인 (Nginx 등)
- 직접 연결 시 request.client.host 사용

### 4. backend/main.py - Pydantic 스키마 추가

**추가: PUT 엔드포인트용 스키마**
```python
class GameVisitUpdateRequest(BaseModel):
    """게임 접속 기록 수정 요청"""
    user_id: Optional[int] = None
    ip_address: str

class GameVisitUpdateResponse(BaseModel):
    """게임 접속 기록 수정 응답"""
    message: str
    user_id: Optional[int]
    ip_address: str
    is_visits: bool
    updated_at: datetime
```

**추가: POST 엔드포인트용 스키마**
```python
class GameVisitCreateRequest(BaseModel):
    """게임 접속 기록 생성 요청"""
    user_id: Optional[int] = None

class GameVisitCreateResponse(BaseModel):
    """게임 접속 기록 생성 응답"""
    message: str
    user_id: Optional[int]
    ip_address: str
    created_at: datetime
    is_new_record: bool
```

**특징:**
- PUT용: ip_address를 요청에서 받음 (테스트/관리 목적)
- POST용: ip_address는 서버에서 자동 추출 (실제 사용)
- is_new_record: 새 레코드 생성 여부를 응답에 포함

### 5. backend/main.py - POST 엔드포인트 구현

**추가: POST /api/v1/game_visits**
```python
@app.post("/api/v1/game_visits", response_model=GameVisitCreateResponse, status_code=201)
def create_game_visit(
    visit_data: GameVisitCreateRequest,
    request: Request,
    db: Session = Depends(get_db)
):
    """게임 접속 기록 생성 (오늘 날짜 + IP 기준 중복 방지)"""
    from sqlalchemy import func

    # 클라이언트 IP 추출
    client_ip = get_client_ip(request)

    # 오늘 날짜와 IP로 레코드 조회
    today = func.date(func.now())
    existing_visit = db.query(GameVisit).filter(
        and_(
            func.date(GameVisit.created_at) == today,
            GameVisit.ip_address == client_ip
        )
    ).first()

    if existing_visit:
        # 레코드가 존재하면 user_id가 null인 경우에만 업데이트
        if existing_visit.user_id is None and visit_data.user_id is not None:
            existing_visit.user_id = visit_data.user_id
            db.commit()
            db.refresh(existing_visit)

        return GameVisitCreateResponse(
            message="Game visit record updated",
            user_id=existing_visit.user_id,
            ip_address=existing_visit.ip_address,
            created_at=existing_visit.created_at,
            is_new_record=False
        )
    else:
        # 레코드가 없으면 새로 생성
        new_visit = GameVisit(
            user_id=visit_data.user_id,
            ip_address=client_ip,
            is_visits=True
        )
        db.add(new_visit)
        db.commit()
        db.refresh(new_visit)

        return GameVisitCreateResponse(
            message="Game visit record created",
            user_id=new_visit.user_id,
            ip_address=new_visit.ip_address,
            created_at=new_visit.created_at,
            is_new_record=True
        )
```

**특징:**
- func.date()로 시간을 제외한 날짜만 비교 (오늘 접속 기록 조회)
- 오늘 같은 IP 접속이 있으면: user_id가 null이고 요청의 user_id가 null이 아닐 때만 업데이트
- 오늘 같은 IP 접속이 없으면: 새 레코드 생성 (is_visits=True)
- is_new_record로 생성/업데이트 구분
- 201 Created 상태 코드 반환

### 6. backend/main.py - PUT 엔드포인트 구현

**추가: PUT /api/v1/game_visits**
```python
@app.put("/api/v1/game_visits", response_model=GameVisitUpdateResponse)
def update_game_visit(
    visit_data: GameVisitUpdateRequest,
    db: Session = Depends(get_db)
):
    """IP 주소 기반 게임 접속 기록 업데이트 (is_visits = True)"""
    # IP 주소로 레코드 조회
    game_visit = db.query(GameVisit).filter(
        GameVisit.ip_address == visit_data.ip_address
    ).first()

    if game_visit is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Game visit record for IP {visit_data.ip_address} not found"
        )

    # user_id와 is_visits 필드 업데이트
    if visit_data.user_id is not None:
        game_visit.user_id = visit_data.user_id
    game_visit.is_visits = True
    db.commit()
    db.refresh(game_visit)

    return GameVisitUpdateResponse(
        message="Game visit updated successfully",
        user_id=game_visit.user_id,
        ip_address=game_visit.ip_address,
        is_visits=game_visit.is_visits,
        updated_at=game_visit.updated_at
    )
```

**특징:**
- IP 주소로 레코드 조회 (날짜 필터링 없음)
- 레코드가 없으면 404 에러 반환
- user_id가 제공되면 함께 업데이트
- is_visits를 True로 설정
- updated_at은 onupdate=func.now()에 의해 자동 갱신

## 아키텍처 구조

### API 엔드포인트 구조
```
Game Visit API
├── POST /api/v1/game_visits (실제 사용)
│   ├── Request: user_id (Optional)
│   ├── IP 자동 추출: get_client_ip()
│   ├── 오늘 날짜 + IP 조회
│   │   ├── 존재 O → user_id null일 때만 업데이트
│   │   └── 존재 X → 새 레코드 생성
│   └── Response: message, user_id, ip_address, created_at, is_new_record
│
└── PUT /api/v1/game_visits (테스트/관리용)
    ├── Request: user_id, ip_address
    ├── IP로 레코드 조회
    │   ├── 존재 O → user_id, is_visits 업데이트
    │   └── 존재 X → 404 에러
    └── Response: message, user_id, ip_address, is_visits, updated_at
```

### 데이터 흐름
```
Client Request
     │
     ▼
FastAPI Endpoint (POST /api/v1/game_visits)
     │
     ├─→ get_client_ip() → Extract IP from Headers
     │                      (X-Forwarded-For → X-Real-IP → client.host)
     │
     ├─→ Query DB (today + IP)
     │        │
     │        ├─→ Record exists?
     │        │        ├─→ Yes: user_id null? → Update user_id
     │        │        └─→ No: Create new record
     │        │
     ▼        ▼
    DB: game_visits
        ├── id (PK)
        ├── user_id (nullable, indexed)
        ├── ip_address (indexed)
        ├── is_visits (bool)
        ├── created_at (indexed)
        └── updated_at
```

### 비회원 → 회원 전환 시나리오
```
Step 1: 비회원 접속
    POST /api/v1/game_visits { user_id: null }
    → IP: 192.168.1.100 추출
    → DB 저장: { user_id: null, ip: 192.168.1.100, is_visits: true }

Step 2: 동일 IP에서 회원 로그인
    POST /api/v1/game_visits { user_id: 123 }
    → IP: 192.168.1.100 추출
    → 오늘 레코드 조회 (IP 일치)
    → user_id가 null이고 요청의 user_id가 123
    → DB 업데이트: { user_id: 123, ip: 192.168.1.100, is_visits: true }

Step 3: 동일 IP에서 재접속
    POST /api/v1/game_visits { user_id: 456 }
    → IP: 192.168.1.100 추출
    → 오늘 레코드 조회 (IP 일치)
    → user_id가 123 (not null)
    → 업데이트 하지 않음 (기존 레코드 반환)
```

## 결과
- 상태: 완료
- 완벽한 테스트 못함 (여러 ip, 여러 날짜에서 테스트 못함)
- 학습 못함

## 배운내용
정교하게 설계하려 할 수록 시간이 많이걸린다.
ip 로 사용자를 구분하는것은 한계가 있다.

## 다음 작업
- 프론트엔드에서 게임 접속 시 POST /api/v1/game_visits 호출 구현
