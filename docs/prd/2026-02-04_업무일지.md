# 업무일지

## 기본 정보
- 날짜: 2026-02-04 (화) 9:08~9:31 11:10~12:00
- 작성자: hexsera

## 진행 목표
FastAPI에 게임 일일 접속자 수 집계를 위한 PUT/POST 엔드포인트를 구현한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| GameVisit 모델 생성 | backend/models.py | user_id, ip_address, is_visits 필드 추가 |
| PUT 엔드포인트용 스키마 생성 | backend/main.py | GameVisitUpdateRequest, GameVisitUpdateResponse |
| PUT /api/v1/game_visits 구현 | backend/main.py | IP 기반 접속 기록 업데이트 |
| POST 엔드포인트용 스키마 생성 | backend/main.py | GameVisitCreateRequest, GameVisitCreateResponse |
| get_client_ip 함수 구현 | backend/main.py | 프록시 환경 고려한 IP 추출 |
| POST /api/v1/game_visits 구현 | backend/main.py | 오늘 날짜 + IP 기준 중복 방지 로직 |
| Request, and_ import 추가 | backend/main.py | FastAPI Request, SQLAlchemy and_ |

## 주요 변경 사항

### 1. backend/models.py 수정

**추가: GameVisit 모델**
```python
from sqlalchemy import Column, Integer, String, Date, DateTime, Boolean, UniqueConstraint, CheckConstraint

class GameVisit(Base):
    __tablename__ = "game_visits"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=True, index=True)
    ip_address = Column(String(45), nullable=False, index=True)
    is_visits = Column(Boolean, nullable=False, default=False)
    created_at = Column(DateTime, nullable=False, server_default=func.now(), index=True)
    updated_at = Column(DateTime, nullable=False, server_default=func.now(), onupdate=func.now())
```

**특징:**
- user_id는 nullable로 설정하여 비회원 접속도 기록 가능
- ip_address는 String(45)로 IPv6 지원 (IPv4: 15자, IPv6: 45자)
- is_visits는 방문 여부를 나타내는 boolean 필드
- created_at과 updated_at으로 생성/수정 시각 자동 기록
- 모든 조회 필드에 인덱스 추가 (성능 최적화)

### 2. backend/main.py - Import 수정

**변경 전:**
```python
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy import or_
from models import User, Score, Friendship, MonthlyScore
```

**변경 후:**
```python
from fastapi import FastAPI, Depends, HTTPException, status, Request
from sqlalchemy import or_, and_
from models import User, Score, Friendship, MonthlyScore, GameVisit
```

**특징:**
- Request: HTTP 요청 정보(헤더, IP 등)에 접근하기 위해 추가
- and_: 여러 조건을 AND로 결합하기 위해 추가
- GameVisit: 새로 생성한 모델 import

### 3. backend/main.py - Helper 함수 추가

**추가: get_client_ip 함수**
```python
def get_client_ip(request: Request) -> str:
    """클라이언트 IP 주소 추출 (프록시 고려)"""
    # X-Forwarded-For 헤더 확인 (프록시/로드밸런서 뒤에 있는 경우)
    forwarded_for = request.headers.get("X-Forwarded-For")
    if forwarded_for:
        # 첫 번째 IP가 실제 클라이언트 IP
        return forwarded_for.split(",")[0].strip()

    # X-Real-IP 헤더 확인 (Nginx 등에서 사용)
    real_ip = request.headers.get("X-Real-IP")
    if real_ip:
        return real_ip

    # 직접 연결된 클라이언트 IP
    return request.client.host
```

**특징:**
- 프록시/로드밸런서 환경을 고려한 IP 추출
- X-Forwarded-For 헤더 우선 확인 (프록시 체인의 첫 번째 IP)
- X-Real-IP 헤더 차순위 확인 (Nginx 등)
- 직접 연결 시 request.client.host 사용

### 4. backend/main.py - Pydantic 스키마 추가

**추가: PUT 엔드포인트용 스키마**
```python
class GameVisitUpdateRequest(BaseModel):
    """게임 접속 기록 수정 요청"""
    user_id: Optional[int] = None
    ip_address: str

class GameVisitUpdateResponse(BaseModel):
    """게임 접속 기록 수정 응답"""
    message: str
    user_id: Optional[int]
    ip_address: str
    is_visits: bool
    updated_at: datetime
```

**추가: POST 엔드포인트용 스키마**
```python
class GameVisitCreateRequest(BaseModel):
    """게임 접속 기록 생성 요청"""
    user_id: Optional[int] = None

class GameVisitCreateResponse(BaseModel):
    """게임 접속 기록 생성 응답"""
    message: str
    user_id: Optional[int]
    ip_address: str
    created_at: datetime
    is_new_record: bool
```

**특징:**
- PUT용: ip_address를 요청에서 받음 (테스트/관리 목적)
- POST용: ip_address는 서버에서 자동 추출 (실제 사용)
- is_new_record: 새 레코드 생성 여부를 응답에 포함

### 5. backend/main.py - POST 엔드포인트 구현

**추가: POST /api/v1/game_visits**
```python
@app.post("/api/v1/game_visits", response_model=GameVisitCreateResponse, status_code=201)
def create_game_visit(
    visit_data: GameVisitCreateRequest,
    request: Request,
    db: Session = Depends(get_db)
):
    """게임 접속 기록 생성 (오늘 날짜 + IP 기준 중복 방지)"""
    from sqlalchemy import func

    # 클라이언트 IP 추출
    client_ip = get_client_ip(request)

    # 오늘 날짜와 IP로 레코드 조회
    today = func.date(func.now())
    existing_visit = db.query(GameVisit).filter(
        and_(
            func.date(GameVisit.created_at) == today,
            GameVisit.ip_address == client_ip
        )
    ).first()

    if existing_visit:
        # 레코드가 존재하면 user_id가 null인 경우에만 업데이트
        if existing_visit.user_id is None and visit_data.user_id is not None:
            existing_visit.user_id = visit_data.user_id
            db.commit()
            db.refresh(existing_visit)

        return GameVisitCreateResponse(
            message="Game visit record updated",
            user_id=existing_visit.user_id,
            ip_address=existing_visit.ip_address,
            created_at=existing_visit.created_at,
            is_new_record=False
        )
    else:
        # 레코드가 없으면 새로 생성
        new_visit = GameVisit(
            user_id=visit_data.user_id,
            ip_address=client_ip,
            is_visits=True
        )
        db.add(new_visit)
        db.commit()
        db.refresh(new_visit)

        return GameVisitCreateResponse(
            message="Game visit record created",
            user_id=new_visit.user_id,
            ip_address=new_visit.ip_address,
            created_at=new_visit.created_at,
            is_new_record=True
        )
```

**특징:**
- func.date()로 시간을 제외한 날짜만 비교 (오늘 접속 기록 조회)
- 오늘 같은 IP 접속이 있으면: user_id가 null이고 요청의 user_id가 null이 아닐 때만 업데이트
- 오늘 같은 IP 접속이 없으면: 새 레코드 생성 (is_visits=True)
- is_new_record로 생성/업데이트 구분
- 201 Created 상태 코드 반환

### 6. backend/main.py - PUT 엔드포인트 구현

**추가: PUT /api/v1/game_visits**
```python
@app.put("/api/v1/game_visits", response_model=GameVisitUpdateResponse)
def update_game_visit(
    visit_data: GameVisitUpdateRequest,
    db: Session = Depends(get_db)
):
    """IP 주소 기반 게임 접속 기록 업데이트 (is_visits = True)"""
    # IP 주소로 레코드 조회
    game_visit = db.query(GameVisit).filter(
        GameVisit.ip_address == visit_data.ip_address
    ).first()

    if game_visit is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Game visit record for IP {visit_data.ip_address} not found"
        )

    # user_id와 is_visits 필드 업데이트
    if visit_data.user_id is not None:
        game_visit.user_id = visit_data.user_id
    game_visit.is_visits = True
    db.commit()
    db.refresh(game_visit)

    return GameVisitUpdateResponse(
        message="Game visit updated successfully",
        user_id=game_visit.user_id,
        ip_address=game_visit.ip_address,
        is_visits=game_visit.is_visits,
        updated_at=game_visit.updated_at
    )
```

**특징:**
- IP 주소로 레코드 조회 (날짜 필터링 없음)
- 레코드가 없으면 404 에러 반환
- user_id가 제공되면 함께 업데이트
- is_visits를 True로 설정
- updated_at은 onupdate=func.now()에 의해 자동 갱신

## 아키텍처 구조

### API 엔드포인트 구조
```
Game Visit API
├── POST /api/v1/game_visits (실제 사용)
│   ├── Request: user_id (Optional)
│   ├── IP 자동 추출: get_client_ip()
│   ├── 오늘 날짜 + IP 조회
│   │   ├── 존재 O → user_id null일 때만 업데이트
│   │   └── 존재 X → 새 레코드 생성
│   └── Response: message, user_id, ip_address, created_at, is_new_record
│
└── PUT /api/v1/game_visits (테스트/관리용)
    ├── Request: user_id, ip_address
    ├── IP로 레코드 조회
    │   ├── 존재 O → user_id, is_visits 업데이트
    │   └── 존재 X → 404 에러
    └── Response: message, user_id, ip_address, is_visits, updated_at
```

### 데이터 흐름
```
Client Request
     │
     ▼
FastAPI Endpoint (POST /api/v1/game_visits)
     │
     ├─→ get_client_ip() → Extract IP from Headers
     │                      (X-Forwarded-For → X-Real-IP → client.host)
     │
     ├─→ Query DB (today + IP)
     │        │
     │        ├─→ Record exists?
     │        │        ├─→ Yes: user_id null? → Update user_id
     │        │        └─→ No: Create new record
     │        │
     ▼        ▼
    DB: game_visits
        ├── id (PK)
        ├── user_id (nullable, indexed)
        ├── ip_address (indexed)
        ├── is_visits (bool)
        ├── created_at (indexed)
        └── updated_at
```

### 비회원 → 회원 전환 시나리오
```
Step 1: 비회원 접속
    POST /api/v1/game_visits { user_id: null }
    → IP: 192.168.1.100 추출
    → DB 저장: { user_id: null, ip: 192.168.1.100, is_visits: true }

Step 2: 동일 IP에서 회원 로그인
    POST /api/v1/game_visits { user_id: 123 }
    → IP: 192.168.1.100 추출
    → 오늘 레코드 조회 (IP 일치)
    → user_id가 null이고 요청의 user_id가 123
    → DB 업데이트: { user_id: 123, ip: 192.168.1.100, is_visits: true }

Step 3: 동일 IP에서 재접속
    POST /api/v1/game_visits { user_id: 456 }
    → IP: 192.168.1.100 추출
    → 오늘 레코드 조회 (IP 일치)
    → user_id가 123 (not null)
    → 업데이트 하지 않음 (기존 레코드 반환)
```

## 결과
- 상태: 완료
- 완벽한 테스트 못함 (여러 ip, 여러 날짜에서 테스트 못함)
- 학습 못함

## 배운내용
정교하게 설계하려 할 수록 시간이 많이걸린다.
ip 로 사용자를 구분하는것은 한계가 있다.

## 다음 작업
- 프론트엔드에서 게임 접속 시 POST /api/v1/game_visits 호출 구현

---

# 업무일지 (2차)

## 기본 정보
- 날짜: 2026-02-04 (화) 13:00~14:00
- 작성자: hexsera

## 진행 목표
FastAPI에 게임 일일 접속자 수 집계를 위한 GET 엔드포인트를 구현하고, 테스트용 Mock 데이터 생성 스크립트를 작성한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| DailyVisitStats 스키마 추가 | backend/main.py | 일별 통계 응답 스키마 |
| DailyVisitStatsResponse 스키마 추가 | backend/main.py | 통계 목록 응답 스키마 |
| GET /api/v1/game_visits/ 구현 | backend/main.py | 날짜별 접속자 수 집계 |
| Mock 데이터 생성 스크립트 작성 | backend/create_mock_visits.py | 테스트용 데이터 생성 |

## 주요 변경 사항

### 1. backend/main.py 수정 - Pydantic 스키마 추가

**추가: 일별 접속자 수 통계 스키마**
```python
class DailyVisitStats(BaseModel):
    """일별 접속자 수 통계"""
    date: str  # YYYY-MM-DD 형식
    user_count: int


class DailyVisitStatsResponse(BaseModel):
    """일별 접속자 수 통계 응답"""
    stats: List[DailyVisitStats]
    total_days: int
    start_date: str
    end_date: str
```

**특징:**
- `DailyVisitStats`: 하루 단위 접속자 수를 담는 스키마
- `date`: YYYY-MM-DD 문자열 형식으로 반환 (프론트엔드 파싱 용이)
- `DailyVisitStatsResponse`: 통계 배열 + 메타 정보 (총 일수, 기간)
- 프론트엔드에서 차트/그래프로 시각화하기 적합한 구조

### 2. backend/main.py 수정 - GET 엔드포인트 구현

**추가: GET /api/v1/game_visits/**
```python
@app.get("/api/v1/game_visits/", response_model=DailyVisitStatsResponse)
def get_daily_visit_stats(
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """게임 일일 접속자 수 조회 (날짜 범위 필터)"""
    from datetime import timedelta
    from sqlalchemy import func

    # 기본값 설정: 최근 7일
    if not end_date:
        end_date_obj = date.today()
    else:
        end_date_obj = date.fromisoformat(end_date)

    if not start_date:
        start_date_obj = end_date_obj - timedelta(days=6)
    else:
        start_date_obj = date.fromisoformat(start_date)

    # 날짜별 접속자 수 집계 (POST에서 이미 일별 IP 중복 방지)
    stats = db.query(
        func.date(GameVisit.created_at).label('visit_date'),
        func.count(GameVisit.id).label('user_count')
    ).filter(
        func.date(GameVisit.created_at) >= start_date_obj,
        func.date(GameVisit.created_at) <= end_date_obj
    ).group_by(
        func.date(GameVisit.created_at)
    ).order_by(
        func.date(GameVisit.created_at)
    ).all()

    # 응답 형식으로 변환
    result = [
        DailyVisitStats(
            date=str(stat.visit_date),
            user_count=stat.user_count
        )
        for stat in stats
    ]

    return DailyVisitStatsResponse(
        stats=result,
        total_days=len(result),
        start_date=str(start_date_obj),
        end_date=str(end_date_obj)
    )
```

**특징:**
- 쿼리 파라미터: `start_date`, `end_date` (선택 사항)
- 기본값: 최근 7일 (end_date: 오늘, start_date: 7일 전)
- `func.date()`: created_at에서 날짜 부분만 추출하여 그룹화
- `func.count(GameVisit.id)`: 레코드 수 집계 (DISTINCT 불필요, POST에서 이미 중복 방지)
- `group_by()`: 날짜별로 그룹화하여 집계
- `order_by()`: 날짜 오름차순 정렬 (시계열 데이터)

### 3. backend/create_mock_visits.py 생성

**추가: Mock 데이터 생성 스크립트**
```python
import random
from datetime import datetime, timedelta
from database import SessionLocal
from models import GameVisit

def create_mock_game_visits(days: int = 30):
    """게임 접속 기록 Mock 데이터 생성"""
    db = SessionLocal()
    try:
        today = datetime.now()

        for day_offset in range(days):
            visit_date = today - timedelta(days=day_offset)
            # 하루에 랜덤하게 5~20명 접속
            num_visits = random.randint(5, 20)

            for i in range(num_visits):
                # 랜덤 IP 생성
                ip = f"192.168.{random.randint(1, 255)}.{random.randint(1, 255)}"
                # 50% 확률로 user_id 할당
                user_id = random.randint(1, 10) if random.random() > 0.5 else None

                # 랜덤 시간 설정 (0~23시)
                visit_time = visit_date.replace(
                    hour=random.randint(0, 23),
                    minute=random.randint(0, 59),
                    second=random.randint(0, 59)
                )

                visit = GameVisit(
                    user_id=user_id,
                    ip_address=ip,
                    is_visits=True,
                    created_at=visit_time
                )
                db.add(visit)

        db.commit()
        print(f"Mock data created: {days}일 동안 접속 기록 생성 완료")
    except Exception as e:
        db.rollback()
        print(f"Error creating mock data: {e}")
    finally:
        db.close()

if __name__ == "__main__":
    create_mock_game_visits(30)
```

**특징:**
- 최근 30일 동안 Mock 데이터 생성
- 하루 5~20명의 랜덤 접속자 (일별 변동성 시뮬레이션)
- 랜덤 IP 생성 (192.168.x.x 사설 IP 대역)
- 50% 확률로 user_id 할당 (회원/비회원 접속 구분)
- 랜덤 시간대 생성 (하루 24시간 분산)
- Docker 컨테이너 내부에서 실행: `docker exec fastapi-server python /code/create_mock_visits.py`

## 아키텍처 구조

### GET API 데이터 흐름
```
Client Request (GET /api/v1/game_visits/?start_date=2026-02-01&end_date=2026-02-07)
     │
     ▼
FastAPI Endpoint
     │
     ├─→ 쿼리 파라미터 파싱
     │   ├─→ start_date 있음? → date.fromisoformat()
     │   │                   → 없음? → 오늘 - 6일
     │   └─→ end_date 있음? → date.fromisoformat()
     │                     → 없음? → 오늘
     │
     ├─→ SQLAlchemy 쿼리 실행
     │   ├─→ SELECT DATE(created_at), COUNT(id)
     │   ├─→ FROM game_visits
     │   ├─→ WHERE DATE(created_at) BETWEEN start_date AND end_date
     │   ├─→ GROUP BY DATE(created_at)
     │   └─→ ORDER BY DATE(created_at) ASC
     │
     ├─→ 결과 변환
     │   └─→ List[DailyVisitStats]
     │
     ▼
Response: DailyVisitStatsResponse
{
  "stats": [
    {"date": "2026-02-01", "user_count": 15},
    {"date": "2026-02-02", "user_count": 20},
    {"date": "2026-02-03", "user_count": 8}
  ],
  "total_days": 3,
  "start_date": "2026-02-01",
  "end_date": "2026-02-03"
}
```

### 날짜별 집계 원리
```
game_visits 테이블 원본 데이터:
┌────┬─────────┬─────────────┬────────────────────┐
│ id │ user_id │ ip_address  │ created_at         │
├────┼─────────┼─────────────┼────────────────────┤
│  1 │    5    │ 192.168.1.1 │ 2026-02-01 10:30:00│
│  2 │   null  │ 192.168.1.2 │ 2026-02-01 14:20:00│
│  3 │    3    │ 192.168.1.3 │ 2026-02-02 09:15:00│
│  4 │    7    │ 192.168.1.4 │ 2026-02-02 15:45:00│
│  5 │   null  │ 192.168.1.5 │ 2026-02-02 18:00:00│
└────┴─────────┴─────────────┴────────────────────┘
                    │
                    ▼ GROUP BY DATE(created_at)
                    ▼ COUNT(id)
┌──────────────┬────────────┐
│ visit_date   │ user_count │
├──────────────┼────────────┤
│ 2026-02-01   │     2      │
│ 2026-02-02   │     3      │
└──────────────┴────────────┘
```

## 결과
- 상태: 완료
- 학습 못함

## 배운내용
ai 가 리스폰스 막 만드는거 같기도하고... 초보랑 고수가 만드는 방식이 달라서 그런가?

## 다음 작업
- fastapi Mock 데이터 삭제
- 프론트 mock 데이터 제거