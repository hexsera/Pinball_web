# 백엔드 구조 개선 - 점진적 실행계획

## 요구사항 요약

**요구사항**: FastAPI 백엔드를 업계 표준 구조로 점진적 리팩토링

**목적**:
- 661줄 main.py의 비대화 해소
- 도메인별 코드 분리로 유지보수성 향상
- 한 단계씩 적용하여 서비스 중단 위험 최소화

## 현재상태 분석

```
fastapi/
├── main.py          (661줄) - 모든 엔드포인트 + 스키마 + 부트스트랩
├── models.py        (55줄)  - 5개 ORM 모델
├── database.py      (39줄)  - DB 연결 설정
├── auth.py          (20줄)  - API Key 인증
├── seed.py          (31줄)  - Admin 시딩
└── alembic/         - 마이그레이션
```

**문제점**:
- main.py에 21개 스키마 + 17개 엔드포인트 집중
- 도메인 간 코드가 섞여 있음 (User, Score, Friend, Monthly)
- 스키마와 라우터가 분리되지 않음

## 구현 방법

**점진적 마이그레이션 전략**:
1. 기존 구조를 유지하면서 새 구조 병행 생성
2. 한 도메인씩 분리 후 테스트
3. 모든 도메인 분리 완료 후 main.py 정리
4. 각 단계 완료 후 docker compose restart로 검증

## 구현 단계

---

### Phase 1: 기본 구조 생성 (코드 변경 없음)

#### 1-1. 폴더 구조 생성

```bash
# fastapi 내부에 app 폴더 구조 생성
mkdir -p fastapi/app/api/v1
mkdir -p fastapi/app/core
mkdir -p fastapi/app/schemas
mkdir -p fastapi/app/db

# 빈 __init__.py 파일 생성 (Python 패키지 인식)
touch fastapi/app/__init__.py
touch fastapi/app/api/__init__.py
touch fastapi/app/api/v1/__init__.py
touch fastapi/app/core/__init__.py
touch fastapi/app/schemas/__init__.py
touch fastapi/app/db/__init__.py
```
- **무엇을 하는가**: Python 패키지 구조 생성
- 기존 코드에 영향 없이 새 폴더만 생성
- __init__.py가 있어야 Python이 패키지로 인식

#### 1-2. 완료 확인

```bash
# 폴더 구조 확인
ls -la fastapi/app/

# Docker 재시작하여 정상 동작 확인
docker compose restart fastapi
docker compose logs fastapi | tail -20
```

**현재 여기까지 완료**
---

### Phase 2: 핵심 설정 분리 (core/)

#### 2-1. config.py 생성

```python
# fastapi/app/core/config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Settings:
    """애플리케이션 설정"""
    # Database
    MYSQL_HOST: str = os.getenv("MYSQL_HOST")
    MYSQL_PORT: str = os.getenv("MYSQL_PORT")
    MYSQL_DATABASE: str = os.getenv("MYSQL_DATABASE")
    MYSQL_USER: str = os.getenv("MYSQL_USER")
    MYSQL_PASSWORD: str = os.getenv("MYSQL_PASSWORD")

    # API Key
    API_KEY: str = os.getenv("API_KEY")

    # Admin Seeding
    ADMIN_EMAIL: str = os.getenv("ADMIN_EMAIL")
    ADMIN_NICKNAME: str = os.getenv("ADMIN_NICKNAME")
    ADMIN_PASSWORD: str = os.getenv("ADMIN_PASSWORD")
    ADMIN_BIRTH_DATE: str = os.getenv("ADMIN_BIRTH_DATE")

    @property
    def DATABASE_URL(self) -> str:
        return f"mysql+pymysql://{self.MYSQL_USER}:{self.MYSQL_PASSWORD}@{self.MYSQL_HOST}:{self.MYSQL_PORT}/{self.MYSQL_DATABASE}"

settings = Settings()
```
- **무엇을 하는가**: 환경변수를 중앙에서 관리
- 모든 설정을 한 곳에서 관리하여 변경 용이
- API_KEY를 환경변수로 이동 (보안 개선)

#### 2-2. security.py 생성

```python
# fastapi/app/core/security.py
from fastapi import HTTPException, Depends
from fastapi.security import APIKeyHeader
from app.core.config import settings

API_KEY_HEADER = APIKeyHeader(name="X-API-Key", auto_error=False)

def verify_api_key(api_key: str = Depends(API_KEY_HEADER)) -> str:
    """API Key 검증 의존성"""
    if api_key is None:
        raise HTTPException(status_code=401, detail="API Key is missing")
    if api_key != settings.API_KEY:
        raise HTTPException(status_code=403, detail="Invalid API Key")
    return api_key
```
- **무엇을 하는가**: 인증 로직을 core/에 통합
- 하드코딩된 API_KEY를 settings에서 가져옴
- 기존 auth.py와 동일한 기능, 구조만 개선

#### 2-3. .env 파일 업데이트

```bash
# fastapi/.env에 추가
API_KEY=hexsera-secret-api-key-2026
```
- **무엇을 하는가**: API Key를 환경변수로 이동
- 코드에서 하드코딩 제거

#### 2-4. 완료 확인

```bash
# Python 문법 검증
docker exec fastapi-server python -c "from app.core.config import settings; print(settings.DATABASE_URL)"
docker exec fastapi-server python -c "from app.core.security import verify_api_key; print('OK')"
```

---

### Phase 3: 데이터베이스 레이어 분리 (db/)

#### 3-1. session.py 생성

```python
# fastapi/app/db/session.py
import time
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

engine = create_engine(settings.DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def wait_for_db(max_retries: int = 10, delay: int = 2) -> bool:
    """DB 연결 대기 (재시도 로직)"""
    retries = 0
    while retries < max_retries:
        try:
            with engine.connect() as conn:
                print("Database connected successfully")
                return True
        except Exception as e:
            retries += 1
            print(f"Database connection failed (attempt {retries}/{max_retries}): {e}")
            if retries < max_retries:
                time.sleep(delay)
    return False
```
- **무엇을 하는가**: DB 연결 설정을 db/로 이동
- config.py의 DATABASE_URL 사용
- 기존 database.py와 동일한 기능

#### 3-2. base.py 생성

```python
# fastapi/app/db/base.py
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

# 모든 모델을 여기서 import하여 Base.metadata에 등록
# Phase 5에서 models/ 분리 후 활성화
# from app.models.user import User
# from app.models.score import Score
# from app.models.friendship import Friendship
# from app.models.visit import Visit
# from app.models.monthly_score import MonthlyScore
```
- **무엇을 하는가**: SQLAlchemy Base 클래스 분리
- 모델 분리 후 한 곳에서 import하여 마이그레이션 지원

#### 3-3. deps.py 생성 (의존성)

```python
# fastapi/app/api/deps.py
from sqlalchemy.orm import Session
from app.db.session import SessionLocal

def get_db():
    """DB 세션 의존성"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```
- **무엇을 하는가**: 공통 의존성을 별도 파일로 분리
- 모든 라우터에서 재사용

#### 3-4. 완료 확인

```bash
# 모듈 import 테스트
docker exec fastapi-server python -c "from app.db.session import engine, SessionLocal, wait_for_db; print('OK')"
docker exec fastapi-server python -c "from app.db.base import Base; print('OK')"
docker exec fastapi-server python -c "from app.api.deps import get_db; print('OK')"
```

---

### Phase 4: 스키마 분리 (schemas/)

#### 4-1. user.py 스키마 생성

```python
# fastapi/app/schemas/user.py
from pydantic import BaseModel
from datetime import date
from typing import Optional

class UserCreateRequest(BaseModel):
    """범용 사용자 생성 요청 (role 포함)"""
    email: str
    nickname: str
    password: str
    birth_date: date
    role: str

class UserRegisterRequest(BaseModel):
    """일반 회원가입 요청 (role 제외)"""
    email: str
    nickname: str
    password: str
    birth_date: date

class UserUpdateRequest(BaseModel):
    """사용자 수정 요청 (모든 필드 선택적)"""
    email: Optional[str] = None
    nickname: Optional[str] = None
    password: Optional[str] = None
    birth_date: Optional[date] = None
    role: Optional[str] = None

class UserResponse(BaseModel):
    """사용자 응답 (password 제외)"""
    id: int
    email: str
    nickname: str
    birth_date: date
    role: str

    class Config:
        from_attributes = True

class LoginRequest(BaseModel):
    """로그인 요청"""
    email: str
    password: str

class LoginResponse(BaseModel):
    """로그인 응답"""
    message: str
    user_id: int
    email: str
    nickname: str
    role: str

class DeleteResponse(BaseModel):
    """삭제 응답"""
    message: str
    deleted_user_id: int
```
- **무엇을 하는가**: User 관련 스키마를 별도 파일로 분리
- main.py에서 그대로 복사한 코드

#### 4-2. score.py 스키마 생성

```python
# fastapi/app/schemas/score.py
from pydantic import BaseModel
from datetime import datetime
from typing import List

class ScoreCreateRequest(BaseModel):
    """점수 기록 생성 요청"""
    user_id: int
    score: int

class ScoreResponse(BaseModel):
    """점수 기록 응답"""
    id: int
    user_id: int
    score: int
    created_at: datetime

    class Config:
        from_attributes = True

class ScoreListResponse(BaseModel):
    """점수 기록 목록 응답"""
    scores: List[ScoreResponse]
    total: int
```
- **무엇을 하는가**: Score 관련 스키마 분리

#### 4-3. monthly_score.py 스키마 생성

```python
# fastapi/app/schemas/monthly_score.py
from pydantic import BaseModel
from datetime import datetime
from typing import List

class MonthlyScoreCreateRequest(BaseModel):
    """월간 점수 생성/수정 요청"""
    user_id: int
    score: int

class MonthlyScoreUpdateRequest(BaseModel):
    """월간 점수 수정 요청"""
    score: int

class MonthlyScoreResponse(BaseModel):
    """월간 점수 응답"""
    user_id: int
    score: int
    created_at: datetime

class MonthlyScoreListResponse(BaseModel):
    """월간 점수 목록 응답"""
    scores: List[MonthlyScoreResponse]
    total: int

class MonthlyScoreDeleteResponse(BaseModel):
    """월간 점수 삭제 응답"""
    message: str
    deleted_user_id: int
```
- **무엇을 하는가**: MonthlyScore 관련 스키마 분리

#### 4-4. friendship.py 스키마 생성

```python
# fastapi/app/schemas/friendship.py
from pydantic import BaseModel
from typing import List

class FriendRequestRequest(BaseModel):
    """친구 요청 생성"""
    requester_id: int
    receiver_id: int

class FriendRequestResponse(BaseModel):
    """친구 요청 응답"""
    message: str
    requester_id: int
    receiver_id: int

class FriendRequestData(BaseModel):
    """친구 요청 데이터"""
    id: int
    requester_id: int
    status: str

class FriendRequestListResponse(BaseModel):
    """친구 요청 목록 응답"""
    requests: List[FriendRequestData]

class FriendRequestActionRequest(BaseModel):
    """친구 요청 승인/거절 요청"""
    requester_id: int
    receiver_id: int

class FriendRequestActionResponse(BaseModel):
    """친구 요청 승인/거절 응답"""
    message: str
    requester_id: int
    receiver_id: int
    status: str
```
- **무엇을 하는가**: Friendship 관련 스키마 분리

#### 4-5. schemas/__init__.py 업데이트

```python
# fastapi/app/schemas/__init__.py
from app.schemas.user import (
    UserCreateRequest,
    UserRegisterRequest,
    UserUpdateRequest,
    UserResponse,
    LoginRequest,
    LoginResponse,
    DeleteResponse,
)
from app.schemas.score import (
    ScoreCreateRequest,
    ScoreResponse,
    ScoreListResponse,
)
from app.schemas.monthly_score import (
    MonthlyScoreCreateRequest,
    MonthlyScoreUpdateRequest,
    MonthlyScoreResponse,
    MonthlyScoreListResponse,
    MonthlyScoreDeleteResponse,
)
from app.schemas.friendship import (
    FriendRequestRequest,
    FriendRequestResponse,
    FriendRequestData,
    FriendRequestListResponse,
    FriendRequestActionRequest,
    FriendRequestActionResponse,
)
```
- **무엇을 하는가**: 모든 스키마를 한 곳에서 import 가능하게 함
- `from app.schemas import UserResponse` 형태로 사용 가능

#### 4-6. 완료 확인

```bash
# 스키마 import 테스트
docker exec fastapi-server python -c "from app.schemas import UserResponse, ScoreResponse; print('OK')"
docker exec fastapi-server python -c "from app.schemas.friendship import FriendRequestRequest; print('OK')"
```

---

### Phase 5: API 라우터 분리 (api/v1/)

#### 5-1. users.py 라우터 생성

```python
# fastapi/app/api/v1/users.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.api.deps import get_db
from app.core.security import verify_api_key
from app.schemas.user import (
    UserCreateRequest,
    UserRegisterRequest,
    UserUpdateRequest,
    UserResponse,
    LoginRequest,
    LoginResponse,
    DeleteResponse,
)
# 기존 models.py 사용 (아직 이동하지 않음)
import sys
sys.path.insert(0, '/code')
from models import User

router = APIRouter()

@router.post("/", response_model=UserResponse)
def create_user(
    user: UserCreateRequest,
    db: Session = Depends(get_db),
    api_key: str = Depends(verify_api_key)
):
    """사용자 생성 (API Key 필요)"""
    existing_user = db.query(User).filter(User.email == user.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")

    db_user = User(**user.dict())
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@router.get("/", response_model=List[UserResponse])
def get_users(
    db: Session = Depends(get_db),
    api_key: str = Depends(verify_api_key)
):
    """전체 사용자 조회 (API Key 필요)"""
    users = db.query(User).all()
    return users

@router.get("/{user_id}", response_model=UserResponse)
def get_user(
    user_id: int,
    db: Session = Depends(get_db),
    api_key: str = Depends(verify_api_key)
):
    """특정 사용자 조회 (API Key 필요)"""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail=f"User with id {user_id} not found")
    return user

@router.put("/{user_id}", response_model=UserResponse)
def update_user(
    user_id: int,
    user_update: UserUpdateRequest,
    db: Session = Depends(get_db),
    api_key: str = Depends(verify_api_key)
):
    """사용자 정보 수정 (API Key 필요)"""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail=f"User with id {user_id} not found")

    if user_update.email and user_update.email != user.email:
        existing_user = db.query(User).filter(User.email == user_update.email).first()
        if existing_user:
            raise HTTPException(status_code=400, detail="Email already registered")

    update_data = user_update.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        if value is not None:
            setattr(user, field, value)

    db.commit()
    db.refresh(user)
    return user

@router.delete("/{user_id}", response_model=DeleteResponse)
def delete_user(
    user_id: int,
    db: Session = Depends(get_db),
    api_key: str = Depends(verify_api_key)
):
    """사용자 삭제 (API Key 필요)"""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail=f"User with id {user_id} not found")

    db.delete(user)
    db.commit()
    return DeleteResponse(message="User deleted successfully", deleted_user_id=user_id)
```
- **무엇을 하는가**: User CRUD 엔드포인트를 별도 라우터로 분리
- 기존 main.py의 코드를 그대로 이동
- 임시로 sys.path로 models.py 참조 (Phase 6에서 정리)

#### 5-2. auth.py 라우터 생성 (로그인/회원가입)

```python
# fastapi/app/api/v1/auth.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.api.deps import get_db
from app.schemas.user import (
    UserRegisterRequest,
    UserResponse,
    LoginRequest,
    LoginResponse,
)
import sys
sys.path.insert(0, '/code')
from models import User

router = APIRouter()

@router.post("/login", response_model=LoginResponse)
def login(login_request: LoginRequest, db: Session = Depends(get_db)):
    """로그인 (인증 불필요)"""
    user = db.query(User).filter(User.email == login_request.email).first()
    if not user or user.password != login_request.password:
        raise HTTPException(status_code=401, detail="Invalid email or password")

    return LoginResponse(
        message="Login successful",
        user_id=user.id,
        email=user.email,
        nickname=user.nickname,
        role=user.role
    )

@router.post("/register", response_model=UserResponse, status_code=201)
def register_user(user: UserRegisterRequest, db: Session = Depends(get_db)):
    """회원가입 (인증 불필요)"""
    existing_user = db.query(User).filter(User.email == user.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")

    db_user = User(**user.dict(), role="user")
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user
```
- **무엇을 하는가**: 로그인/회원가입을 별도 라우터로 분리
- 인증이 필요 없는 공개 엔드포인트

#### 5-3. scores.py 라우터 생성

```python
# fastapi/app/api/v1/scores.py
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.api.deps import get_db
from app.schemas.score import ScoreCreateRequest, ScoreResponse
import sys
sys.path.insert(0, '/code')
from models import Score

router = APIRouter()

@router.post("/", response_model=ScoreResponse, status_code=201)
def create_score(score_data: ScoreCreateRequest, db: Session = Depends(get_db)):
    """점수 기록 생성 (인증 불필요)"""
    db_score = Score(
        id=score_data.user_id,
        user_id=score_data.user_id,
        score=score_data.score
    )
    db.add(db_score)
    db.commit()
    db.refresh(db_score)
    return db_score
```
- **무엇을 하는가**: Score 엔드포인트를 별도 라우터로 분리

#### 5-4. monthly_scores.py 라우터 생성

```python
# fastapi/app/api/v1/monthly_scores.py
from fastapi import APIRouter, HTTPException, Query
from datetime import datetime
from typing import Optional

from app.schemas.monthly_score import (
    MonthlyScoreCreateRequest,
    MonthlyScoreUpdateRequest,
    MonthlyScoreResponse,
    MonthlyScoreListResponse,
    MonthlyScoreDeleteResponse,
)

router = APIRouter()

# 메모리 저장소 (앱 재시작 시 초기화)
monthly_scores_store: dict = {}

@router.post("/", response_model=MonthlyScoreResponse, status_code=201)
def create_or_update_monthly_score(score_data: MonthlyScoreCreateRequest):
    """월간 점수 생성/수정 (최고 점수만 저장)"""
    user_id = score_data.user_id

    if user_id in monthly_scores_store:
        existing_score = monthly_scores_store[user_id]
        if score_data.score > existing_score["score"]:
            monthly_scores_store[user_id] = {
                "user_id": user_id,
                "score": score_data.score,
                "created_at": datetime.now()
            }
    else:
        monthly_scores_store[user_id] = {
            "user_id": user_id,
            "score": score_data.score,
            "created_at": datetime.now()
        }

    return MonthlyScoreResponse(**monthly_scores_store[user_id])

@router.get("/", response_model=MonthlyScoreListResponse)
def get_all_monthly_scores(
    sort_by: Optional[str] = Query("score", description="정렬 기준: score, created_at, user_id"),
    order: Optional[str] = Query("desc", description="정렬 순서: asc, desc")
):
    """전체 월간 점수 조회 (정렬 지원)"""
    scores = list(monthly_scores_store.values())

    reverse = order == "desc"
    if sort_by in ["score", "created_at", "user_id"]:
        scores.sort(key=lambda x: x[sort_by], reverse=reverse)

    return MonthlyScoreListResponse(
        scores=[MonthlyScoreResponse(**s) for s in scores],
        total=len(scores)
    )

@router.get("/{user_id}", response_model=MonthlyScoreResponse)
def get_monthly_score(user_id: int):
    """사용자별 월간 점수 조회"""
    if user_id not in monthly_scores_store:
        raise HTTPException(status_code=404, detail=f"Monthly score for user {user_id} not found")
    return MonthlyScoreResponse(**monthly_scores_store[user_id])

@router.put("/{user_id}", response_model=MonthlyScoreResponse)
def update_monthly_score(user_id: int, score_update: MonthlyScoreUpdateRequest):
    """월간 점수 수정"""
    if user_id not in monthly_scores_store:
        raise HTTPException(status_code=404, detail=f"Monthly score for user {user_id} not found")

    monthly_scores_store[user_id]["score"] = score_update.score
    monthly_scores_store[user_id]["created_at"] = datetime.now()
    return MonthlyScoreResponse(**monthly_scores_store[user_id])

@router.delete("/{user_id}", response_model=MonthlyScoreDeleteResponse)
def delete_monthly_score(user_id: int):
    """월간 점수 삭제"""
    if user_id not in monthly_scores_store:
        raise HTTPException(status_code=404, detail=f"Monthly score for user {user_id} not found")

    del monthly_scores_store[user_id]
    return MonthlyScoreDeleteResponse(
        message="Monthly score deleted successfully",
        deleted_user_id=user_id
    )
```
- **무엇을 하는가**: MonthlyScore 엔드포인트를 별도 라우터로 분리
- 메모리 저장소를 라우터 모듈 내부로 이동

#### 5-5. friends.py 라우터 생성

```python
# fastapi/app/api/v1/friends.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.api.deps import get_db
from app.schemas.friendship import (
    FriendRequestRequest,
    FriendRequestResponse,
    FriendRequestData,
    FriendRequestListResponse,
    FriendRequestActionRequest,
    FriendRequestActionResponse,
)
import sys
sys.path.insert(0, '/code')
from models import Friendship

router = APIRouter()

@router.post("/", response_model=FriendRequestResponse)
def create_friend_request(
    request: FriendRequestRequest,
    db: Session = Depends(get_db)
):
    """친구 요청 생성"""
    # 자신에게 요청 방지
    if request.requester_id == request.receiver_id:
        raise HTTPException(
            status_code=400,
            detail="Cannot send friend request to yourself"
        )

    # 기존 요청 확인 (A→B)
    existing = db.query(Friendship).filter(
        Friendship.requester_id == request.requester_id,
        Friendship.receiver_id == request.receiver_id
    ).first()

    if existing:
        if existing.status == "pending":
            raise HTTPException(status_code=400, detail="Friend request already pending")
        elif existing.status == "accepted":
            raise HTTPException(status_code=400, detail="Already friends")
        elif existing.status == "rejected":
            existing.status = "pending"
            db.commit()
            return FriendRequestResponse(
                message="Friend request sent again",
                requester_id=request.requester_id,
                receiver_id=request.receiver_id
            )

    # 역방향 확인 (B→A)
    reverse = db.query(Friendship).filter(
        Friendship.requester_id == request.receiver_id,
        Friendship.receiver_id == request.requester_id
    ).first()

    if reverse:
        if reverse.status == "pending":
            raise HTTPException(
                status_code=400,
                detail="You have a pending request from this user. Accept it instead."
            )
        elif reverse.status == "accepted":
            raise HTTPException(status_code=400, detail="Already friends")
        elif reverse.status == "rejected":
            pass  # 새 요청 허용

    # 새 요청 생성
    friendship = Friendship(
        requester_id=request.requester_id,
        receiver_id=request.receiver_id,
        status="pending"
    )
    db.add(friendship)
    db.commit()

    return FriendRequestResponse(
        message="Friend request sent successfully",
        requester_id=request.requester_id,
        receiver_id=request.receiver_id
    )

@router.get("/", response_model=FriendRequestListResponse)
def get_friend_requests(receiver_id: int, db: Session = Depends(get_db)):
    """받은 친구 요청 조회"""
    requests = db.query(Friendship).filter(
        Friendship.receiver_id == receiver_id,
        Friendship.status == "pending"
    ).all()

    return FriendRequestListResponse(
        requests=[
            FriendRequestData(
                id=r.id,
                requester_id=r.requester_id,
                status=r.status
            ) for r in requests
        ]
    )

@router.post("/accept", response_model=FriendRequestActionResponse)
def accept_friend_request(
    action: FriendRequestActionRequest,
    db: Session = Depends(get_db)
):
    """친구 요청 승인"""
    friendship = db.query(Friendship).filter(
        Friendship.requester_id == action.requester_id,
        Friendship.receiver_id == action.receiver_id,
        Friendship.status == "pending"
    ).first()

    if not friendship:
        raise HTTPException(status_code=404, detail="Friend request not found")

    friendship.status = "accepted"
    db.commit()

    return FriendRequestActionResponse(
        message="Friend request accepted",
        requester_id=action.requester_id,
        receiver_id=action.receiver_id,
        status="accepted"
    )

@router.post("/reject", response_model=FriendRequestActionResponse)
def reject_friend_request(
    action: FriendRequestActionRequest,
    db: Session = Depends(get_db)
):
    """친구 요청 거절"""
    friendship = db.query(Friendship).filter(
        Friendship.requester_id == action.requester_id,
        Friendship.receiver_id == action.receiver_id,
        Friendship.status == "pending"
    ).first()

    if not friendship:
        raise HTTPException(status_code=404, detail="Friend request not found")

    friendship.status = "rejected"
    db.commit()

    return FriendRequestActionResponse(
        message="Friend request rejected",
        requester_id=action.requester_id,
        receiver_id=action.receiver_id,
        status="rejected"
    )
```
- **무엇을 하는가**: Friendship 엔드포인트를 별도 라우터로 분리
- 친구 요청 검증 로직 포함

#### 5-6. api/v1/__init__.py 업데이트

```python
# fastapi/app/api/v1/__init__.py
from app.api.v1 import users, auth, scores, monthly_scores, friends
```
- **무엇을 하는가**: 모든 라우터를 한 곳에서 export

---

### Phase 6: main.py 리팩토링

#### 6-1. 새로운 main.py 작성

```python
# fastapi/main.py (새로운 버전)
from fastapi import FastAPI

# 새 구조의 모듈 import
from app.db.session import engine, SessionLocal, wait_for_db
from app.db.base import Base
from app.api.v1 import users, auth, scores, monthly_scores, friends

# 기존 models.py 사용 (models/ 분리는 선택사항)
from models import User, Score, Friendship, Visit, MonthlyScore

# 기존 seed.py 사용
from seed import seed_admin

# 부트스트랩
print("Starting FastAPI application...")

if not wait_for_db():
    raise Exception("Database connection failed after retries")

print("Creating database tables...")
Base.metadata.create_all(bind=engine)
print("Database tables created successfully")

print("Starting data seeding...")
db = SessionLocal()
try:
    seed_admin(db)
finally:
    db.close()
print("Data seeding completed")

# FastAPI 앱 생성
app = FastAPI(
    title="Pinball API",
    description="핀볼 게임 웹 플랫폼 API",
    version="1.0.0"
)

# 라우터 등록
app.include_router(users.router, prefix="/api/v1/users", tags=["Users"])
app.include_router(auth.router, prefix="/api/v1", tags=["Auth"])
app.include_router(scores.router, prefix="/api/v1/scores", tags=["Scores"])
app.include_router(monthly_scores.router, prefix="/api/v1/monthly-scores", tags=["Monthly Scores"])
app.include_router(friends.router, prefix="/api/friend-requests", tags=["Friends"])

# 헬스 체크 엔드포인트
@app.get("/api/")
def health_check():
    return {"message": "Hello, FastAPI!"}

@app.get("/api/test")
def test():
    return {"message": "API is working!"}
```
- **무엇을 하는가**: main.py를 라우터 등록만 담당하도록 간소화
- 661줄 → 약 50줄로 축소
- 기존 models.py, seed.py는 그대로 사용 (추가 분리는 선택사항)

#### 6-2. 기존 main.py 백업

```bash
# 기존 main.py 백업
cp fastapi/main.py fastapi/main.py.backup
```

#### 6-3. 완료 확인

```bash
# Docker 재시작
docker compose restart fastapi

# 로그 확인
docker compose logs fastapi | tail -30

# API 테스트
curl http://localhost:8000/api/test
curl http://localhost:8000/api/docs
```

---

### Phase 7: 최종 검증

#### 7-1. 전체 엔드포인트 테스트

```bash
# 헬스 체크
curl http://localhost:8000/api/
curl http://localhost:8000/api/test

# 회원가입 테스트
curl -X POST http://localhost:8000/api/v1/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","nickname":"tester","password":"1234","birth_date":"2000-01-01"}'

# 로그인 테스트
curl -X POST http://localhost:8000/api/v1/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"1234"}'

# 사용자 조회 (API Key 필요)
curl http://localhost:8000/api/v1/users \
  -H "X-API-Key: hexsera-secret-api-key-2026"

# 점수 저장
curl -X POST http://localhost:8000/api/v1/scores \
  -H "Content-Type: application/json" \
  -d '{"user_id":1,"score":15000}'

# 월간 점수 저장
curl -X POST http://localhost:8000/api/v1/monthly-scores \
  -H "Content-Type: application/json" \
  -d '{"user_id":1,"score":20000}'

# Swagger UI 확인
# 브라우저에서 http://localhost:8000/api/docs 접속
```

#### 7-2. React 연동 테스트

```bash
# React 개발 서버 실행
cd react/main && npm run start

# 로그인/회원가입/게임 플레이 테스트
# Dashboard에서 계정, 게임하기 기능 확인
```

---

## 수정/생성할 파일 목록

| 파일 경로 | 작업 유형 | Phase | 변경 내용 |
|-----------|-----------|-------|-----------|
| fastapi/app/__init__.py | 생성 | 1 | 빈 파일 (패키지 인식) |
| fastapi/app/api/__init__.py | 생성 | 1 | 빈 파일 |
| fastapi/app/api/v1/__init__.py | 생성/수정 | 1, 5 | 라우터 export |
| fastapi/app/core/__init__.py | 생성 | 1 | 빈 파일 |
| fastapi/app/core/config.py | 생성 | 2 | 환경변수 설정 |
| fastapi/app/core/security.py | 생성 | 2 | API Key 인증 |
| fastapi/app/db/__init__.py | 생성 | 1 | 빈 파일 |
| fastapi/app/db/session.py | 생성 | 3 | DB 연결 설정 |
| fastapi/app/db/base.py | 생성 | 3 | SQLAlchemy Base |
| fastapi/app/api/deps.py | 생성 | 3 | 공통 의존성 |
| fastapi/app/schemas/__init__.py | 생성/수정 | 1, 4 | 스키마 export |
| fastapi/app/schemas/user.py | 생성 | 4 | User 스키마 |
| fastapi/app/schemas/score.py | 생성 | 4 | Score 스키마 |
| fastapi/app/schemas/monthly_score.py | 생성 | 4 | MonthlyScore 스키마 |
| fastapi/app/schemas/friendship.py | 생성 | 4 | Friendship 스키마 |
| fastapi/app/api/v1/users.py | 생성 | 5 | User CRUD 라우터 |
| fastapi/app/api/v1/auth.py | 생성 | 5 | 로그인/회원가입 라우터 |
| fastapi/app/api/v1/scores.py | 생성 | 5 | Score 라우터 |
| fastapi/app/api/v1/monthly_scores.py | 생성 | 5 | MonthlyScore 라우터 |
| fastapi/app/api/v1/friends.py | 생성 | 5 | Friendship 라우터 |
| fastapi/main.py | 수정 | 6 | 라우터 등록으로 간소화 |
| fastapi/.env | 수정 | 2 | API_KEY 환경변수 추가 |

## 단계별 진행 요약

| Phase | 작업 내용 | 위험도 | 예상 소요 |
|-------|-----------|--------|-----------|
| 1 | 폴더 구조 생성 | 없음 | 빈 폴더만 생성 |
| 2 | core/ 설정 분리 | 낮음 | 새 파일 생성만 |
| 3 | db/ 레이어 분리 | 낮음 | 새 파일 생성만 |
| 4 | schemas/ 분리 | 낮음 | 스키마 복사 |
| 5 | api/v1/ 라우터 분리 | 중간 | 엔드포인트 이동 |
| 6 | main.py 리팩토링 | 높음 | 기존 코드 교체 |
| 7 | 최종 검증 | 없음 | 테스트만 |

**권장 진행 방식**:
- Phase 1~4: 기존 코드에 영향 없이 새 파일만 생성
- Phase 5: 라우터 생성 후 main.py에서 테스트 import
- Phase 6: 모든 테스트 통과 후 main.py 교체
- 각 Phase 완료 후 `docker compose restart fastapi`로 검증

## 완료 체크리스트

### Phase 1 완료
- [ ] fastapi/app/ 폴더 구조가 생성되었다
- [ ] 모든 __init__.py 파일이 존재한다
- [ ] `docker compose restart fastapi` 후 정상 동작한다

### Phase 2 완료
- [ ] fastapi/app/core/config.py가 존재한다
- [ ] fastapi/app/core/security.py가 존재한다
- [ ] .env에 API_KEY가 추가되었다
- [ ] `docker exec fastapi-server python -c "from app.core.config import settings; print(settings.API_KEY)"` 성공

### Phase 3 완료
- [ ] fastapi/app/db/session.py가 존재한다
- [ ] fastapi/app/db/base.py가 존재한다
- [ ] fastapi/app/api/deps.py가 존재한다
- [ ] `docker exec fastapi-server python -c "from app.api.deps import get_db; print('OK')"` 성공

### Phase 4 완료
- [ ] fastapi/app/schemas/ 폴더에 4개 스키마 파일이 존재한다
- [ ] `docker exec fastapi-server python -c "from app.schemas import UserResponse; print('OK')"` 성공

### Phase 5 완료
- [ ] fastapi/app/api/v1/ 폴더에 5개 라우터 파일이 존재한다
- [ ] 각 라우터 파일이 문법 오류 없이 import된다

### Phase 6 완료
- [ ] main.py가 50줄 이내로 간소화되었다
- [ ] main.py.backup 백업 파일이 존재한다
- [ ] `docker compose restart fastapi` 후 정상 동작한다

### Phase 7 완료 (최종)
- [ ] http://localhost:8000/api/docs 에서 모든 엔드포인트가 표시된다
- [ ] 회원가입 API가 정상 동작한다 (201 응답)
- [ ] 로그인 API가 정상 동작한다 (200 응답)
- [ ] 사용자 조회 API가 API Key와 함께 정상 동작한다
- [ ] 점수 저장 API가 정상 동작한다
- [ ] 월간 점수 API가 정상 동작한다
- [ ] 친구 요청 API가 정상 동작한다
- [ ] React 프론트엔드에서 로그인/게임 플레이가 정상 동작한다
