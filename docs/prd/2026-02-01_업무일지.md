# 업무일지

## 기본 정보
- 날짜: 2026-02-01 (일) 12:03~13:00
- 작성자: hexsera

## 진행 목표
핀볼 게임 종료 시 게임 오버 오버레이 UI를 표시하고, 획득한 점수를 월간 랭킹 API에 POST하여 최고점수를 갱신하고 오버레이에 표시하는 기능 구현 (PHASE 1 + PHASE 2)

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| overlayState 상태 추가 | react/main/src/Pinball.jsx | null / 'gameOver' 값으로 오버레이 종류 관리 |
| 게임 오버 시 오버레이 트리거 | react/main/src/Pinball.jsx | 목숨 0일 때 setOverlayState('gameOver') 호출 |
| 범용 인게임 오버레이 UI 추가 | react/main/src/Pinball.jsx | 게임 캔버스 영역(1100px) 위에 position: absolute로 배치 |
| axios, AuthContext import 추가 | react/main/src/Pinball.jsx | API 호출 및 사용자 정보 접근용 |
| bestScore 상태 및 submitScore 함수 구현 | react/main/src/Pinball.jsx | POST 응답의 score를 최고점수로 세팅 |
| 게임 오버 시 submitScore 호출 | react/main/src/Pinball.jsx | setOverlayState 다음 줄에 추가 |
| 오버레이 최고점수 표시에 bestScore 연결 | react/main/src/Pinball.jsx | null이면 '---', 아니면 실제 값 표시 |

## 주요 변경 사항

### 1. react/main/src/Pinball.jsx 수정

#### import 추가

**변경 전:**
```jsx
import { useEffect, useRef, useState, useCallback } from 'react';
import Matter from 'matter-js';
import { Button, Box, Typography } from '@mui/material';
```

**변경 후:**
```jsx
import { useEffect, useRef, useState, useCallback } from 'react';
import Matter from 'matter-js';
import axios from 'axios';
import { Button, Box, Typography } from '@mui/material';
import { useAuth } from './AuthContext';
```

---

#### 상태 변수 및 useAuth 추가

**변경 전:**
```jsx
function Pinball() {
  const sceneRef = useRef(null);
  // ...
  const [lives, setLives] = useState(3);
  const [windowSize, setWindowSize] = useState({
```

**변경 후:**
```jsx
function Pinball() {
  const { user } = useAuth();
  const sceneRef = useRef(null);
  // ...
  const [lives, setLives] = useState(3);
  const [overlayState, setOverlayState] = useState(null);
  const [bestScore, setBestScore] = useState(null);
  const [windowSize, setWindowSize] = useState({
```

**특징:**
- `useAuth()`에서 현재 로그인한 사용자의 `user` 객체를 가져옴 (`user.id`로 사용자 ID 접근)
- `overlayState`: 현재 표시할 오버레이 종류를 관리하는 단일 상태 (`null` → 숨김, `'gameOver'` → 게임 오버 콘텐츠)
- `bestScore`: POST 응답에서 받은 최고점수를 저장하는 상태 (초기값 `null`)

---

#### submitScore 함수 추가

**변경 전:**
```jsx
  // 최적 스케일 계산 함수
  const calculateScale = useCallback(() => {
```

**변경 후:**
```jsx
  // 점수 전송 및 최고점수 갱신 함수
  const submitScore = async () => {
    if (!user || !user.id) {
      console.log('User not logged in, score not submitted');
      return;
    }

    try {
      const response = await axios.post('/api/v1/monthly-scores', {
        user_id: user.id,
        score: score
      });
      console.log('Score submitted successfully:', response.data);
      setBestScore(response.data.score);
    } catch (error) {
      console.error('Failed to submit score:', error);
    }
  };

  // 최적 스케일 계산 함수
  const calculateScale = useCallback(() => {
```

**특징:**
- 로그인하지 않은 사용자는 점수 전송을 건너뜀 (console.log로 안내)
- POST `/api/v1/monthly-scores`는 Upsert 로직: 기존 점수보다 높을 때만 갱신하고, 갱신된 최고점수를 응답에 반환
- 응답의 `score` 값을 `bestScore`로 세팅하여 별도 GET 호출 없이 최고점수가 바로 결정됨

---

#### 게임 오버 시 오버레이 트리거 및 점수 전송

**변경 전:**
```jsx
          } else {
            // 생명이 없으면 공 제거 (게임 오버)
            World.remove(engine.world, ball);
            console.log('Game Over!');
          }
```

**변경 후:**
```jsx
          } else {
            // 생명이 없으면 공 제거 (게임 오버)
            World.remove(engine.world, ball);
            console.log('Game Over!');
            setOverlayState('gameOver');
            submitScore();
          }
```

**특징:**
- `setOverlayState('gameOver')`: 오버레이 UI를 즉시 표시
- `submitScore()`: 점수를 API에 전송하고, 응답 후 최고점수 갱신 (비동기)

---

#### 범용 인게임 오버레이 UI 추가

**변경 전:**
```jsx
          {/* 게임 영역 (하단 900px) */}
          <Box sx={{
            width: '700px',
            height: '1100px',
            backgroundImage: 'url(/images/pinball_back.png)',
            backgroundSize: '100% 100%',
            backgroundPosition: 'center',
            backgroundRepeat: 'no-repeat'
          }}>
            <div ref={sceneRef} />
          </Box>
```

**변경 후:**
```jsx
          {/* 게임 영역 (하단 1100px) */}
          <Box sx={{
            position: 'relative',
            width: '700px',
            height: '1100px',
            backgroundImage: 'url(/images/pinball_back.png)',
            backgroundSize: '100% 100%',
            backgroundPosition: 'center',
            backgroundRepeat: 'no-repeat'
          }}>
            <div ref={sceneRef} />

            {/* 인게임 오버레이 (게임 캔버스 영역 위) */}
            {overlayState && (
              <Box
                sx={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '100%',
                  height: '100%',
                  backgroundColor: 'rgba(0, 0, 0, 0.8)',
                  display: 'flex',
                  flexDirection: 'column',
                  justifyContent: 'center',
                  alignItems: 'center',
                  zIndex: 10,
                }}
              >
                {overlayState === 'gameOver' && (
                  <>
                    <Typography variant="h2" sx={{ color: '#ff0000', fontWeight: 'bold', mb: 4 }}>
                      GAME OVER
                    </Typography>
                    <Typography variant="h4" sx={{ color: '#ffffff', mb: 2 }}>
                      획득 점수: {score}
                    </Typography>
                    <Typography variant="h5" sx={{ color: '#ffff00', mb: 4 }}>
                      최고 점수: {bestScore !== null ? bestScore : '---'}
                    </Typography>
                    <Button
                      variant="contained"
                      disabled
                      sx={{ fontSize: '1.2rem', padding: '10px 30px' }}
                    >
                      다시 시작
                    </Button>
                  </>
                )}
              </Box>
            )}
          </Box>
```

**특징:**
- 게임 영역 Box에 `position: 'relative'` 추가하여 오버레이의 절대 배치 기준점 설정
- 오버레이는 게임 캔버스 영역(1100px)만 덮음 (상단 UI Bar 아래)
- 외부 Box는 범용 구조로, `overlayState` 값에 따라 내부 콘텐츠를 분기 렌더링 (향후 'pause' 등 추가 가능)
- 최고 점수: `bestScore`가 `null`이면 `---` 표시, API 응답 후 실제 값으로 갱신
- 다시시작 버튼: `disabled` 상태 (기능 미구현)

---

### 데이터 흐름

```
게임 오버 발생 (목숨 0)
        │
        ▼
  World.remove(ball)          ← 공 제거
  setOverlayState('gameOver') ← 오버레이 즉시 표시
  submitScore()               ← 비동기 점수 전송
        │
        ▼
  POST /api/v1/monthly-scores
  { user_id, score }
        │
        ▼
  백엔드 Upsert 로직
  ├── 기존 점수 없음 → INSERT
  └── 기존 점수 있음 → 새 점수가 더 높으면 UPDATE
        │
        ▼
  응답: { user_id, score (최고점수), created_at }
        │
        ▼
  setBestScore(response.data.score)
        │
        ▼
  오버레이 최고 점수 표시 갱신
```

## 결과
- 상태: 완료
- PHASE 1 (범용 오버레이 구조 + 게임 오버 콘텐츠): 완료
- PHASE 2 (월간 점수 API 연동 + 최고점수 표시): 완료

## 배운내용

## 다음 작업
- 다시시작 버튼 기능 구현 (overlayState를 null로 리셋하고 공/목숨 초기화)
- 최고점수 조회: 게임 시작 시에도 기존 최고점수를 GET으로 가져오기
- 점수 시스템 구현 (현재 score는 하드코딩 값)
- 사용자 정보 수정시 localstroge 업데이트.

---

# 업무일지 2

## 기본 정보
- 날짜: 2026-02-01 (일)
- 작성자: hexsera

## 진행 목표
핀볼 게임의 벽, 바닥, 플리퍼를 재배치하여 깔대기(funnel) 구조로 변경한다. 벽을 두꺼운 40px로 변경하고, 평탄한 바닥을 깔대기 형태의 경사면으로 구성하여 공이 중앙 구멍으로 모이도록 하며, 플리퍼를 깔대기 구멍 앞에 배치한다.

## 진행 내용

| 작업 | 수정 파일 | 비고 |
|------|----------|------|
| 벽 두께 증가 (20px → 40px) | react/main/src/Pinball.jsx | 왼쪽/오른쪽/천장 벽 두께 변경, 왼쪽 내면 x=40, 오른쪽 내면 x=660 |
| 평탄한 바닥(ground) 제거 | react/main/src/Pinball.jsx | 깔대기 경사면으로 대체 |
| 깔대기 경사면 생성 | react/main/src/Pinball.jsx | rectangle + Body.setAngle() 방식으로 왼쪽/오른쪽 경사면 구성 |
| 플리퍼 및 회전축 재배치 | react/main/src/Pinball.jsx | 구멍(x=270~430) 안쪽에 배치, 회전축도 구멍 양끝으로 이동 |
| 죽음구역(deathZone) 재배치 | react/main/src/Pinball.jsx | 구멍 아래로 이동 (폭 160px) |
| World.add 목록 수정 | react/main/src/Pinball.jsx | ground 제거, leftFunnelWall·rightFunnelWall 추가 |
| 실행계획 문서 작성 및 업데이트 | docs/prd/핀볼게임오브젝트재배치-실행계획.md | fromVertices → rectangle 방식으로 전환 후 문서도 갱신 |

## 주요 변경 사항

### 1. react/main/src/Pinball.jsx 수정

#### 벽 두께 증가

**변경 전:**
```jsx
const ground = Bodies.rectangle(350, 1200, 700, 20, { ... });
const leftWall = Bodies.rectangle(0, 600, 20, 1200, { ... });
const rightWall = Bodies.rectangle(700, 600, 20, 1200, { ... });
const upWall = Bodies.rectangle(350, 0, 700, 20, { ... });
```

**변경 후:**
```jsx
const leftWall = Bodies.rectangle(20, 550, 40, 1100, { ... });   // 두께 40px, 내면 x=40
const rightWall = Bodies.rectangle(680, 550, 40, 1100, { ... });  // 두께 40px, 내면 x=660
const upWall = Bodies.rectangle(350, 20, 700, 40, { ... });       // 두께 40px
// ground 제거됨
```

**특징:**
- 벽 두께를 20px에서 40px로 증가하여 공이 벽과 경사면 사이로 빠져나갈 수 없도록 함
- ground는 깔대기 경사면으로 대체되어 제거됨

---

#### 깔대기 경사면 생성

**변경 전:**
```jsx
// 평탄한 바닥만 존재
const ground = Bodies.rectangle(350, 1200, 700, 20, { isStatic: true, ... });
```

**변경 후:**
```jsx
const FUNNEL_LENGTH = Math.sqrt(230 * 230 + 130 * 130); // ≈ 264.2px
const FUNNEL_ANGLE = Math.atan2(130, 230);              // ≈ 0.515 rad (29.5°)
const FUNNEL_THICKNESS = 40;

// 왼쪽 경사면 (중심: x=155, y=1015)
const leftFunnelWall = Bodies.rectangle(155, 1015, FUNNEL_LENGTH, FUNNEL_THICKNESS, {
  isStatic: true,
  render: { fillStyle: '#16213e' }
});
Body.setAngle(leftFunnelWall, FUNNEL_ANGLE);   // 오른쪽 아래로 회전

// 오른쪽 경사면 (중심: x=545, y=1015)
const rightFunnelWall = Bodies.rectangle(545, 1015, FUNNEL_LENGTH, FUNNEL_THICKNESS, {
  isStatic: true,
  render: { fillStyle: '#16213e' }
});
Body.setAngle(rightFunnelWall, -FUNNEL_ANGLE); // 왼쪽 아래로 회전 (대칭)
```

**특징:**
- 왼쪽 경사면: (40, 950)에서 (270, 1080)으로 내려오는 경사면
- 오른쪽 경사면: (660, 950)에서 (430, 1080)으로 내려오는 경사면 (왼쪽과 대칭)
- `-FUNNEL_ANGLE`로 오른쪽 경사면을 왼쪽과 대칭 회전

---

#### 플리퍼 및 회전축 재배치

**변경 전:**
```jsx
const leftFlipper = Bodies.rectangle(200, 1150, 100, 20, { ... });
const rightFlipper = Bodies.rectangle(550, 1150, 100, 20, { ... });

// 왼쪽 회전축
pointB: { x: 210, y: 1150 }
// 오른쪽 회전축
pointB: { x: 540, y: 1150 }
```

**변경 후:**
```jsx
// 왼쪽 플리퍼 — 회전축 x=270, 중심 = 회전축 + 길이절반(50) = x=320
const leftFlipper = Bodies.rectangle(320, 1090, 100, 20, { ... });
// 오른쪽 플리퍼 — 회전축 x=430, 중심 = 회전축 - 길이절반(50) = x=380
const rightFlipper = Bodies.rectangle(380, 1090, 100, 20, { ... });

// 왼쪽 회전축 — 경사면 끝점 왼쪽
pointB: { x: 270, y: 1090 }
// 오른쪽 회전축 — 경사면 끝점 오른쪽
pointB: { x: 430, y: 1090 }
```

**특징:**
- 플리퍼를 깔대기 구멍(x=270~430) 안쪽에 배치하여 공이 떨어지기 직전에 쳐낼 수 있도록 함
- 왼쪽 플리퍼 중심 x=320: 회전축(x=270) + 플리퍼 길이절반(50px)
- 오른쪽 플리퍼 중심 x=380: 회전축(x=430) - 플리퍼 길이절반(50px)

---

#### 죽음구역 재배치

**변경 전:**
```jsx
const deathZone = Bodies.rectangle(350, 1200, 700, 40, { ... });  // 바닥 전체 폭
```

**변경 후:**
```jsx
const deathZone = Bodies.rectangle(350, 1095, 160, 30, { ... });  // 구멍 폭만큼
```

**특征:**
- 폭을 700px에서 160px로 축소하여 깔대기 구멍 폭과 동일
- 공이 플리퍼를 통과한 후에만 죽음구역에 진입

---

### 깔대기 구조 다이어그램

```
왼쪽벽(40px)                              오른쪽벽(40px)
│  x=40                              x=660  │
│   \                                  /    │
│    \  경사면 시작 y=950             /     │
│     \                              /      │
│      \                            /       │
│       \  경사면 끝 y=1080        /        │
│        x=270 ─[왼플]─[오플]─ x=430       │
│              │  구멍 160px  │             │
│              │  deathZone   │             │
│              │   y=1095     │             │
```

## 결과
- 상태: 미완료
- 세부조정을 손으로 하니깐 너무 오래 걸림
- 기타 오브젝트 세부조정 미완료

## 배운내용

## 다음 작업
- 경사면·플리퍼 좌표 최종 확인 및 테스트 완료
- 경사면과 왼쪽/오른쪽 벽 사이 틈 확인 및 보완
- 공 초기 위치 조정 (깔대기 구조와 맞추기)